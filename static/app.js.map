{"version":3,"sources":["webpack:///app.js","webpack:///webpack/bootstrap ddb8f9f6711a7d473cad","webpack:///../~/riot/riot.js","webpack:///../~/promissory-arbiter/src/promissory-arbiter.js","webpack:///./store/index.js","webpack:///./components/anon_homepage.tag","webpack:///./components/app.tag","webpack:///./components/control.tag","webpack:///./components/drafteditpage.tag","webpack:///./components/homepage.tag","webpack:///./components/job.tag","webpack:///./components/loggedin_homepage.tag","webpack:///./components/login.tag","webpack:///./components/macaroon.tag","webpack:///./components/modal.tag","webpack:///./components/only-logo.tag","webpack:///./components/poller.tag","webpack:///./components/router.tag","webpack:///./components/signuporsignin.tag","webpack:///./components/topnav.tag","webpack:///./components/tsform.tag","webpack:///./actions/index.js","webpack:///./main.js","webpack:///../~/watchjs/src/watch.js","webpack:///../~/webpack/buildin/amd-options.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","window","undefined","mkitem","expr","key","val","item","pos","unmountRedundant","items","tags","t","i","length","j","splice","unmount","moveNestedTags","child","Object","keys","forEach","tagName","tag","isArray","each","moveChildTag","addVirtual","src","target","sib","el","_root","_virts","nextSibling","insertBefore","appendChild","push","moveVirtual","len","_each","dom","parent","remAttr","hasKeys","mustReorder","getAttr","T_STRING","getTagName","impl","__tagImpl","tmpl","getOuterHTML","useRoot","SPECIAL_TAGS_REGEX","test","root","parentNode","ref","document","createTextNode","getTag","isOption","toLowerCase","oldItems","isVirtual","loopKeys","one","removeChild","stub","on","frag","createDocumentFragment","map","itemsLength","_mustReorder","T_OBJECT","oldPos","indexOf","Tag","isLoop","hasImpl","cloneNode","innerHTML","mount","firstChild","update","childNodes","_item","defineProperty","FIREFOX","multiple","n","__riot1374","selectedIndex","slice","parseNamedElements","childTags","forceParsingNamed","walk","nodeType","initChildTag","setNamed","parseExpressions","expressions","addExpr","extra","hasExpr","extend","attr","type","nodeValue","attributes","name","bool","split","value","conf","updateOpts","ctx","self","opts","toCamel","normalizeData","data","T_UNDEF","isWritable","inheritFromParent","k","mustSync","RESERVED_WORDS_BLACKLIST","contains","propsInSyncWithParent","onChildUpdate","toggle","isMount","evt","riot","observable","this","inherit","cleanUpData","_tag","isMounted","__uid","mkdom","isInherited","isObject","trigger","rAF","arguments","mix","instance","mixin","isFunction","prototype","getOwnPropertyNames","bind","init","globalMixin","GLOBAL_MIXIN","hasOwnProperty","fn","attrs","walkAttributes","v","setAttr","isInStub","keepRootTag","ptag","tagIndex","__virtualDom","getImmediateCustomParentTag","_riot_id","RIOT_TAG_IS","RIOT_TAG","off","setEventHandler","handler","e","_parent","event","currentTarget","srcElement","which","charCode","keyCode","preventDefault","returnValue","preventUpdate","insertTo","node","before","attrName","IE_VERSION","add","remove","inStub","style","display","startsWith","RIOT_PREFIX","els","T_FUNCTION","outerHTML","container","mkEl","setInnerHTML","html","doc","DOMParser","parseFromString","ownerDocument","importNode","documentElement","isSVGTag","SVG_TAGS_LIST","removeAttribute","string","replace","_","toUpperCase","getAttribute","setAttribute","addChildTag","cachedTag","newPos","options","enumerable","writable","configurable","namedTag","obj","args","arr","a","Array","props","getOwnPropertyDescriptor","o","re","exec","isSvg","createElementNS","createElement","$$","selector","querySelectorAll","$","querySelector","Child","getNamedKey","isArr","str","mountTo","_innerHTML","version","settings","documentMode","InstallTrigger","onEachEvent","indx","es","l","substring","callbacks","defineProperties","events","ns","typed","cb","apply","fns","arglen","busy","concat","DEFAULT_PARSER","path","DEFAULT_SECOND_PARSER","filter","RegExp","REPLACE","match","debounce","delay","clearTimeout","setTimeout","start","autoExec","debouncedEmit","emit","win","ADD_EVENT_LISTENER","POPSTATE","HASHCHANGE","clickEvent","click","Router","central","s","normalize","isString","getPathFromRoot","href","loc","RE_ORIGIN","getPathFromBase","base","force","isRoot","emitStackLevel","MAX_EMIT_STACK_LEVEL","emitStack","current","TRIGGER","shift","metaKey","ctrlKey","shiftKey","defaultPrevented","nodeName","HAS_ATTRIBUTE","go","title","shouldReplace","hist","replaceState","pushState","routeFound","parser","secondParser","EVENT_LISTENER","REMOVE_EVENT_LISTENER","history","location","prot","ontouchstart","started","first","second","third","r","some","action","mainRouter","route","create","newSubRouter","router","stop","arg","fn2","query","q","readyState","brackets","UNDEF","_loopback","_rewrite","bp","_cache","source","global","REGLOB","_create","pair","DEFAULT","_pairs","Error","S_QBLOCKS","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","b","set","get","_settings","R_MLCOMMS","R_STRINGS","FINDBRACES","(","[","{","_bp","unescapeStr","isexpr","parts","skipBraces","ch","ix","recch","lastIndex","index","trim","array","_tmpl","_logErr","err","errorHandler","riotData","_getTmpl","Function","qstr","RE_DQUOTE","list","_parseExpr","join","RE_QBMARK","asText","mm","lv","ir","RE_BREND","RE_QBLOCK","div","CH_IDEXPR","cnt","RE_CSNAME","jsb","rightContext","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","haveRaw","hasRaw","parse","_mkdom","templ","replaceYield","tblTags","specialTags","select","tname","rootEls","childElementCount","reHasYield","reYieldSrc","text","reYieldDest","def","reYieldAll","tr","th","td","col","styleManager","_riot","inject","styleNode","newNode","userNode","replaceChild","getElementsByTagName","cssTextProp","styleSheet","stylesToInject","css","cssText","w","raf","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","navigator","userAgent","lastTime","nowtime","Date","now","timeout","Math","max","util","mixins","globals","_id","g","store","tag2","addRiotTags","selectAllTags","pushTags","riotTag","allTags","nodeList","_el","vdom","factory","define","subscribe","state","topic","subscription","context","assert","merge","ancestor","addTopicLine","ancestorTopicSearch","_topics","insert","getPriority","createSubscription","subscriptions","subscriptionToken","priority","ignorePersisted","persisted","persistedDescendents","getPersisted","descendents","persistedMessages","mergeBy","getFingerArrayOrder","suspended","publish","sync","hierarchicalTopicDispatcher","async","unsubscribe","tokens","suspend","result","curryMap","topics","removeSubscriber","resubscribe","unsuspendSubscriber","removePersisted","token","applyTopicDescendents","empty","tokenTopic","binaryIndexBy","getId","persistedMessage","order","createNode","persist","preventBubble","latch","settlementLatch","semaphor","Infinity","updateAfterSettlement","arbiter","mkGenerator","partial1","subscribeDispatcher","removePersistedDispatcher","lineage","findLineage","getTopic","isAncestorTopic","topicNode","getFingerArrayPriority","getSubscriptions","fulfilledPromise","subscriptionDispatcher","resumeSubscriptionDispatcher","resolver","fulfill","reject","promise","pending","subscriptionInvoker","then","createResolver","resolveUse","resume","evaluateLatch","appendList","increment","settled","fulfilled","rejected","maxFulfilled","total","rejectedValues","fulfilledValues","Promise","succ","resolve","subscribeTopicApplier","f","property","unsuspendTopic","searchAround","unsuspendNode","suspendSubs","suspendTopic","suspendNode","ancestorSearch","ancestorTopic","additionalTopics","reduce","appendPrefixedTopic","substr","addFamilyLine","addChildTopic","tree","addChild","prefix","nodeTopic","fingerArray","getPointedFinger","SYMBOL_NOTHING","getOrder","persistedSubscription","prop","noop","children","getValue","isAncestor","childIndex","foundChild","child1","child0","appendDescendents","next","addChildToTree","line","newChild","getItemOrder","arrays","min","getLength","fingerArrays","mkFingerArray","minBy","pointer","getConditionValue","conditionValue","elm","mid","elem","low","high","valueComputer","computedCurrent","idx","winner","computedWinner","fArray","invoke","x","identity","unshift","seed","haystack","needle","startPosition","lastIndexOf","y","expected","method","identifier","Arbiter","WatchJS","watch","unwatch","payload","mutation","console","log","mutations","guid","s4","floor","random","toString","profile","username","modals","registration","content","buttons","color","login","forms","fields","label","input_type","placeholder","valid","pristine","error","registration_flow","registration_submitted","registration_sent_remote","registration_failed","status","message","registration_succeeded","authentication_flow","login_submitted","login_sent_remote","login_failed","login_succeeded","macaroon","remote_requests","credentials","password","authenticated","routes","startup_selected_or_created","change_registration_state","new_state","update_modal_state","modal_name","change_form_state","update_form","form","change_login_state","update_macaroon","change_route","set_selected_or_created","add_job_id","job_id","request_id","success","failed","created_job_request","uuid","set_job_as_fulfilled","status_code","newvalue","oldvalue","registration_credentials","login_credentials","Store","login_form","login_modal","registration_modal","dropdownobservable","succeeded_or_failed","loading","api","submit_login_remote","url","new_job_id","ajax","dataType","contentType","headers","Authorization","JSON","stringify","loginUser","small","active","image_src","image_description","modal","hide_modal_name","cancelModal","modal_state","buttonAction","startPoller","setInterval","/","/create","currentPage","goTo","page","state_value","new_route","activeLogin","registerUser","submitForm","updateStoreForm","field","formdata","actions","macaroon_received","activate_modal","deactivate_modal","submit_login","create_job","defineWatcher","unwatchOne","callWatchers","noMore","functionToCheck","getType","isInt","isModernBrowser","__defineGetter__","defineGetAndSet","propName","getter","setter","__defineSetter__","error2","defineProp","watchAll","watchMany","watchOne","watcher","level","String","prop2","unwatchAll","unwatchMany","watchFunctions","watchers","newval","oldval","wr","methodNames","defineArrayMethodWatcher","original","methodName","response","subjects","serialized","subj","loop","newSer","__webpack_amd_options__"],"mappings":"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","file":"app.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!******************!*\\\n  !*** multi main ***!\n  \\******************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(/*! ./actions/index.js */20);\n\t__webpack_require__(/*! ./store/index.js */3);\n\tmodule.exports = __webpack_require__(/*! ./main.js */21);\n\n\n/***/ },\n/* 1 */\n/*!*************************!*\\\n  !*** ../~/riot/riot.js ***!\n  \\*************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* Riot v2.4.1, @license MIT */\n\t\n\t;(function(window, undefined) {\n\t  'use strict';\n\tvar riot = { version: 'v2.4.1', settings: {} },\n\t  // be aware, internal usage\n\t  // ATTENTION: prefix the global dynamic variables with `__`\n\t\n\t  // counter to give a unique id to all the Tag instances\n\t  __uid = 0,\n\t  // tags instances cache\n\t  __virtualDom = [],\n\t  // tags implementation cache\n\t  __tagImpl = {},\n\t\n\t  /**\n\t   * Const\n\t   */\n\t  GLOBAL_MIXIN = '__global_mixin',\n\t\n\t  // riot specific prefixes\n\t  RIOT_PREFIX = 'riot-',\n\t  RIOT_TAG = RIOT_PREFIX + 'tag',\n\t  RIOT_TAG_IS = 'data-is',\n\t\n\t  // for typeof == '' comparisons\n\t  T_STRING = 'string',\n\t  T_OBJECT = 'object',\n\t  T_UNDEF  = 'undefined',\n\t  T_FUNCTION = 'function',\n\t  // special native tags that cannot be treated like the others\n\t  SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n\t  RESERVED_WORDS_BLACKLIST = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|parent|opts|trigger|o(?:n|ff|ne))$/,\n\t  // SVG tags list https://www.w3.org/TR/SVG/attindex.html#PresentationAttributes\n\t  SVG_TAGS_LIST = ['altGlyph', 'animate', 'animateColor', 'circle', 'clipPath', 'defs', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feGaussianBlur', 'feImage', 'feMerge', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence', 'filter', 'font', 'foreignObject', 'g', 'glyph', 'glyphRef', 'image', 'line', 'linearGradient', 'marker', 'mask', 'missing-glyph', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'switch', 'symbol', 'text', 'textPath', 'tref', 'tspan', 'use'],\n\t\n\t  // version# for IE 8-11, 0 for others\n\t  IE_VERSION = (window && window.document || {}).documentMode | 0,\n\t\n\t  // detect firefox to fix #1374\n\t  FIREFOX = window && !!window.InstallTrigger\n\t/* istanbul ignore next */\n\triot.observable = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {}\n\t\n\t  /**\n\t   * Private variables\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice\n\t\n\t  /**\n\t   * Private Methods\n\t   */\n\t\n\t  /**\n\t   * Helper function needed to get and loop all the events in a string\n\t   * @param   { String }   e - event string\n\t   * @param   {Function}   fn - callback\n\t   */\n\t  function onEachEvent(e, fn) {\n\t    var es = e.split(' '), l = es.length, i = 0, name, indx\n\t    for (; i < l; i++) {\n\t      name = es[i]\n\t      indx = name.indexOf('.')\n\t      if (name) fn( ~indx ? name.substring(0, indx) : name, i, ~indx ? name.slice(indx + 1) : null)\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Public Api\n\t   */\n\t\n\t  // extend the el object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given space separated list of `events` and\n\t     * execute the `callback` each time an event is triggered.\n\t     * @param  { String } events - events ids\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(events, fn) {\n\t        if (typeof fn != 'function')  return el\n\t\n\t        onEachEvent(events, function(name, pos, ns) {\n\t          (callbacks[name] = callbacks[name] || []).push(fn)\n\t          fn.typed = pos > 0\n\t          fn.ns = ns\n\t        })\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given space separated list of `events` listeners\n\t     * @param   { String } events - events ids\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(events, fn) {\n\t        if (events == '*' && !fn) callbacks = {}\n\t        else {\n\t          onEachEvent(events, function(name, pos, ns) {\n\t            if (fn || ns) {\n\t              var arr = callbacks[name]\n\t              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t                if (cb == fn || ns && cb.ns == ns) arr.splice(i--, 1)\n\t              }\n\t            } else delete callbacks[name]\n\t          })\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given space separated list of `events` and\n\t     * execute the `callback` at most once\n\t     * @param   { String } events - events ids\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(events, fn) {\n\t        function on() {\n\t          el.off(events, on)\n\t          fn.apply(el, arguments)\n\t        }\n\t        return el.on(events, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to\n\t     * the given space separated list of `events`\n\t     * @param   { String } events - events ids\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(events) {\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns\n\t\n\t        for (var i = 0; i < arglen; i++) {\n\t          args[i] = arguments[i + 1] // skip first argument\n\t        }\n\t\n\t        onEachEvent(events, function(name, pos, ns) {\n\t\n\t          fns = slice.call(callbacks[name] || [], 0)\n\t\n\t          for (var i = 0, fn; fn = fns[i]; ++i) {\n\t            if (fn.busy) continue\n\t            fn.busy = 1\n\t            if (!ns || fn.ns == ns) fn.apply(el, fn.typed ? [name].concat(args) : args)\n\t            if (fns[i] !== fn) { i-- }\n\t            fn.busy = 0\n\t          }\n\t\n\t          if (callbacks['*'] && name != '*')\n\t            el.trigger.apply(el, ['*', name].concat(args))\n\t\n\t        })\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  })\n\t\n\t  return el\n\t\n\t}\n\t/* istanbul ignore next */\n\t;(function(riot) {\n\t\n\t/**\n\t * Simple client-side router\n\t * @module riot-route\n\t */\n\t\n\t\n\tvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/,\n\t  EVENT_LISTENER = 'EventListener',\n\t  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n\t  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n\t  HAS_ATTRIBUTE = 'hasAttribute',\n\t  REPLACE = 'replace',\n\t  POPSTATE = 'popstate',\n\t  HASHCHANGE = 'hashchange',\n\t  TRIGGER = 'trigger',\n\t  MAX_EMIT_STACK_LEVEL = 3,\n\t  win = typeof window != 'undefined' && window,\n\t  doc = typeof document != 'undefined' && document,\n\t  hist = win && history,\n\t  loc = win && (hist.location || win.location), // see html5-history-api\n\t  prot = Router.prototype, // to minify more\n\t  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n\t  started = false,\n\t  central = riot.observable(),\n\t  routeFound = false,\n\t  debouncedEmit,\n\t  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\t\n\t/**\n\t * Default parser. You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_PARSER(path) {\n\t  return path.split(/[/?#]/)\n\t}\n\t\n\t/**\n\t * Default parser (second). You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @param {string} filter - filter string (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_SECOND_PARSER(path, filter) {\n\t  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n\t    args = path.match(re)\n\t\n\t  if (args) return args.slice(1)\n\t}\n\t\n\t/**\n\t * Simple/cheap debounce implementation\n\t * @param   {function} fn - callback\n\t * @param   {number} delay - delay in seconds\n\t * @returns {function} debounced function\n\t */\n\tfunction debounce(fn, delay) {\n\t  var t\n\t  return function () {\n\t    clearTimeout(t)\n\t    t = setTimeout(fn, delay)\n\t  }\n\t}\n\t\n\t/**\n\t * Set the window listeners to trigger the routes\n\t * @param {boolean} autoExec - see route.start\n\t */\n\tfunction start(autoExec) {\n\t  debouncedEmit = debounce(emit, 1)\n\t  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n\t  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n\t  doc[ADD_EVENT_LISTENER](clickEvent, click)\n\t  if (autoExec) emit(true)\n\t}\n\t\n\t/**\n\t * Router class\n\t */\n\tfunction Router() {\n\t  this.$ = []\n\t  riot.observable(this) // make it observable\n\t  central.on('stop', this.s.bind(this))\n\t  central.on('emit', this.e.bind(this))\n\t}\n\t\n\tfunction normalize(path) {\n\t  return path[REPLACE](/^\\/|\\/$/, '')\n\t}\n\t\n\tfunction isString(str) {\n\t  return typeof str == 'string'\n\t}\n\t\n\t/**\n\t * Get the part after domain name\n\t * @param {string} href - fullpath\n\t * @returns {string} path from root\n\t */\n\tfunction getPathFromRoot(href) {\n\t  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n\t}\n\t\n\t/**\n\t * Get the part after base\n\t * @param {string} href - fullpath\n\t * @returns {string} path from base\n\t */\n\tfunction getPathFromBase(href) {\n\t  return base[0] == '#'\n\t    ? (href || loc.href || '').split(base)[1] || ''\n\t    : (loc ? getPathFromRoot(href) : href || '')[REPLACE](base, '')\n\t}\n\t\n\tfunction emit(force) {\n\t  // the stack is needed for redirections\n\t  var isRoot = emitStackLevel == 0\n\t  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\t\n\t  emitStackLevel++\n\t  emitStack.push(function() {\n\t    var path = getPathFromBase()\n\t    if (force || path != current) {\n\t      central[TRIGGER]('emit', path)\n\t      current = path\n\t    }\n\t  })\n\t  if (isRoot) {\n\t    while (emitStack.length) {\n\t      emitStack[0]()\n\t      emitStack.shift()\n\t    }\n\t    emitStackLevel = 0\n\t  }\n\t}\n\t\n\tfunction click(e) {\n\t  if (\n\t    e.which != 1 // not left click\n\t    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n\t    || e.defaultPrevented // or default prevented\n\t  ) return\n\t\n\t  var el = e.target\n\t  while (el && el.nodeName != 'A') el = el.parentNode\n\t\n\t  if (\n\t    !el || el.nodeName != 'A' // not A tag\n\t    || el[HAS_ATTRIBUTE]('download') // has download attr\n\t    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n\t    || el.target && el.target != '_self' // another window or frame\n\t    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n\t  ) return\n\t\n\t  if (el.href != loc.href) {\n\t    if (\n\t      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n\t      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n\t      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n\t    ) return\n\t  }\n\t\n\t  e.preventDefault()\n\t}\n\t\n\t/**\n\t * Go to the path\n\t * @param {string} path - destination path\n\t * @param {string} title - page title\n\t * @param {boolean} shouldReplace - use replaceState or pushState\n\t * @returns {boolean} - route not found flag\n\t */\n\tfunction go(path, title, shouldReplace) {\n\t  if (hist) { // if a browser\n\t    path = base + normalize(path)\n\t    title = title || doc.title\n\t    // browsers ignores the second parameter `title`\n\t    shouldReplace\n\t      ? hist.replaceState(null, title, path)\n\t      : hist.pushState(null, title, path)\n\t    // so we need to set it manually\n\t    doc.title = title\n\t    routeFound = false\n\t    emit()\n\t    return routeFound\n\t  }\n\t\n\t  // Server-side usage: directly execute handlers for the path\n\t  return central[TRIGGER]('emit', getPathFromBase(path))\n\t}\n\t\n\t/**\n\t * Go to path or set action\n\t * a single string:                go there\n\t * two strings:                    go there with setting a title\n\t * two strings and boolean:        replace history with setting a title\n\t * a single function:              set an action on the default route\n\t * a string/RegExp and a function: set an action on the route\n\t * @param {(string|function)} first - path / action / filter\n\t * @param {(string|RegExp|function)} second - title / action\n\t * @param {boolean} third - replace flag\n\t */\n\tprot.m = function(first, second, third) {\n\t  if (isString(first) && (!second || isString(second))) go(first, second, third || false)\n\t  else if (second) this.r(first, second)\n\t  else this.r('@', first)\n\t}\n\t\n\t/**\n\t * Stop routing\n\t */\n\tprot.s = function() {\n\t  this.off('*')\n\t  this.$ = []\n\t}\n\t\n\t/**\n\t * Emit\n\t * @param {string} path - path\n\t */\n\tprot.e = function(path) {\n\t  this.$.concat('@').some(function(filter) {\n\t    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n\t    if (typeof args != 'undefined') {\n\t      this[TRIGGER].apply(null, [filter].concat(args))\n\t      return routeFound = true // exit from loop\n\t    }\n\t  }, this)\n\t}\n\t\n\t/**\n\t * Register route\n\t * @param {string} filter - filter for matching to url\n\t * @param {function} action - action to register\n\t */\n\tprot.r = function(filter, action) {\n\t  if (filter != '@') {\n\t    filter = '/' + normalize(filter)\n\t    this.$.push(filter)\n\t  }\n\t  this.on(filter, action)\n\t}\n\t\n\tvar mainRouter = new Router()\n\tvar route = mainRouter.m.bind(mainRouter)\n\t\n\t/**\n\t * Create a sub router\n\t * @returns {function} the method of a new Router object\n\t */\n\troute.create = function() {\n\t  var newSubRouter = new Router()\n\t  // assign sub-router's main method\n\t  var router = newSubRouter.m.bind(newSubRouter)\n\t  // stop only this sub-router\n\t  router.stop = newSubRouter.s.bind(newSubRouter)\n\t  return router\n\t}\n\t\n\t/**\n\t * Set the base of url\n\t * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n\t */\n\troute.base = function(arg) {\n\t  base = arg || '#'\n\t  current = getPathFromBase() // recalculate current path\n\t}\n\t\n\t/** Exec routing right now **/\n\troute.exec = function() {\n\t  emit(true)\n\t}\n\t\n\t/**\n\t * Replace the default router to yours\n\t * @param {function} fn - your parser function\n\t * @param {function} fn2 - your secondParser function\n\t */\n\troute.parser = function(fn, fn2) {\n\t  if (!fn && !fn2) {\n\t    // reset parser for testing...\n\t    parser = DEFAULT_PARSER\n\t    secondParser = DEFAULT_SECOND_PARSER\n\t  }\n\t  if (fn) parser = fn\n\t  if (fn2) secondParser = fn2\n\t}\n\t\n\t/**\n\t * Helper function to get url query as an object\n\t * @returns {object} parsed query\n\t */\n\troute.query = function() {\n\t  var q = {}\n\t  var href = loc.href || current\n\t  href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n\t  return q\n\t}\n\t\n\t/** Stop routing **/\n\troute.stop = function () {\n\t  if (started) {\n\t    if (win) {\n\t      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n\t      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n\t      doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n\t    }\n\t    central[TRIGGER]('stop')\n\t    started = false\n\t  }\n\t}\n\t\n\t/**\n\t * Start routing\n\t * @param {boolean} autoExec - automatically exec after starting if true\n\t */\n\troute.start = function (autoExec) {\n\t  if (!started) {\n\t    if (win) {\n\t      if (document.readyState == 'complete') start(autoExec)\n\t      // the timeout is needed to solve\n\t      // a weird safari bug https://github.com/riot/route/issues/33\n\t      else win[ADD_EVENT_LISTENER]('load', function() {\n\t        setTimeout(function() { start(autoExec) }, 1)\n\t      })\n\t    }\n\t    started = true\n\t  }\n\t}\n\t\n\t/** Prepare the router **/\n\troute.base()\n\troute.parser()\n\t\n\triot.route = route\n\t})(riot)\n\t/* istanbul ignore next */\n\t\n\t/**\n\t * The riot template engine\n\t * @version v2.4.0\n\t */\n\t/**\n\t * riot.util.brackets\n\t *\n\t * - `brackets    ` - Returns a string or regex based on its parameter\n\t * - `brackets.set` - Change the current riot brackets\n\t *\n\t * @module\n\t */\n\t\n\tvar brackets = (function (UNDEF) {\n\t\n\t  var\n\t    REGLOB = 'g',\n\t\n\t    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\t\n\t    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\t\n\t    S_QBLOCKS = R_STRINGS.source + '|' +\n\t      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n\t      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\t\n\t    FINDBRACES = {\n\t      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n\t      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n\t      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n\t    },\n\t\n\t    DEFAULT = '{ }'\n\t\n\t  var _pairs = [\n\t    '{', '}',\n\t    '{', '}',\n\t    /{[^}]*}/,\n\t    /\\\\([{}])/g,\n\t    /\\\\({)|{/g,\n\t    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n\t    DEFAULT,\n\t    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n\t    /(^|[^\\\\]){=[\\S\\s]*?}/\n\t  ]\n\t\n\t  var\n\t    cachedBrackets = UNDEF,\n\t    _regex,\n\t    _cache = [],\n\t    _settings\n\t\n\t  function _loopback (re) { return re }\n\t\n\t  function _rewrite (re, bp) {\n\t    if (!bp) bp = _cache\n\t    return new RegExp(\n\t      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n\t    )\n\t  }\n\t\n\t  function _create (pair) {\n\t    if (pair === DEFAULT) return _pairs\n\t\n\t    var arr = pair.split(' ')\n\t\n\t    if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) { // eslint-disable-line\n\t      throw new Error('Unsupported brackets \"' + pair + '\"')\n\t    }\n\t    arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n\t\n\t    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr)\n\t    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr)\n\t    arr[6] = _rewrite(_pairs[6], arr)\n\t    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB)\n\t    arr[8] = pair\n\t    return arr\n\t  }\n\t\n\t  function _brackets (reOrIdx) {\n\t    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n\t  }\n\t\n\t  _brackets.split = function split (str, tmpl, _bp) {\n\t    // istanbul ignore next: _bp is for the compiler\n\t    if (!_bp) _bp = _cache\n\t\n\t    var\n\t      parts = [],\n\t      match,\n\t      isexpr,\n\t      start,\n\t      pos,\n\t      re = _bp[6]\n\t\n\t    isexpr = start = re.lastIndex = 0\n\t\n\t    while ((match = re.exec(str))) {\n\t\n\t      pos = match.index\n\t\n\t      if (isexpr) {\n\t\n\t        if (match[2]) {\n\t          re.lastIndex = skipBraces(str, match[2], re.lastIndex)\n\t          continue\n\t        }\n\t        if (!match[3]) {\n\t          continue\n\t        }\n\t      }\n\t\n\t      if (!match[1]) {\n\t        unescapeStr(str.slice(start, pos))\n\t        start = re.lastIndex\n\t        re = _bp[6 + (isexpr ^= 1)]\n\t        re.lastIndex = start\n\t      }\n\t    }\n\t\n\t    if (str && start < str.length) {\n\t      unescapeStr(str.slice(start))\n\t    }\n\t\n\t    return parts\n\t\n\t    function unescapeStr (s) {\n\t      if (tmpl || isexpr) {\n\t        parts.push(s && s.replace(_bp[5], '$1'))\n\t      } else {\n\t        parts.push(s)\n\t      }\n\t    }\n\t\n\t    function skipBraces (s, ch, ix) {\n\t      var\n\t        match,\n\t        recch = FINDBRACES[ch]\n\t\n\t      recch.lastIndex = ix\n\t      ix = 1\n\t      while ((match = recch.exec(s))) {\n\t        if (match[1] &&\n\t          !(match[1] === ch ? ++ix : --ix)) break\n\t      }\n\t      return ix ? s.length : recch.lastIndex\n\t    }\n\t  }\n\t\n\t  _brackets.hasExpr = function hasExpr (str) {\n\t    return _cache[4].test(str)\n\t  }\n\t\n\t  _brackets.loopKeys = function loopKeys (expr) {\n\t    var m = expr.match(_cache[9])\n\t\n\t    return m\n\t      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n\t      : { val: expr.trim() }\n\t  }\n\t\n\t  _brackets.array = function array (pair) {\n\t    return pair ? _create(pair) : _cache\n\t  }\n\t\n\t  function _reset (pair) {\n\t    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n\t      _cache = _create(pair)\n\t      _regex = pair === DEFAULT ? _loopback : _rewrite\n\t      _cache[9] = _regex(_pairs[9])\n\t    }\n\t    cachedBrackets = pair\n\t  }\n\t\n\t  function _setSettings (o) {\n\t    var b\n\t\n\t    o = o || {}\n\t    b = o.brackets\n\t    Object.defineProperty(o, 'brackets', {\n\t      set: _reset,\n\t      get: function () { return cachedBrackets },\n\t      enumerable: true\n\t    })\n\t    _settings = o\n\t    _reset(b)\n\t  }\n\t\n\t  Object.defineProperty(_brackets, 'settings', {\n\t    set: _setSettings,\n\t    get: function () { return _settings }\n\t  })\n\t\n\t  /* istanbul ignore next: in the browser riot is always in the scope */\n\t  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n\t  _brackets.set = _reset\n\t\n\t  _brackets.R_STRINGS = R_STRINGS\n\t  _brackets.R_MLCOMMS = R_MLCOMMS\n\t  _brackets.S_QBLOCKS = S_QBLOCKS\n\t\n\t  return _brackets\n\t\n\t})()\n\t\n\t/**\n\t * @module tmpl\n\t *\n\t * tmpl          - Root function, returns the template value, render with data\n\t * tmpl.hasExpr  - Test the existence of a expression inside a string\n\t * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n\t */\n\t\n\tvar tmpl = (function () {\n\t\n\t  var _cache = {}\n\t\n\t  function _tmpl (str, data) {\n\t    if (!str) return str\n\t\n\t    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n\t  }\n\t\n\t  _tmpl.haveRaw = brackets.hasRaw\n\t\n\t  _tmpl.hasExpr = brackets.hasExpr\n\t\n\t  _tmpl.loopKeys = brackets.loopKeys\n\t\n\t  _tmpl.errorHandler = null\n\t\n\t  function _logErr (err, ctx) {\n\t\n\t    if (_tmpl.errorHandler) {\n\t\n\t      err.riotData = {\n\t        tagName: ctx && ctx.root && ctx.root.tagName,\n\t        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n\t      }\n\t      _tmpl.errorHandler(err)\n\t    }\n\t  }\n\t\n\t  function _create (str) {\n\t    var expr = _getTmpl(str)\n\t\n\t    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\t\n\t/* eslint-disable */\n\t\n\t    return new Function('E', expr + ';')\n\t/* eslint-enable */\n\t  }\n\t\n\t  var\n\t    CH_IDEXPR = '\\u2057',\n\t    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n\t    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n\t    RE_DQUOTE = /\\u2057/g,\n\t    RE_QBMARK = /\\u2057(\\d+)~/g\n\t\n\t  function _getTmpl (str) {\n\t    var\n\t      qstr = [],\n\t      expr,\n\t      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1)\n\t\n\t    if (parts.length > 2 || parts[0]) {\n\t      var i, j, list = []\n\t\n\t      for (i = j = 0; i < parts.length; ++i) {\n\t\n\t        expr = parts[i]\n\t\n\t        if (expr && (expr = i & 1\n\t\n\t            ? _parseExpr(expr, 1, qstr)\n\t\n\t            : '\"' + expr\n\t                .replace(/\\\\/g, '\\\\\\\\')\n\t                .replace(/\\r\\n?|\\n/g, '\\\\n')\n\t                .replace(/\"/g, '\\\\\"') +\n\t              '\"'\n\t\n\t          )) list[j++] = expr\n\t\n\t      }\n\t\n\t      expr = j < 2 ? list[0]\n\t           : '[' + list.join(',') + '].join(\"\")'\n\t\n\t    } else {\n\t\n\t      expr = _parseExpr(parts[1], 0, qstr)\n\t    }\n\t\n\t    if (qstr[0]) {\n\t      expr = expr.replace(RE_QBMARK, function (_, pos) {\n\t        return qstr[pos]\n\t          .replace(/\\r/g, '\\\\r')\n\t          .replace(/\\n/g, '\\\\n')\n\t      })\n\t    }\n\t    return expr\n\t  }\n\t\n\t  var\n\t    RE_BREND = {\n\t      '(': /[()]/g,\n\t      '[': /[[\\]]/g,\n\t      '{': /[{}]/g\n\t    }\n\t\n\t  function _parseExpr (expr, asText, qstr) {\n\t\n\t    expr = expr\n\t          .replace(RE_QBLOCK, function (s, div) {\n\t            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n\t          })\n\t          .replace(/\\s+/g, ' ').trim()\n\t          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\t\n\t    if (expr) {\n\t      var\n\t        list = [],\n\t        cnt = 0,\n\t        match\n\t\n\t      while (expr &&\n\t            (match = expr.match(RE_CSNAME)) &&\n\t            !match.index\n\t        ) {\n\t        var\n\t          key,\n\t          jsb,\n\t          re = /,|([[{(])|$/g\n\t\n\t        expr = RegExp.rightContext\n\t        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\t\n\t        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\t\n\t        jsb  = expr.slice(0, match.index)\n\t        expr = RegExp.rightContext\n\t\n\t        list[cnt++] = _wrapExpr(jsb, 1, key)\n\t      }\n\t\n\t      expr = !cnt ? _wrapExpr(expr, asText)\n\t           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n\t    }\n\t    return expr\n\t\n\t    function skipBraces (ch, re) {\n\t      var\n\t        mm,\n\t        lv = 1,\n\t        ir = RE_BREND[ch]\n\t\n\t      ir.lastIndex = re.lastIndex\n\t      while (mm = ir.exec(expr)) {\n\t        if (mm[0] === ch) ++lv\n\t        else if (!--lv) break\n\t      }\n\t      re.lastIndex = lv ? expr.length : ir.lastIndex\n\t    }\n\t  }\n\t\n\t  // istanbul ignore next: not both\n\t  var // eslint-disable-next-line max-len\n\t    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n\t    JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n\t    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/\n\t\n\t  function _wrapExpr (expr, asText, key) {\n\t    var tb\n\t\n\t    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n\t      if (mvar) {\n\t        pos = tb ? 0 : pos + match.length\n\t\n\t        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n\t          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n\t          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n\t        } else if (pos) {\n\t          tb = !JS_NOPROPS.test(s.slice(pos))\n\t        }\n\t      }\n\t      return match\n\t    })\n\t\n\t    if (tb) {\n\t      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n\t    }\n\t\n\t    if (key) {\n\t\n\t      expr = (tb\n\t          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n\t        ) + '?\"' + key + '\":\"\"'\n\t\n\t    } else if (asText) {\n\t\n\t      expr = 'function(v){' + (tb\n\t          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n\t        ) + ';return v||v===0?v:\"\"}.call(this)'\n\t    }\n\t\n\t    return expr\n\t  }\n\t\n\t  // istanbul ignore next: compatibility fix for beta versions\n\t  _tmpl.parse = function (s) { return s }\n\t\n\t  _tmpl.version = brackets.version = 'v2.4.0'\n\t\n\t  return _tmpl\n\t\n\t})()\n\t\n\t/*\n\t  lib/browser/tag/mkdom.js\n\t\n\t  Includes hacks needed for the Internet Explorer version 9 and below\n\t  See: http://kangax.github.io/compat-table/es5/#ie8\n\t       http://codeplanet.io/dropping-ie8/\n\t*/\n\tvar mkdom = (function _mkdom() {\n\t  var\n\t    reHasYield  = /<yield\\b/i,\n\t    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n\t    reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n\t    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig\n\t  var\n\t    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n\t    tblTags = IE_VERSION && IE_VERSION < 10\n\t      ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/\n\t\n\t  /**\n\t   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n\t   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n\t   *\n\t   * @param   {string} templ  - The template coming from the custom tag definition\n\t   * @param   {string} [html] - HTML content that comes from the DOM element where you\n\t   *           will mount the tag, mostly the original tag in the page\n\t   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.\n\t   */\n\t  function _mkdom(templ, html) {\n\t    var\n\t      match   = templ && templ.match(/^\\s*<([-\\w]+)/),\n\t      tagName = match && match[1].toLowerCase(),\n\t      el = mkEl('div', isSVGTag(tagName))\n\t\n\t    // replace all the yield tags with the tag inner html\n\t    templ = replaceYield(templ, html)\n\t\n\t    /* istanbul ignore next */\n\t    if (tblTags.test(tagName))\n\t      el = specialTags(el, templ, tagName)\n\t    else\n\t      setInnerHTML(el, templ)\n\t\n\t    el.stub = true\n\t\n\t    return el\n\t  }\n\t\n\t  /*\n\t    Creates the root element for table or select child elements:\n\t    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n\t  */\n\t  function specialTags(el, templ, tagName) {\n\t    var\n\t      select = tagName[0] === 'o',\n\t      parent = select ? 'select>' : 'table>'\n\t\n\t    // trim() is important here, this ensures we don't have artifacts,\n\t    // so we can check if we have only one element inside the parent\n\t    el.innerHTML = '<' + parent + templ.trim() + '</' + parent\n\t    parent = el.firstChild\n\t\n\t    // returns the immediate parent if tr/th/td/col is the only element, if not\n\t    // returns the whole tree, as this can include additional elements\n\t    if (select) {\n\t      parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior\n\t    } else {\n\t      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n\t      var tname = rootEls[tagName]\n\t      if (tname && parent.childElementCount === 1) parent = $(tname, parent)\n\t    }\n\t    return parent\n\t  }\n\t\n\t  /*\n\t    Replace the yield tag from any tag template with the innerHTML of the\n\t    original tag in the page\n\t  */\n\t  function replaceYield(templ, html) {\n\t    // do nothing if no yield\n\t    if (!reHasYield.test(templ)) return templ\n\t\n\t    // be careful with #1343 - string on the source having `$1`\n\t    var src = {}\n\t\n\t    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n\t      src[ref] = src[ref] || text   // preserve first definition\n\t      return ''\n\t    }).trim()\n\t\n\t    return templ\n\t      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n\t        return src[ref] || def || ''\n\t      })\n\t      .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n\t        return html || def || ''\n\t      })\n\t  }\n\t\n\t  return _mkdom\n\t\n\t})()\n\t\n\t/**\n\t * Convert the item looped into an object used to extend the child tag properties\n\t * @param   { Object } expr - object containing the keys used to extend the children tags\n\t * @param   { * } key - value to assign to the new object returned\n\t * @param   { * } val - value containing the position of the item in the array\n\t * @returns { Object } - new object containing the values of the original item\n\t *\n\t * The variables 'key' and 'val' are arbitrary.\n\t * They depend on the collection type looped (Array, Object)\n\t * and on the expression used on the each tag\n\t *\n\t */\n\tfunction mkitem(expr, key, val) {\n\t  var item = {}\n\t  item[expr.key] = key\n\t  if (expr.pos) item[expr.pos] = val\n\t  return item\n\t}\n\t\n\t/**\n\t * Unmount the redundant tags\n\t * @param   { Array } items - array containing the current items to loop\n\t * @param   { Array } tags - array containing all the children tags\n\t */\n\tfunction unmountRedundant(items, tags) {\n\t\n\t  var i = tags.length,\n\t    j = items.length,\n\t    t\n\t\n\t  while (i > j) {\n\t    t = tags[--i]\n\t    tags.splice(i, 1)\n\t    t.unmount()\n\t  }\n\t}\n\t\n\t/**\n\t * Move the nested custom tags in non custom loop tags\n\t * @param   { Object } child - non custom loop tag\n\t * @param   { Number } i - current position of the loop tag\n\t */\n\tfunction moveNestedTags(child, i) {\n\t  Object.keys(child.tags).forEach(function(tagName) {\n\t    var tag = child.tags[tagName]\n\t    if (isArray(tag))\n\t      each(tag, function (t) {\n\t        moveChildTag(t, tagName, i)\n\t      })\n\t    else\n\t      moveChildTag(tag, tagName, i)\n\t  })\n\t}\n\t\n\t/**\n\t * Adds the elements for a virtual tag\n\t * @param { Tag } tag - the tag whose root's children will be inserted or appended\n\t * @param { Node } src - the node that will do the inserting or appending\n\t * @param { Tag } target - only if inserting, insert before this tag's first child\n\t */\n\tfunction addVirtual(tag, src, target) {\n\t  var el = tag._root, sib\n\t  tag._virts = []\n\t  while (el) {\n\t    sib = el.nextSibling\n\t    if (target)\n\t      src.insertBefore(el, target._root)\n\t    else\n\t      src.appendChild(el)\n\t\n\t    tag._virts.push(el) // hold for unmounting\n\t    el = sib\n\t  }\n\t}\n\t\n\t/**\n\t * Move virtual tag and all child nodes\n\t * @param { Tag } tag - first child reference used to start move\n\t * @param { Node } src  - the node that will do the inserting\n\t * @param { Tag } target - insert before this tag's first child\n\t * @param { Number } len - how many child nodes to move\n\t */\n\tfunction moveVirtual(tag, src, target, len) {\n\t  var el = tag._root, sib, i = 0\n\t  for (; i < len; i++) {\n\t    sib = el.nextSibling\n\t    src.insertBefore(el, target._root)\n\t    el = sib\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Manage tags having the 'each'\n\t * @param   { Object } dom - DOM node we need to loop\n\t * @param   { Tag } parent - parent tag instance where the dom node is contained\n\t * @param   { String } expr - string contained in the 'each' attribute\n\t */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  // remove the each property from the original tag\n\t  remAttr(dom, 'each')\n\t\n\t  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n\t    tagName = getTagName(dom),\n\t    impl = __tagImpl[tagName] || { tmpl: getOuterHTML(dom) },\n\t    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n\t    root = dom.parentNode,\n\t    ref = document.createTextNode(''),\n\t    child = getTag(dom),\n\t    isOption = tagName.toLowerCase() === 'option', // the option tags must be treated differently\n\t    tags = [],\n\t    oldItems = [],\n\t    hasKeys,\n\t    isVirtual = dom.tagName == 'VIRTUAL'\n\t\n\t  // parse the each expression\n\t  expr = tmpl.loopKeys(expr)\n\t\n\t  // insert a marked where the loop tags will be injected\n\t  root.insertBefore(ref, dom)\n\t\n\t  // clean template code\n\t  parent.one('before-mount', function () {\n\t\n\t    // remove the original DOM node\n\t    dom.parentNode.removeChild(dom)\n\t    if (root.stub) root = parent.root\n\t\n\t  }).on('update', function () {\n\t    // get the new items collection\n\t    var items = tmpl(expr.val, parent),\n\t      // create a fragment to hold the new DOM nodes to inject in the parent tag\n\t      frag = document.createDocumentFragment()\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (!isArray(items)) {\n\t      hasKeys = items || false\n\t      items = hasKeys ?\n\t        Object.keys(items).map(function (key) {\n\t          return mkitem(expr, key, items[key])\n\t        }) : []\n\t    }\n\t\n\t    // loop all the new items\n\t    var i = 0,\n\t      itemsLength = items.length\n\t\n\t    for (; i < itemsLength; i++) {\n\t      // reorder only if the items are objects\n\t      var\n\t        item = items[i],\n\t        _mustReorder = mustReorder && typeof item == T_OBJECT && !hasKeys,\n\t        oldPos = oldItems.indexOf(item),\n\t        pos = ~oldPos && _mustReorder ? oldPos : i,\n\t        // does a tag exist in this position?\n\t        tag = tags[pos]\n\t\n\t      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\t\n\t      // new tag\n\t      if (\n\t        !_mustReorder && !tag // with no-reorder we just update the old tags\n\t        ||\n\t        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n\t      ) {\n\t\n\t        tag = new Tag(impl, {\n\t          parent: parent,\n\t          isLoop: true,\n\t          hasImpl: !!__tagImpl[tagName],\n\t          root: useRoot ? root : dom.cloneNode(),\n\t          item: item\n\t        }, dom.innerHTML)\n\t\n\t        tag.mount()\n\t\n\t        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n\t        // this tag must be appended\n\t        if (i == tags.length || !tags[i]) { // fix 1581\n\t          if (isVirtual)\n\t            addVirtual(tag, frag)\n\t          else frag.appendChild(tag.root)\n\t        }\n\t        // this tag must be insert\n\t        else {\n\t          if (isVirtual)\n\t            addVirtual(tag, root, tags[i])\n\t          else root.insertBefore(tag.root, tags[i].root) // #1374 some browsers reset selected here\n\t          oldItems.splice(i, 0, item)\n\t        }\n\t\n\t        tags.splice(i, 0, tag)\n\t        pos = i // handled here so no move\n\t      } else tag.update(item, true)\n\t\n\t      // reorder the tag if it's not located in its previous position\n\t      if (\n\t        pos !== i && _mustReorder &&\n\t        tags[i] // fix 1581 unable to reproduce it in a test!\n\t      ) {\n\t        // update the DOM\n\t        if (isVirtual)\n\t          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n\t        else root.insertBefore(tag.root, tags[i].root)\n\t        // update the position attribute if it exists\n\t        if (expr.pos)\n\t          tag[expr.pos] = i\n\t        // move the old tag instance\n\t        tags.splice(i, 0, tags.splice(pos, 1)[0])\n\t        // move the old item\n\t        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n\t        // if the loop tags are not custom\n\t        // we need to move all their custom tags into the right position\n\t        if (!child && tag.tags) moveNestedTags(tag, i)\n\t      }\n\t\n\t      // cache the original item to use it in the events bound to this node\n\t      // and its children\n\t      tag._item = item\n\t      // cache the real parent tag internally\n\t      defineProperty(tag, '_parent', parent)\n\t    }\n\t\n\t    // remove the redundant tags\n\t    unmountRedundant(items, tags)\n\t\n\t    // insert the new nodes\n\t    if (isOption) {\n\t      root.appendChild(frag)\n\t\n\t      // #1374 FireFox bug in <option selected={expression}>\n\t      if (FIREFOX && !root.multiple) {\n\t        for (var n = 0; n < root.length; n++) {\n\t          if (root[n].__riot1374) {\n\t            root.selectedIndex = n  // clear other options\n\t            delete root[n].__riot1374\n\t            break\n\t          }\n\t        }\n\t      }\n\t    }\n\t    else root.insertBefore(frag, ref)\n\t\n\t    // set the 'tags' property of the parent tag\n\t    // if child is 'undefined' it means that we don't need to set this property\n\t    // for example:\n\t    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n\t    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n\t    if (child) parent.tags[tagName] = tags\n\t\n\t    // clone the items array\n\t    oldItems = items.slice()\n\t\n\t  })\n\t\n\t}\n\t/**\n\t * Object that will be used to inject and manage the css of every tag instance\n\t */\n\tvar styleManager = (function(_riot) {\n\t\n\t  if (!window) return { // skip injection on the server\n\t    add: function () {},\n\t    inject: function () {}\n\t  }\n\t\n\t  var styleNode = (function () {\n\t    // create a new style element with the correct type\n\t    var newNode = mkEl('style')\n\t    setAttr(newNode, 'type', 'text/css')\n\t\n\t    // replace any user node or insert the new one into the head\n\t    var userNode = $('style[type=riot]')\n\t    if (userNode) {\n\t      if (userNode.id) newNode.id = userNode.id\n\t      userNode.parentNode.replaceChild(newNode, userNode)\n\t    }\n\t    else document.getElementsByTagName('head')[0].appendChild(newNode)\n\t\n\t    return newNode\n\t  })()\n\t\n\t  // Create cache and shortcut to the correct property\n\t  var cssTextProp = styleNode.styleSheet,\n\t    stylesToInject = ''\n\t\n\t  // Expose the style node in a non-modificable property\n\t  Object.defineProperty(_riot, 'styleNode', {\n\t    value: styleNode,\n\t    writable: true\n\t  })\n\t\n\t  /**\n\t   * Public api\n\t   */\n\t  return {\n\t    /**\n\t     * Save a tag style to be later injected into DOM\n\t     * @param   { String } css [description]\n\t     */\n\t    add: function(css) {\n\t      stylesToInject += css\n\t    },\n\t    /**\n\t     * Inject all previously saved tag styles into DOM\n\t     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n\t     */\n\t    inject: function() {\n\t      if (stylesToInject) {\n\t        if (cssTextProp) cssTextProp.cssText += stylesToInject\n\t        else styleNode.innerHTML += stylesToInject\n\t        stylesToInject = ''\n\t      }\n\t    }\n\t  }\n\t\n\t})(riot)\n\t\n\t\n\tfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\t\n\t  walk(root, function(dom) {\n\t    if (dom.nodeType == 1) {\n\t      dom.isLoop = dom.isLoop ||\n\t                  (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each'))\n\t                    ? 1 : 0\n\t\n\t      // custom child tag\n\t      if (childTags) {\n\t        var child = getTag(dom)\n\t\n\t        if (child && !dom.isLoop)\n\t          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n\t      }\n\t\n\t      if (!dom.isLoop || forceParsingNamed)\n\t        setNamed(dom, tag, [])\n\t    }\n\t\n\t  })\n\t\n\t}\n\t\n\tfunction parseExpressions(root, tag, expressions) {\n\t\n\t  function addExpr(dom, val, extra) {\n\t    if (tmpl.hasExpr(val)) {\n\t      expressions.push(extend({ dom: dom, expr: val }, extra))\n\t    }\n\t  }\n\t\n\t  walk(root, function(dom) {\n\t    var type = dom.nodeType,\n\t      attr\n\t\n\t    // text node\n\t    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n\t    if (type != 1) return\n\t\n\t    /* element */\n\t\n\t    // loop\n\t    attr = getAttr(dom, 'each')\n\t\n\t    if (attr) { _each(dom, tag, attr); return false }\n\t\n\t    // attribute expressions\n\t    each(dom.attributes, function(attr) {\n\t      var name = attr.name,\n\t        bool = name.split('__')[1]\n\t\n\t      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n\t      if (bool) { remAttr(dom, name); return false }\n\t\n\t    })\n\t\n\t    // skip custom tags\n\t    if (getTag(dom)) return false\n\t\n\t  })\n\t\n\t}\n\tfunction Tag(impl, conf, innerHTML) {\n\t\n\t  var self = riot.observable(this),\n\t    opts = inherit(conf.opts) || {},\n\t    parent = conf.parent,\n\t    isLoop = conf.isLoop,\n\t    hasImpl = conf.hasImpl,\n\t    item = cleanUpData(conf.item),\n\t    expressions = [],\n\t    childTags = [],\n\t    root = conf.root,\n\t    tagName = root.tagName.toLowerCase(),\n\t    attr = {},\n\t    propsInSyncWithParent = [],\n\t    dom\n\t\n\t  // only call unmount if we have a valid __tagImpl (has name property)\n\t  if (impl.name && root._tag) root._tag.unmount(true)\n\t\n\t  // not yet mounted\n\t  this.isMounted = false\n\t  root.isLoop = isLoop\n\t\n\t  // keep a reference to the tag just created\n\t  // so we will be able to mount this tag multiple times\n\t  root._tag = this\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\t\n\t  extend(this, { parent: parent, root: root, opts: opts}, item)\n\t  // protect the \"tags\" property from being overridden\n\t  defineProperty(this, 'tags', {})\n\t\n\t  // grab attributes\n\t  each(root.attributes, function(el) {\n\t    var val = el.value\n\t    // remember attributes with expressions only\n\t    if (tmpl.hasExpr(val)) attr[el.name] = val\n\t  })\n\t\n\t  dom = mkdom(impl.tmpl, innerHTML)\n\t\n\t  // options\n\t  function updateOpts() {\n\t    var ctx = hasImpl && isLoop ? self : parent || self\n\t\n\t    // update opts from current DOM attributes\n\t    each(root.attributes, function(el) {\n\t      var val = el.value\n\t      opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val\n\t    })\n\t    // recover those with expressions\n\t    each(Object.keys(attr), function(name) {\n\t      opts[toCamel(name)] = tmpl(attr[name], ctx)\n\t    })\n\t  }\n\t\n\t  function normalizeData(data) {\n\t    for (var key in item) {\n\t      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n\t        self[key] = data[key]\n\t    }\n\t  }\n\t\n\t  function inheritFromParent () {\n\t    if (!self.parent || !isLoop) return\n\t    each(Object.keys(self.parent), function(k) {\n\t      // some properties must be always in sync with the parent tag\n\t      var mustSync = !RESERVED_WORDS_BLACKLIST.test(k) && contains(propsInSyncWithParent, k)\n\t      if (typeof self[k] === T_UNDEF || mustSync) {\n\t        // track the property to keep in sync\n\t        // so we can keep it updated\n\t        if (!mustSync) propsInSyncWithParent.push(k)\n\t        self[k] = self.parent[k]\n\t      }\n\t    })\n\t  }\n\t\n\t  /**\n\t   * Update the tag expressions and options\n\t   * @param   { * }  data - data we want to use to extend the tag properties\n\t   * @param   { Boolean } isInherited - is this update coming from a parent tag?\n\t   * @returns { self }\n\t   */\n\t  defineProperty(this, 'update', function(data, isInherited) {\n\t\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data)\n\t    // inherit properties from the parent\n\t    inheritFromParent()\n\t    // normalize the tag properties in case an item object was initially passed\n\t    if (data && isObject(item)) {\n\t      normalizeData(data)\n\t      item = data\n\t    }\n\t    extend(self, data)\n\t    updateOpts()\n\t    self.trigger('update', data)\n\t    update(expressions, self)\n\t\n\t    // the updated event will be triggered\n\t    // once the DOM will be ready and all the re-flows are completed\n\t    // this is useful if you want to get the \"real\" root properties\n\t    // 4 ex: root.offsetWidth ...\n\t    if (isInherited && self.parent)\n\t      // closes #1599\n\t      self.parent.one('updated', function() { self.trigger('updated') })\n\t    else rAF(function() { self.trigger('updated') })\n\t\n\t    return this\n\t  })\n\t\n\t  defineProperty(this, 'mixin', function() {\n\t    each(arguments, function(mix) {\n\t      var instance\n\t\n\t      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\t\n\t      // check if the mixin is a function\n\t      if (isFunction(mix)) {\n\t        // create the new mixin instance\n\t        instance = new mix()\n\t        // save the prototype to loop it afterwards\n\t        mix = mix.prototype\n\t      } else instance = mix\n\t\n\t      // loop the keys in the function prototype or the all object keys\n\t      each(Object.getOwnPropertyNames(mix), function(key) {\n\t        // bind methods to self\n\t        if (key != 'init')\n\t          self[key] = isFunction(instance[key]) ?\n\t                        instance[key].bind(self) :\n\t                        instance[key]\n\t      })\n\t\n\t      // init method will be called automatically\n\t      if (instance.init) instance.init.bind(self)()\n\t    })\n\t    return this\n\t  })\n\t\n\t  defineProperty(this, 'mount', function() {\n\t\n\t    updateOpts()\n\t\n\t    // add global mixins\n\t    var globalMixin = riot.mixin(GLOBAL_MIXIN)\n\t    if (globalMixin)\n\t      for (var i in globalMixin)\n\t        if (globalMixin.hasOwnProperty(i))\n\t          self.mixin(globalMixin[i])\n\t\n\t    // initialiation\n\t    if (impl.fn) impl.fn.call(self, opts)\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions(dom, self, expressions)\n\t\n\t    // mount the child tags\n\t    toggle(true)\n\t\n\t    // update the root adding custom attributes coming from the compiler\n\t    // it fixes also #1087\n\t    if (impl.attrs)\n\t      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n\t    if (impl.attrs || hasImpl)\n\t      parseExpressions(self.root, self, expressions)\n\t\n\t    if (!self.parent || isLoop) self.update(item)\n\t\n\t    // internal use only, fixes #403\n\t    self.trigger('before-mount')\n\t\n\t    if (isLoop && !hasImpl) {\n\t      // update the root attribute for the looped elements\n\t      root = dom.firstChild\n\t    } else {\n\t      while (dom.firstChild) root.appendChild(dom.firstChild)\n\t      if (root.stub) root = parent.root\n\t    }\n\t\n\t    defineProperty(self, 'root', root)\n\t\n\t    // parse the named dom nodes in the looped child\n\t    // adding them to the parent as well\n\t    if (isLoop)\n\t      parseNamedElements(self.root, self.parent, null, true)\n\t\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!self.parent || self.parent.isMounted) {\n\t      self.isMounted = true\n\t      self.trigger('mount')\n\t    }\n\t    // otherwise we need to wait that the parent event gets triggered\n\t    else self.parent.one('mount', function() {\n\t      // avoid to trigger the `mount` event for the tags\n\t      // not visible included in an if statement\n\t      if (!isInStub(self.root)) {\n\t        self.parent.isMounted = self.isMounted = true\n\t        self.trigger('mount')\n\t      }\n\t    })\n\t  })\n\t\n\t\n\t  defineProperty(this, 'unmount', function(keepRootTag) {\n\t    var el = root,\n\t      p = el.parentNode,\n\t      ptag,\n\t      tagIndex = __virtualDom.indexOf(self)\n\t\n\t    self.trigger('before-unmount')\n\t\n\t    // remove this tag instance from the global virtualDom variable\n\t    if (~tagIndex)\n\t      __virtualDom.splice(tagIndex, 1)\n\t\n\t    if (p) {\n\t\n\t      if (parent) {\n\t        ptag = getImmediateCustomParentTag(parent)\n\t        // remove this tag from the parent tags object\n\t        // if there are multiple nested tags with same name..\n\t        // remove this element form the array\n\t        if (isArray(ptag.tags[tagName]))\n\t          each(ptag.tags[tagName], function(tag, i) {\n\t            if (tag._riot_id == self._riot_id)\n\t              ptag.tags[tagName].splice(i, 1)\n\t          })\n\t        else\n\t          // otherwise just delete the tag instance\n\t          ptag.tags[tagName] = undefined\n\t      }\n\t\n\t      else\n\t        while (el.firstChild) el.removeChild(el.firstChild)\n\t\n\t      if (!keepRootTag)\n\t        p.removeChild(el)\n\t      else {\n\t        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n\t        remAttr(p, RIOT_TAG_IS)\n\t        remAttr(p, RIOT_TAG) // this will be removed in riot 3.0.0\n\t      }\n\t\n\t    }\n\t\n\t    if (this._virts) {\n\t      each(this._virts, function(v) {\n\t        if (v.parentNode) v.parentNode.removeChild(v)\n\t      })\n\t    }\n\t\n\t    self.trigger('unmount')\n\t    toggle()\n\t    self.off('*')\n\t    self.isMounted = false\n\t    delete root._tag\n\t\n\t  })\n\t\n\t  // proxy function to bind updates\n\t  // dispatched from a parent tag\n\t  function onChildUpdate(data) { self.update(data, true) }\n\t\n\t  function toggle(isMount) {\n\t\n\t    // mount/unmount children\n\t    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\t\n\t    // listen/unlisten parent (events flow one way from parent to children)\n\t    if (!parent) return\n\t    var evt = isMount ? 'on' : 'off'\n\t\n\t    // the loop tags will be always in sync with the parent automatically\n\t    if (isLoop)\n\t      parent[evt]('unmount', self.unmount)\n\t    else {\n\t      parent[evt]('update', onChildUpdate)[evt]('unmount', self.unmount)\n\t    }\n\t  }\n\t\n\t\n\t  // named elements available for fn\n\t  parseNamedElements(dom, this, childTags)\n\t\n\t}\n\t/**\n\t * Attach an event to a DOM node\n\t * @param { String } name - event name\n\t * @param { Function } handler - event callback\n\t * @param { Object } dom - dom node\n\t * @param { Tag } tag - tag instance\n\t */\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t\n\t  dom[name] = function(e) {\n\t\n\t    var ptag = tag._parent,\n\t      item = tag._item,\n\t      el\n\t\n\t    if (!item)\n\t      while (ptag && !item) {\n\t        item = ptag._item\n\t        ptag = ptag._parent\n\t      }\n\t\n\t    // cross browser event fix\n\t    e = e || window.event\n\t\n\t    // override the event properties\n\t    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n\t    if (isWritable(e, 'target')) e.target = e.srcElement\n\t    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\t\n\t    e.item = item\n\t\n\t    // prevent default behaviour (by default)\n\t    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n\t      if (e.preventDefault) e.preventDefault()\n\t      e.returnValue = false\n\t    }\n\t\n\t    if (!e.preventUpdate) {\n\t      el = item ? getImmediateCustomParentTag(ptag) : tag\n\t      el.update()\n\t    }\n\t\n\t  }\n\t\n\t}\n\t\n\t\n\t/**\n\t * Insert a DOM node replacing another one (used by if- attribute)\n\t * @param   { Object } root - parent node\n\t * @param   { Object } node - node replaced\n\t * @param   { Object } before - node added\n\t */\n\tfunction insertTo(root, node, before) {\n\t  if (!root) return\n\t  root.insertBefore(before, node)\n\t  root.removeChild(node)\n\t}\n\t\n\t/**\n\t * Update the expressions in a Tag instance\n\t * @param   { Array } expressions - expression that must be re evaluated\n\t * @param   { Tag } tag - tag instance\n\t */\n\tfunction update(expressions, tag) {\n\t\n\t  each(expressions, function(expr, i) {\n\t\n\t    var dom = expr.dom,\n\t      attrName = expr.attr,\n\t      value = tmpl(expr.expr, tag),\n\t      parent = expr.dom.parentNode\n\t\n\t    if (expr.bool) {\n\t      value = !!value\n\t    } else if (value == null) {\n\t      value = ''\n\t    }\n\t\n\t    // #1638: regression of #1612, update the dom only if the value of the\n\t    // expression was changed\n\t    if (expr.value === value) {\n\t      return\n\t    }\n\t    expr.value = value\n\t\n\t    // textarea and text nodes has no attribute name\n\t    if (!attrName) {\n\t      // about #815 w/o replace: the browser converts the value to a string,\n\t      // the comparison by \"==\" does too, but not in the server\n\t      value += ''\n\t      // test for parent avoids error with invalid assignment to nodeValue\n\t      if (parent) {\n\t        if (parent.tagName === 'TEXTAREA') {\n\t          parent.value = value                    // #1113\n\t          if (!IE_VERSION) dom.nodeValue = value  // #1625 IE throws here, nodeValue\n\t        }                                         // will be available on 'updated'\n\t        else dom.nodeValue = value\n\t      }\n\t      return\n\t    }\n\t\n\t    // ~~#1612: look for changes in dom.value when updating the value~~\n\t    if (attrName === 'value') {\n\t      dom.value = value\n\t      return\n\t    }\n\t\n\t    // remove original attribute\n\t    remAttr(dom, attrName)\n\t\n\t    // event handler\n\t    if (isFunction(value)) {\n\t      setEventHandler(attrName, value, dom, tag)\n\t\n\t    // if- conditional\n\t    } else if (attrName == 'if') {\n\t      var stub = expr.stub,\n\t        add = function() { insertTo(stub.parentNode, stub, dom) },\n\t        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\t\n\t      // add to DOM\n\t      if (value) {\n\t        if (stub) {\n\t          add()\n\t          dom.inStub = false\n\t          // avoid to trigger the mount event if the tags is not visible yet\n\t          // maybe we can optimize this avoiding to mount the tag at all\n\t          if (!isInStub(dom)) {\n\t            walk(dom, function(el) {\n\t              if (el._tag && !el._tag.isMounted)\n\t                el._tag.isMounted = !!el._tag.trigger('mount')\n\t            })\n\t          }\n\t        }\n\t      // remove from DOM\n\t      } else {\n\t        stub = expr.stub = stub || document.createTextNode('')\n\t        // if the parentNode is defined we can easily replace the tag\n\t        if (dom.parentNode)\n\t          remove()\n\t        // otherwise we need to wait the updated event\n\t        else (tag.parent || tag).one('updated', remove)\n\t\n\t        dom.inStub = true\n\t      }\n\t    // show / hide\n\t    } else if (attrName === 'show') {\n\t      dom.style.display = value ? '' : 'none'\n\t\n\t    } else if (attrName === 'hide') {\n\t      dom.style.display = value ? 'none' : ''\n\t\n\t    } else if (expr.bool) {\n\t      dom[attrName] = value\n\t      if (value) setAttr(dom, attrName, attrName)\n\t      if (FIREFOX && attrName === 'selected' && dom.tagName === 'OPTION') {\n\t        dom.__riot1374 = value   // #1374\n\t      }\n\t\n\t    } else if (value === 0 || value && typeof value !== T_OBJECT) {\n\t      // <img src=\"{ expr }\">\n\t      if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n\t        attrName = attrName.slice(RIOT_PREFIX.length)\n\t      }\n\t      setAttr(dom, attrName, value)\n\t    }\n\t\n\t  })\n\t\n\t}\n\t/**\n\t * Specialized function for looping an array-like collection with `each={}`\n\t * @param   { Array } els - collection of items\n\t * @param   {Function} fn - callback function\n\t * @returns { Array } the array looped\n\t */\n\tfunction each(els, fn) {\n\t  var len = els ? els.length : 0\n\t\n\t  for (var i = 0, el; i < len; i++) {\n\t    el = els[i]\n\t    // return false -> current item was removed by fn during the loop\n\t    if (el != null && fn(el, i) === false) i--\n\t  }\n\t  return els\n\t}\n\t\n\t/**\n\t * Detect if the argument passed is a function\n\t * @param   { * } v - whatever you want to pass to this function\n\t * @returns { Boolean } -\n\t */\n\tfunction isFunction(v) {\n\t  return typeof v === T_FUNCTION || false   // avoid IE problems\n\t}\n\t\n\t/**\n\t * Get the outer html of any DOM node SVGs included\n\t * @param   { Object } el - DOM node to parse\n\t * @returns { String } el.outerHTML\n\t */\n\tfunction getOuterHTML(el) {\n\t  if (el.outerHTML) return el.outerHTML\n\t  // some browsers do not support outerHTML on the SVGs tags\n\t  else {\n\t    var container = mkEl('div')\n\t    container.appendChild(el.cloneNode(true))\n\t    return container.innerHTML\n\t  }\n\t}\n\t\n\t/**\n\t * Set the inner html of any DOM node SVGs included\n\t * @param { Object } container - DOM node where we will inject the new html\n\t * @param { String } html - html to inject\n\t */\n\tfunction setInnerHTML(container, html) {\n\t  if (typeof container.innerHTML != T_UNDEF) container.innerHTML = html\n\t  // some browsers do not support innerHTML on the SVGs tags\n\t  else {\n\t    var doc = new DOMParser().parseFromString(html, 'application/xml')\n\t    container.appendChild(\n\t      container.ownerDocument.importNode(doc.documentElement, true)\n\t    )\n\t  }\n\t}\n\t\n\t/**\n\t * Checks wether a DOM node must be considered part of an svg document\n\t * @param   { String }  name - tag name\n\t * @returns { Boolean } -\n\t */\n\tfunction isSVGTag(name) {\n\t  return ~SVG_TAGS_LIST.indexOf(name)\n\t}\n\t\n\t/**\n\t * Detect if the argument passed is an object, exclude null.\n\t * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.\n\t * @param   { * } v - whatever you want to pass to this function\n\t * @returns { Boolean } -\n\t */\n\tfunction isObject(v) {\n\t  return v && typeof v === T_OBJECT         // typeof null is 'object'\n\t}\n\t\n\t/**\n\t * Remove any DOM attribute from a node\n\t * @param   { Object } dom - DOM node we want to update\n\t * @param   { String } name - name of the property we want to remove\n\t */\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name)\n\t}\n\t\n\t/**\n\t * Convert a string containing dashes to camel case\n\t * @param   { String } string - input string\n\t * @returns { String } my-string -> myString\n\t */\n\tfunction toCamel(string) {\n\t  return string.replace(/-(\\w)/g, function(_, c) {\n\t    return c.toUpperCase()\n\t  })\n\t}\n\t\n\t/**\n\t * Get the value of any DOM attribute on a node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { String } name - name of the attribute we want to get\n\t * @returns { String | undefined } name of the node attribute whether it exists\n\t */\n\tfunction getAttr(dom, name) {\n\t  return dom.getAttribute(name)\n\t}\n\t\n\t/**\n\t * Set any DOM attribute\n\t * @param { Object } dom - DOM node we want to update\n\t * @param { String } name - name of the property we want to set\n\t * @param { String } val - value of the property we want to set\n\t */\n\tfunction setAttr(dom, name, val) {\n\t  dom.setAttribute(name, val)\n\t}\n\t\n\t/**\n\t * Detect the tag implementation by a DOM node\n\t * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n\t * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n\t */\n\tfunction getTag(dom) {\n\t  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG_IS) ||\n\t    getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n\t}\n\t/**\n\t * Add a child tag to its parent into the `tags` object\n\t * @param   { Object } tag - child tag instance\n\t * @param   { String } tagName - key where the new tag will be stored\n\t * @param   { Object } parent - tag instance where the new child tag will be included\n\t */\n\tfunction addChildTag(tag, tagName, parent) {\n\t  var cachedTag = parent.tags[tagName]\n\t\n\t  // if there are multiple children tags having the same name\n\t  if (cachedTag) {\n\t    // if the parent tags property is not yet an array\n\t    // create it adding the first cached tag\n\t    if (!isArray(cachedTag))\n\t      // don't add the same tag twice\n\t      if (cachedTag !== tag)\n\t        parent.tags[tagName] = [cachedTag]\n\t    // add the new nested tag to the array\n\t    if (!contains(parent.tags[tagName], tag))\n\t      parent.tags[tagName].push(tag)\n\t  } else {\n\t    parent.tags[tagName] = tag\n\t  }\n\t}\n\t\n\t/**\n\t * Move the position of a custom tag in its parent tag\n\t * @param   { Object } tag - child tag instance\n\t * @param   { String } tagName - key where the tag was stored\n\t * @param   { Number } newPos - index where the new tag will be stored\n\t */\n\tfunction moveChildTag(tag, tagName, newPos) {\n\t  var parent = tag.parent,\n\t    tags\n\t  // no parent no move\n\t  if (!parent) return\n\t\n\t  tags = parent.tags[tagName]\n\t\n\t  if (isArray(tags))\n\t    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n\t  else addChildTag(tag, tagName, parent)\n\t}\n\t\n\t/**\n\t * Create a new child tag including it correctly into its parent\n\t * @param   { Object } child - child tag implementation\n\t * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n\t * @param   { String } innerHTML - inner html of the child node\n\t * @param   { Object } parent - instance of the parent tag including the child custom tag\n\t * @returns { Object } instance of the new child tag just created\n\t */\n\tfunction initChildTag(child, opts, innerHTML, parent) {\n\t  var tag = new Tag(child, opts, innerHTML),\n\t    tagName = getTagName(opts.root),\n\t    ptag = getImmediateCustomParentTag(parent)\n\t  // fix for the parent attribute in the looped elements\n\t  tag.parent = ptag\n\t  // store the real parent tag\n\t  // in some cases this could be different from the custom parent tag\n\t  // for example in nested loops\n\t  tag._parent = parent\n\t\n\t  // add this tag to the custom parent tag\n\t  addChildTag(tag, tagName, ptag)\n\t  // and also to the real parent tag\n\t  if (ptag !== parent)\n\t    addChildTag(tag, tagName, parent)\n\t  // empty the child node once we got its template\n\t  // to avoid that its children get compiled multiple times\n\t  opts.root.innerHTML = ''\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * Loop backward all the parents tree to detect the first custom parent tag\n\t * @param   { Object } tag - a Tag instance\n\t * @returns { Object } the instance of the first custom parent tag found\n\t */\n\tfunction getImmediateCustomParentTag(tag) {\n\t  var ptag = tag\n\t  while (!getTag(ptag.root)) {\n\t    if (!ptag.parent) break\n\t    ptag = ptag.parent\n\t  }\n\t  return ptag\n\t}\n\t\n\t/**\n\t * Helper function to set an immutable property\n\t * @param   { Object } el - object where the new property will be set\n\t * @param   { String } key - object key where the new property will be stored\n\t * @param   { * } value - value of the new property\n\t* @param   { Object } options - set the propery overriding the default options\n\t * @returns { Object } - the initial object\n\t */\n\tfunction defineProperty(el, key, value, options) {\n\t  Object.defineProperty(el, key, extend({\n\t    value: value,\n\t    enumerable: false,\n\t    writable: false,\n\t    configurable: true\n\t  }, options))\n\t  return el\n\t}\n\t\n\t/**\n\t * Get the tag name of any DOM node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @returns { String } name to identify this dom node in riot\n\t */\n\tfunction getTagName(dom) {\n\t  var child = getTag(dom),\n\t    namedTag = getAttr(dom, 'name'),\n\t    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n\t                namedTag :\n\t              child ? child.name : dom.tagName.toLowerCase()\n\t\n\t  return tagName\n\t}\n\t\n\t/**\n\t * Extend any object with other properties\n\t * @param   { Object } src - source object\n\t * @returns { Object } the resulting extended object\n\t *\n\t * var obj = { foo: 'baz' }\n\t * extend(obj, {bar: 'bar', foo: 'bar'})\n\t * console.log(obj) => {bar: 'bar', foo: 'bar'}\n\t *\n\t */\n\tfunction extend(src) {\n\t  var obj, args = arguments\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if (obj = args[i]) {\n\t      for (var key in obj) {\n\t        // check if this property of the source object could be overridden\n\t        if (isWritable(src, key))\n\t          src[key] = obj[key]\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\t/**\n\t * Check whether an array contains an item\n\t * @param   { Array } arr - target array\n\t * @param   { * } item - item to test\n\t * @returns { Boolean } Does 'arr' contain 'item'?\n\t */\n\tfunction contains(arr, item) {\n\t  return ~arr.indexOf(item)\n\t}\n\t\n\t/**\n\t * Check whether an object is a kind of array\n\t * @param   { * } a - anything\n\t * @returns {Boolean} is 'a' an array?\n\t */\n\tfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\t\n\t/**\n\t * Detect whether a property of an object could be overridden\n\t * @param   { Object }  obj - source object\n\t * @param   { String }  key - object property\n\t * @returns { Boolean } is this property writable?\n\t */\n\tfunction isWritable(obj, key) {\n\t  var props = Object.getOwnPropertyDescriptor(obj, key)\n\t  return typeof obj[key] === T_UNDEF || props && props.writable\n\t}\n\t\n\t\n\t/**\n\t * With this function we avoid that the internal Tag methods get overridden\n\t * @param   { Object } data - options we want to use to extend the tag instance\n\t * @returns { Object } clean object without containing the riot internal reserved words\n\t */\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))\n\t    return data\n\t\n\t  var o = {}\n\t  for (var key in data) {\n\t    if (!RESERVED_WORDS_BLACKLIST.test(key)) o[key] = data[key]\n\t  }\n\t  return o\n\t}\n\t\n\t/**\n\t * Walk down recursively all the children tags starting dom node\n\t * @param   { Object }   dom - starting node where we will start the recursion\n\t * @param   { Function } fn - callback to transform the child node just found\n\t */\n\tfunction walk(dom, fn) {\n\t  if (dom) {\n\t    // stop the recursion\n\t    if (fn(dom) === false) return\n\t    else {\n\t      dom = dom.firstChild\n\t\n\t      while (dom) {\n\t        walk(dom, fn)\n\t        dom = dom.nextSibling\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Minimize risk: only zero or one _space_ between attr & value\n\t * @param   { String }   html - html string we want to parse\n\t * @param   { Function } fn - callback function to apply on any attribute found\n\t */\n\tfunction walkAttributes(html, fn) {\n\t  var m,\n\t    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\t\n\t  while (m = re.exec(html)) {\n\t    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n\t  }\n\t}\n\t\n\t/**\n\t * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n\t * @param   { Object }  dom - DOM node we want to parse\n\t * @returns { Boolean } -\n\t */\n\tfunction isInStub(dom) {\n\t  while (dom) {\n\t    if (dom.inStub) return true\n\t    dom = dom.parentNode\n\t  }\n\t  return false\n\t}\n\t\n\t/**\n\t * Create a generic DOM node\n\t * @param   { String } name - name of the DOM node we want to create\n\t * @param   { Boolean } isSvg - should we use a SVG as parent node?\n\t * @returns { Object } DOM node just created\n\t */\n\tfunction mkEl(name, isSvg) {\n\t  return isSvg ?\n\t    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n\t    document.createElement(name)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select multiple nodes in the DOM\n\t * @param   { String } selector - DOM selector\n\t * @param   { Object } ctx - DOM node where the targets of our search will is located\n\t * @returns { Object } dom nodes found\n\t */\n\tfunction $$(selector, ctx) {\n\t  return (ctx || document).querySelectorAll(selector)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select a single node in the DOM\n\t * @param   { String } selector - unique dom selector\n\t * @param   { Object } ctx - DOM node where the target of our search will is located\n\t * @returns { Object } dom node found\n\t */\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\t/**\n\t * Simple object prototypal inheritance\n\t * @param   { Object } parent - parent object\n\t * @returns { Object } child instance\n\t */\n\tfunction inherit(parent) {\n\t  function Child() {}\n\t  Child.prototype = parent\n\t  return new Child()\n\t}\n\t\n\t/**\n\t * Get the name property needed to identify a DOM node in riot\n\t * @param   { Object } dom - DOM node we need to parse\n\t * @returns { String | undefined } give us back a string to identify this dom node\n\t */\n\tfunction getNamedKey(dom) {\n\t  return getAttr(dom, 'id') || getAttr(dom, 'name')\n\t}\n\t\n\t/**\n\t * Set the named properties of a tag element\n\t * @param { Object } dom - DOM node we need to parse\n\t * @param { Object } parent - tag instance where the named dom element will be eventually added\n\t * @param { Array } keys - list of all the tag instance properties\n\t */\n\tfunction setNamed(dom, parent, keys) {\n\t  // get the key value we want to add to the tag instance\n\t  var key = getNamedKey(dom),\n\t    isArr,\n\t    // add the node detected to a tag instance using the named property\n\t    add = function(value) {\n\t      // avoid to override the tag properties already set\n\t      if (contains(keys, key)) return\n\t      // check whether this value is an array\n\t      isArr = isArray(value)\n\t      // if the key was never set\n\t      if (!value)\n\t        // set it once on the tag instance\n\t        parent[key] = dom\n\t      // if it was an array and not yet set\n\t      else if (!isArr || isArr && !contains(value, dom)) {\n\t        // add the dom node into the array\n\t        if (isArr)\n\t          value.push(dom)\n\t        else\n\t          parent[key] = [value, dom]\n\t      }\n\t    }\n\t\n\t  // skip the elements with no named properties\n\t  if (!key) return\n\t\n\t  // check whether this key has been already evaluated\n\t  if (tmpl.hasExpr(key))\n\t    // wait the first updated event only once\n\t    parent.one('mount', function() {\n\t      key = getNamedKey(dom)\n\t      add(parent[key])\n\t    })\n\t  else\n\t    add(parent[key])\n\t\n\t}\n\t\n\t/**\n\t * Faster String startsWith alternative\n\t * @param   { String } src - source string\n\t * @param   { String } str - test string\n\t * @returns { Boolean } -\n\t */\n\tfunction startsWith(src, str) {\n\t  return src.slice(0, str.length) === str\n\t}\n\t\n\t/**\n\t * requestAnimationFrame function\n\t * Adapted from https://gist.github.com/paulirish/1579671, license MIT\n\t */\n\tvar rAF = (function (w) {\n\t  var raf = w.requestAnimationFrame    ||\n\t            w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame\n\t\n\t  if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {  // buggy iOS6\n\t    var lastTime = 0\n\t\n\t    raf = function (cb) {\n\t      var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0)\n\t      setTimeout(function () { cb(lastTime = nowtime + timeout) }, timeout)\n\t    }\n\t  }\n\t  return raf\n\t\n\t})(window || {})\n\t\n\t/**\n\t * Mount a tag creating new Tag instance\n\t * @param   { Object } root - dom node where the tag will be mounted\n\t * @param   { String } tagName - name of the riot tag we want to mount\n\t * @param   { Object } opts - options to pass to the Tag instance\n\t * @returns { Tag } a new Tag instance\n\t */\n\tfunction mountTo(root, tagName, opts) {\n\t  var tag = __tagImpl[tagName],\n\t    // cache the inner HTML to fix #855\n\t    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\t\n\t  // clear the inner html\n\t  root.innerHTML = ''\n\t\n\t  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount()\n\t    // add this tag to the virtualDom variable\n\t    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n\t  }\n\t\n\t  return tag\n\t}\n\t/**\n\t * Riot public api\n\t */\n\t\n\t// share methods for other riot parts, e.g. compiler\n\triot.util = { brackets: brackets, tmpl: tmpl }\n\t\n\t/**\n\t * Create a mixin that could be globally shared across all the tags\n\t */\n\triot.mixin = (function() {\n\t  var mixins = {},\n\t    globals = mixins[GLOBAL_MIXIN] = {},\n\t    _id = 0\n\t\n\t  /**\n\t   * Create/Return a mixin by its name\n\t   * @param   { String }  name - mixin name (global mixin if object)\n\t   * @param   { Object }  mixin - mixin logic\n\t   * @param   { Boolean } g - is global?\n\t   * @returns { Object }  the mixin logic\n\t   */\n\t  return function(name, mixin, g) {\n\t    // Unnamed global\n\t    if (isObject(name)) {\n\t      riot.mixin('__unnamed_'+_id++, name, true)\n\t      return\n\t    }\n\t\n\t    var store = g ? globals : mixins\n\t\n\t    // Getter\n\t    if (!mixin) {\n\t      if (typeof store[name] === T_UNDEF) {\n\t        throw new Error('Unregistered mixin: ' + name)\n\t      }\n\t      return store[name]\n\t    }\n\t    // Setter\n\t    if (isFunction(mixin)) {\n\t      extend(mixin.prototype, store[name] || {})\n\t      store[name] = mixin\n\t    }\n\t    else {\n\t      store[name] = extend(store[name] || {}, mixin)\n\t    }\n\t  }\n\t\n\t})()\n\t\n\t/**\n\t * Create a new riot tag implementation\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   html - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\triot.tag = function(name, html, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css\n\t      css = ''\n\t    } else attrs = ''\n\t  }\n\t  if (css) {\n\t    if (isFunction(css)) fn = css\n\t    else styleManager.add(css)\n\t  }\n\t  name = name.toLowerCase()\n\t  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation (for use by the compiler)\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   html - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\triot.tag2 = function(name, html, css, attrs, fn) {\n\t  if (css) styleManager.add(css)\n\t  //if (bpair) riot.settings.brackets = bpair\n\t  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\t/**\n\t * Mount a tag using a specific tag implementation\n\t * @param   { String } selector - tag DOM selector\n\t * @param   { String } tagName - tag implementation name\n\t * @param   { Object } opts - tag logic\n\t * @returns { Array } new tags instances\n\t */\n\triot.mount = function(selector, tagName, opts) {\n\t\n\t  var els,\n\t    allTags,\n\t    tags = []\n\t\n\t  // helper functions\n\t\n\t  function addRiotTags(arr) {\n\t    var list = ''\n\t    each(arr, function (e) {\n\t      if (!/[^-\\w]/.test(e)) {\n\t        e = e.trim().toLowerCase()\n\t        list += ',[' + RIOT_TAG_IS + '=\"' + e + '\"],[' + RIOT_TAG + '=\"' + e + '\"]'\n\t      }\n\t    })\n\t    return list\n\t  }\n\t\n\t  function selectAllTags() {\n\t    var keys = Object.keys(__tagImpl)\n\t    return keys + addRiotTags(keys)\n\t  }\n\t\n\t  function pushTags(root) {\n\t    if (root.tagName) {\n\t      var riotTag = getAttr(root, RIOT_TAG_IS) || getAttr(root, RIOT_TAG)\n\t\n\t      // have tagName? force riot-tag to be the same\n\t      if (tagName && riotTag !== tagName) {\n\t        riotTag = tagName\n\t        setAttr(root, RIOT_TAG_IS, tagName)\n\t        setAttr(root, RIOT_TAG, tagName) // this will be removed in riot 3.0.0\n\t      }\n\t      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)\n\t\n\t      if (tag) tags.push(tag)\n\t    } else if (root.length) {\n\t      each(root, pushTags)   // assume nodeList\n\t    }\n\t  }\n\t\n\t  // ----- mount code -----\n\t\n\t  // inject styles into DOM\n\t  styleManager.inject()\n\t\n\t  if (isObject(tagName)) {\n\t    opts = tagName\n\t    tagName = 0\n\t  }\n\t\n\t  // crawl the DOM to find the tag\n\t  if (typeof selector === T_STRING) {\n\t    if (selector === '*')\n\t      // select all the tags registered\n\t      // and also the tags found with the riot-tag attribute set\n\t      selector = allTags = selectAllTags()\n\t    else\n\t      // or just the ones named like the selector\n\t      selector += addRiotTags(selector.split(/, */))\n\t\n\t    // make sure to pass always a selector\n\t    // to the querySelectorAll function\n\t    els = selector ? $$(selector) : []\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    els = selector\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectAllTags()\n\t    // if the root els it's just a single tag\n\t    if (els.tagName)\n\t      els = $$(tagName, els)\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = []\n\t      each(els, function (_el) {\n\t        nodeList.push($$(tagName, _el))\n\t      })\n\t      els = nodeList\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0\n\t  }\n\t\n\t  pushTags(els)\n\t\n\t  return tags\n\t}\n\t\n\t/**\n\t * Update all the tags instances created\n\t * @returns { Array } all the tags instances\n\t */\n\triot.update = function() {\n\t  return each(__virtualDom, function(tag) {\n\t    tag.update()\n\t  })\n\t}\n\t\n\t/**\n\t * Export the Virtual DOM\n\t */\n\triot.vdom = __virtualDom\n\t\n\t/**\n\t * Export the Tag constructor\n\t */\n\triot.Tag = Tag\n\t  // support CommonJS, AMD & browser\n\t  /* istanbul ignore next */\n\t  if (typeof exports === T_OBJECT)\n\t    module.exports = riot\n\t  else if (\"function\" === T_FUNCTION && typeof __webpack_require__(/*! !webpack amd options */ 23) !== T_UNDEF)\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return riot }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t  else\n\t    window.riot = riot\n\t\n\t})(typeof window != 'undefined' ? window : void 0);\n\n\n/***/ },\n/* 2 */\n/*!*********************************************************!*\\\n  !*** ../~/promissory-arbiter/src/promissory-arbiter.js ***!\n  \\*********************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function iife (root, factory) {\n\t  'use strict';\n\t\n\t  var moduleName = 'Arbiter';\n\t\n\t  // Detect AMD/RequireJS environments and register as an anonymous module\n\t  if (typeof root.define === 'function') {\n\t    root.define(['exports'], factory);\n\t\n\t  // Detect CommonJS/Node environments and export arbiter\n\t  } else if (true) {\n\t    module.exports = factory();\n\t\n\t  // Other \"global\" environments such as browsers. Attempt to expose itself\n\t  // using the revealing module pattern.\n\t  } else {\n\t    root[moduleName] = factory();\n\t  }\n\t  // TODO When a browser ships ES6 modules support, detect it and expose the\n\t  // goods. This is not done because there is some uncertainty how browsers will\n\t  // handle these features. Possible methods are:\n\t  // 1) Using try/catching around import/export statement\n\t  // 2) Try some sort of lazy loading mechanism\n\t}(this, function factory () {\n\t  'use strict';\n\t\n\t  return create();\n\t\n\t  /**\n\t   * A Topic is simply a string. This string is can contain any character, but\n\t   * two characters have special meanings. The comma `','`, with optional\n\t   * whitespace, separates individual Topics. This means that `\"a, b\"` is the\n\t   * same as two separate topics, `[\"a\", \"b\"]`. The second special character is\n\t   * the period or dot `'.'`. This character separates generations. In the\n\t   * example `\"a.b\"`, `\"a\"` is an ancestor of it and `\"a.b.c\"` is a descendent\n\t   * of it. This creates a hierarchical relationship between topics. When\n\t   * you publish a topic all of the ancestors or parents are also\n\t   * notified. The empty string is an ancestor all topics. When publishing\n\t   * to `\"a.b.c.d\"`, all subscribers to `\"\"`, `\"a\"`, `\"a.b\"`, `\"a.b.c\"`,\n\t   * `\"a.b.c.d\"` will be executed in priority order. If there is a\n\t   * subscriber to `\"\"` with a very high priority, it will be notified\n\t   * before `\"a\"` with a much lower priority.\n\t   *\n\t   * @typedef Topic\n\t   * @memberof Arbiter\n\t   * @example\n\t   *\n\t   * Arbiter.subscribe('', function f1 () {});\n\t   * Arbiter.subscribe('a', function f2 () {});\n\t   * Arbiter.subscribe('a.b', function f3 () {});\n\t   * Arbiter.subscribe('a.c', function f4 () {});\n\t   * Arbiter.subscribe('a.b.c', function f5 () {});\n\t   * Arbiter.publish('a.b'); // Executes f1, f2, f3 in priority order\n\t   */\n\t\n\t  // *************************************************************************\n\t  //   Public Instance Functions\n\t  // *************************************************************************\n\t\n\t  /**\n\t   * `Arbiter.subscribe` registers a subscription to a topic and its\n\t   * descendants. When a publication occurs it will be notified. The behavior\n\t   * can be modified by using the options parameter. `options.priority`\n\t   * establishes the order to notify subscribers when multiple subscribers\n\t   * exist. The other option is `ignorePersisted`. This allows a subscriber\n\t   * to skip being notified of saved messages.\n\t   *\n\t   * @function subscribe\n\t   * @memberof Arbiter\n\t   *\n\t   * @param {Topic|Topic[]} topic The title of the topic to listen for\n\t   *   publications. Topics are hierarchical can be separated by `\",\"`.\n\t   * @param {Subscription} subscription The function to invoke every\n\t   *   time a publication occurs. If `subscription` is not a function, a\n\t   *   no-operation is put in its place.\n\t   * @param {Object} [options]. An object that can have two properties.\n\t   *   `ignorePersited` and `priority`.\n\t   * @param {Object} [context=null] The value of `this` for the subscription.\n\t   * @return {Token} A unique token to remove this subscription from\n\t   *   the distribution list.\n\t   *\n\t   * @example\n\t   * Arbiter.publish('my.topic', null, {persist: true});\n\t   * Arbiter.subscribe('my.topic', log, {ignorePersisted: true}); // => Nothing\n\t   */\n\t\n\t  /**\n\t   * A Subscription is a function provided to the `subscribe` method. It is used\n\t   * as a callback when a publication occurs. The subscriber is considered\n\t   * \"done working\" if it returns a value (even `undefined`). If an error is\n\t   * thrown, then it is assumed that the subscriber failed. If it returns a\n\t   * `Promise`, then it is \"done\" when the `Promise` is fulfilled. If rejected,\n\t   * it is assumed to fail. If the subscriber function has a length of 3\n\t   * or more, then it is provided with callback function as the third argument\n\t   * to be treated as a node-style callback. The first argument to the callback\n\t   * is the error and the second is the \"return value\".\n\t   *\n\t   * @callback Subscription\n\t   * @memberof Arbiter\n\t   * @param {Object} data The data associated with the publication.\n\t   * @param {Topic} topic The topic to which the publication belongs.\n\t   * @param {Function} [callback] A node style callback.\n\t   * @return {Object} This is either a `Promise` or a value used to\n\t   *   communicate when the subscriber is done.\n\t   *\n\t   * @example\n\t   *\n\t   * // All of the following look the same from a publishers perspective.\n\t   * Arbiter.subscribe('my.topic', function() {\n\t   *   return new Promise(function(fulfill, reject) {\n\t   *     Math.random() > 0.5 ? fulfill('hi') : reject('bye');\n\t   *   });\n\t   * });\n\t   *\n\t   * Arbiter.subscribe('my.topic', function(data, topic, done) {\n\t   *   Math.random() > 0.5 ? done(null, 'hi') : done('bye');\n\t   * });\n\t   *\n\t   * Arbiter.subscribe('my.topic', function() {\n\t   *   if (Math.random() > 0.5) {\n\t   *     return 'hi';\n\t   *   } else {\n\t   *     throw 'bye';\n\t   *   }\n\t   * });\n\t   */\n\t  function subscribe (state, topic, subscription, options, context) {\n\t    assert(typeof topic, 'string', 'Arbiter.subscribe', 'strings', 'topics');\n\t    options = merge(state.options, options);\n\t\n\t    var\n\t      ancestor = addTopicLine(\n\t        topic, ancestorTopicSearch(topic, state._topics)\n\t      ),\n\t      node = insert(\n\t        getPriority,\n\t        createSubscription(state, subscription, options, context),\n\t        ancestor.subscriptions\n\t      ),\n\t      subscriptionToken = {\n\t        topic: topic,\n\t        id: node.id,\n\t        priority: node.priority\n\t      };\n\t\n\t    // Notify late subscribers of persisted messages\n\t    if (!options.ignorePersisted) {\n\t      var\n\t        persistedDescendents = map(getPersisted, descendents(ancestor)),\n\t        persistedMessages = mergeBy(getFingerArrayOrder, persistedDescendents),\n\t\n\t        persisted, i, n;\n\t\n\t      for (i = 0, n = persistedMessages.length; i < n; i++) {\n\t        persisted = persistedMessages[i];\n\t        !subscription.suspended // eslint-disable-line no-unused-expressions\n\t          && subscription.call(\n\t            subscription.context, persisted.data, persisted.topic\n\t          );\n\t      }\n\t    }\n\t\n\t    return subscriptionToken;\n\t  }\n\t\n\t  /**\n\t   * `Arbiter.publish` notifies all subscribers of a publication by invoking\n\t   * their subscription function with the data and topic associated with the\n\t   * publication.\n\t   *\n\t   * @function publish\n\t   * @memberof Arbiter\n\t   *\n\t   * @param {Topic} topic All subscribers to this topic, will be notified of\n\t   *   the publication\n\t   * @param {Object} [data] This data is the publication that all subscribers\n\t   *   will receive.\n\t   * @param {Object} [options] These options override the options in\n\t   *   Arbiter.options for this publication only. See [`Options`](#options) for\n\t   *   a complete list\n\t   * @return {PublicationPromise} This resolves according to\n\t   *   [`Options`](#options)\n\t   *\n\t   * @example\n\t   *\n\t   * var options = {persist: true, preventBubble: true};\n\t   * Arbiter.publish('app.init', 'initialization', options);\n\t   * Arbiter.subscribe('app', log); // => Nothing because of `preventBubble`\n\t   * Arbiter.subscribe('app.init', log); // => logs app.init initialization\n\t   */\n\t\n\t  /**\n\t   * `publish` returns a `PublicationPromise`. This is a regular old\n\t   * promise with some additional properties described below. Each property is\n\t   * updated in real time as updates occur; it stops updating when the promise\n\t   * fulfills. This can be changed with\n\t   * `Arbiter.options.updateAfterSettlement`.\n\t   *\n\t   * @typedef PublicationPromise PublicationPromise\n\t   * @memberof Arbiter\n\t   * @property {number} fulfilled The number of promises fulfilled when this\n\t   *   promise settles.\n\t   * @property {number} rejected The number of promises rejected when this\n\t   *   promise settles.\n\t   * @property {number} pending The number of promises pending when this\n\t   *   promise settles.\n\t   * @property {Token} token If the `options.persist` is true, then a token is\n\t   *   added to the promise so it can be removed later.\n\t   *\n\t   * @example\n\t   *\n\t   * Arbiter.subscribe('get', getFromCache);\n\t   * Arbiter.subscribe('get', getFromAjax);\n\t   * Arbiter.publish('get', {latch: 1})\n\t   *   .then(function(data) {\n\t   *     // This is fulfilled when one of the subscribers fulfills because\n\t   *     // of `latch: 1`. In this case we could also use `latch: 0.5`.\n\t   *   }, function(errs) {\n\t   *     // This occurs when it is impossible to satisify the latch. In this\n\t   *     // case, both have to fail.\n\t   *   });\n\t   *\n\t   */\n\t  function publish (state, topic, data, options) {\n\t    assert(typeof topic, 'string', 'Arbiter.publish', 'strings', 'topics');\n\t    options = merge(state.options, options);\n\t\n\t    var args = [state, topic, data, options];\n\t    if (options.sync) {\n\t      return hierarchicalTopicDispatcher(state, topic, data, options);\n\t    }\n\t\n\t    return async(hierarchicalTopicDispatcher, args);\n\t  }\n\t\n\t  /**\n\t   *  `Arbiter.unsubscribe` removes the subscribers associated with a token or\n\t   *  a topic. This prevents them from being notified when a publication\n\t   *  occurs. By default these cannot be recovered, however this also allows\n\t   *  us to temporarily suspend them instead.\n\t   *\n\t   * @function unsubscribe\n\t   * @memberof Arbiter\n\t   *\n\t   * @param {Token|Topic} token Removes the subscription associated with the\n\t   *   provided token. If a topic is provided, then this removes all\n\t   *   subscribers and their descendants are removed.\n\t   * @param {Boolean} [suspend=false] If this true, then the subscriptions\n\t   *   are only suspended. This means that they will not be notified of any\n\t   *   publications, but they can be re-enabled with [Arbiter.resubscribe].\n\t   * @return {Boolean} Returns false if the token's subscription cannot be\n\t   *   located and true otherwise. This returns an array if multiple tokens\n\t   *   or topics used.\n\t   *\n\t   * @example\n\t   *\n\t   * Arbiter.subscribe('a', function a () {});\n\t   * Arbiter.subscribe('a.b', function ab () {});\n\t   * var bToken = Arbiter.subscribe('b', function b () {});\n\t   * Arbiter.subscribe('c', function c () {});\n\t   * Arbiter.unsubscribe(bToken); // 'a', 'a.b', 'c' remain\n\t   * Arbiter.unsubscribe('a'); // Only 'c' remains\n\t   * Arbiter.unsubscribe(''); // Removes all subscriptions\n\t   */\n\t  function unsubscribe (state, tokens, suspend) {\n\t    tokens = typeof tokens === 'string' ? tokens.split(/,\\s*/) : tokens;\n\t    tokens = !tokens.length ? [tokens] : tokens;\n\t\n\t    var result = curryMap(\n\t      {topics: state._topics, suspend: suspend}, removeSubscriber, tokens\n\t    );\n\t\n\t    return result.length === 1 ? result[0] : result;\n\t  }\n\t\n\t  /**\n\t   *  Reactivates all subscriptions associated with a token or all\n\t   *  subscriptions that are descendants of a topic.\n\t   *\n\t   * @function resubscribe\n\t   * @memberof Arbiter\n\t   *\n\t   * @param {Token|Topic} token The token or topic to reactivates\n\t   * @return {Boolean} Returns false if the token's subscription cannot be\n\t   *   located and true otherwise. This returns an array if multiple tokens\n\t   *   or topics used.\n\t   *\n\t   * @example\n\t   *\n\t   * Arbiter.subscribe('a, b, c', function() {}); // Create 3 listeners\n\t   * Arbiter.unsubscribe('', true); // Suspends all listeners\n\t   * Arbiter.resubscribe(''); // Resumes all listeners\n\t   */\n\t  function resubscribe (state, tokens) {\n\t    tokens = typeof tokens === 'string' ? tokens.split(/,\\s*/) : tokens;\n\t    tokens = !tokens.length ? [tokens] : tokens;\n\t\n\t    var result = curryMap(state._topics, unsuspendSubscriber, tokens);\n\t\n\t    return result.length === 1 ? result[0] : result;\n\t  }\n\t\n\t  /**\n\t   * Removes the publications that are stored (persisted) for late subscribers\n\t   * by providing either a `Token` or a `Topic`.\n\t   *\n\t   * @memberof Arbiter\n\t   * @param {Token|Topic} token The publication or topics to remove. Note: If\n\t   *   provided the [PublicationPromise], then this uses the token\n\t   *   associated with it.\n\t   * @return {Boolean} `false` if the topic or token does not exist, `true`\n\t   *   otherwise.\n\t   *\n\t   * @example\n\t   *\n\t   * Arbiter.publish('a', null, {persist: true});\n\t   * Arbiter.subscribe('a', function a1 () {}); // Executes a1\n\t   * Arbiter.removedPersisted();\n\t   * Arbiter.subscribe('a', function a2 () {}); // Does not execute a2\n\t   */\n\t  function removePersisted (topics, token) {\n\t    if (typeof token === 'string') {\n\t      return !!applyTopicDescendents(empty, 'persisted', token, topics);\n\t    }\n\t\n\t    var\n\t      tokenTopic = token.topic,\n\t      node = ancestorTopicSearch(tokenTopic, topics);\n\t\n\t    if (node.topic !== tokenTopic) {\n\t      return false;\n\t    }\n\t\n\t    var\n\t      id = token.id,\n\t      persisted = node.persisted,\n\t      i = binaryIndexBy(getId, id, node.persisted),\n\t      persistedMessage = persisted[i];\n\t\n\t    if (persistedMessage && persistedMessage.order === id) {\n\t      persisted.splice(i, 1);\n\t      return true;\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  /**\n\t   * Creates a new instance of Arbiter that is completely separate from the\n\t   * original. It has its own set of topics, subscribers, and options.\n\t   *\n\t   * @function create\n\t   * @memberof Arbiter\n\t   *\n\t   * @return {Arbiter} The new instance.\n\t   *\n\t   * @example\n\t   *\n\t   * var arbiter = Arbiter.create();\n\t   * Arbiter.subscribe('a', function a () {});\n\t   * arbiter.publish('a'); // Does not execute a\n\t   */\n\t  function create () {\n\t    /**\n\t     * Arbiter has a few options to affect the way that subscribers are\n\t     * notified and PublicationPromises are resolved.\n\t     *\n\t     * @typedef Options\n\t     * @memberof Arbiter\n\t     *\n\t     * @property {boolean} persist=false When true, subscribers are notified\n\t     *   of past messages.\n\t     * @property {boolean} sync=false When true, invokes the subscription\n\t     *   functions synchronously.\n\t     * @property {boolean} preventBubble=false When true, only the topics\n\t     *   that match the published topics exactly are invoked.\n\t     * @property {number} latch=0.9999999999999999 When this number is less\n\t     *   than one, it is the ratio of subscribers that must fulfilled before\n\t     *   resolving the `PublicationPromise`. If greater or equal to one,\n\t     *   then it is a count of the subscribers that must fulfill.\n\t     * @property {boolean} settlementLatch=false Changes the resolving logic\n\t     *   of `PublicationPromise` to be based off resolved rather than\n\t     *   fulfilled promises. This means that failed subscribers will count\n\t     *   toward the tally of latch.\n\t     * @property {number} semaphor=Infinity The maximum number of subscribers\n\t     *   to allowed to be pending at any given point in time.\n\t     * @property {boolean} updateAfterSettlement=false If true, updates the\n\t     *   `PublicationPromise` after it resolves.\n\t     *\n\t     * @example\n\t     *\n\t     * Arbiter.subscribe('a', log);\n\t     * Arbiter.subscribe('a.b', log);\n\t     * Arbiter.subscribe('a.b.c', log);\n\t     * var promise = Arbiter.publish('a.b.c', {latch: 1});\n\t     *\n\t     * // Remeber publish is async by default?\n\t     * // promise.pending === 3;\n\t     * // promise.fulfilled === 0;\n\t     * // promise.rejected === 0;\n\t     */\n\t    var\n\t      topics = createNode(''),\n\t      options = {\n\t        persist: false,\n\t        sync: false,\n\t        preventBubble: false,\n\t        latch: 0.9999999999999999,\n\t        settlementLatch: false,\n\t        semaphor: Infinity,\n\t        updateAfterSettlement: false\n\t      },\n\t      arbiter = {\n\t        _topics: topics,\n\t        options: options,\n\t        version: 'v1.0.0',\n\t        id: mkGenerator(),\n\t        create: create\n\t      };\n\t\n\t    arbiter.subscribe = partial1(subscribeDispatcher, arbiter);\n\t    arbiter.publish = partial1(publish, arbiter);\n\t    arbiter.unsubscribe = partial1(unsubscribe, arbiter);\n\t    arbiter.resubscribe = partial1(resubscribe, arbiter);\n\t    arbiter.removePersisted = partial1(removePersistedDispatcher, arbiter);\n\t\n\t    return arbiter;\n\t  }\n\t\n\t  // *************************************************************************\n\t  //   Private Arbiter Data Structures Functions\n\t  // *************************************************************************\n\t\n\t  // Takes care of all the heavy lifting of publishing a message. This\n\t  // includes locating all topics, their subscribers, publishing the data and,\n\t  // if necessary, storing the message for late subscribers.\n\t  function hierarchicalTopicDispatcher (state, topic, data, options) {\n\t    var\n\t      lineage = findLineage(getTopic, isAncestorTopic, topic, state._topics),\n\t      topicNode = lineage[lineage.length - 1],\n\t      subscriptions = options.preventBubble\n\t        ? topicNode.topic === topic ? topicNode.subscriptions : []\n\t        : mergeBy(getFingerArrayPriority, map(getSubscriptions, lineage)),\n\t      fulfilledPromise = subscriptionDispatcher(\n\t        topic, data, options, subscriptions\n\t      );\n\t\n\t    if (options.persist) {\n\t      var id = state.id();\n\t\n\t      topicNode = addTopicLine(topic, topicNode);\n\t      topicNode.persisted.push(\n\t        {topic: topic, data: data, order: id}\n\t      );\n\t      fulfilledPromise.token = {\n\t        topic: topic,\n\t        id: id\n\t      };\n\t    }\n\t\n\t    return fulfilledPromise;\n\t  }\n\t\n\t  // Invokes the next set of subscriptions\n\t  function resumeSubscriptionDispatcher (\n\t    topic, data, options, subscriptions, resolver, fulfill, reject\n\t  ) {\n\t    var\n\t      promise = resolver.promise,\n\t\n\t      subscription;\n\t\n\t    for (\n\t      ;\n\t      resolver.i >= 0 && promise.pending < options.semaphor;\n\t      resolver.i -= 1\n\t    ) {\n\t      subscription = subscriptions[resolver.i];\n\t      if (!subscription.suspended) {\n\t        promise.pending += 1;\n\t        subscriptionInvoker(subscription, data, topic).then(fulfill, reject);\n\t      }\n\t    }\n\t  }\n\t\n\t  // Takes care of sending all the requests on their way\n\t  function removePersistedDispatcher (state, tokens) {\n\t    tokens = tokens && tokens.token || tokens || '';\n\t    tokens = typeof tokens === 'string' ? tokens.split(/,\\s*/) : tokens;\n\t    tokens = !tokens.length ? [tokens] : tokens;\n\t\n\t    var result = curryMap(state._topics, removePersisted, tokens);\n\t\n\t    return result.length === 1 ? result[0] : result;\n\t  }\n\t\n\t  // Invokes all the subscriptions according to `options` and returns a promise\n\t  // that resolves according to `options`.\n\t  function subscriptionDispatcher (topic, data, options, subscriptions) {\n\t    var\n\t      resolver = createResolver(),\n\t      fulfill = resolveUse('fulfilledValues', 'fulfilled', options, resolver),\n\t      reject = resolveUse('rejectedValues', 'rejected', options, resolver);\n\t\n\t    resolver.i = subscriptions.length - 1;\n\t    resolver.resume = {\n\t      topic: topic,\n\t      data: data,\n\t      subscriptions: subscriptions,\n\t      fulfill: fulfill,\n\t      reject: reject\n\t    };\n\t\n\t    resumeSubscriptionDispatcher(\n\t      topic, data, options, subscriptions, resolver, fulfill, reject\n\t    );\n\t    evaluateLatch(resolver, options);\n\t\n\t    return resolver.promise;\n\t  }\n\t\n\t  // Takes care all the bookkeeping work surrounding a subscriber resolving\n\t  // resolving.\n\t  function resolveUse (appendList, increment, options, resolver) {\n\t    return function resolveUseClosure (value) {\n\t      // TODO This should state.options('update..\n\t      // TODO look at all of options.xxxx\n\t      if (resolver.settled && !options.updateAfterSettlement) {\n\t        return;\n\t      }\n\t\n\t      var promise = resolver.promise;\n\t      resolver[appendList].push(value);\n\t      promise[increment] += 1;\n\t      promise.pending -= 1;\n\t\n\t      if (resolver.i >= 0) {\n\t        var resume = resolver.resume;\n\t\n\t        resumeSubscriptionDispatcher(\n\t          resume.topic, resume.data, options, resume.subscriptions,\n\t          resolver, resume.fulfill, resume.reject\n\t        );\n\t        return;\n\t      }\n\t\n\t      evaluateLatch(resolver, options);\n\t    };\n\t  }\n\t\n\t  // Resolves the latch according to `options`. Computes the hypothetical max\n\t  // and resolves if is not met.\n\t  function evaluateLatch (resolver, options) {\n\t    var\n\t      settlementLatch = options.settlementLatch,\n\t      latch = options.latch,\n\t      promise = resolver.promise,\n\t      fulfilled = promise.fulfilled,\n\t      pending = promise.pending,\n\t      rejected = promise.rejected,\n\t      settled = fulfilled + rejected,\n\t      maxFulfilled = fulfilled + pending,\n\t      total = fulfilled + pending + rejected;\n\t\n\t    if (resolver.settled) {\n\t      return resolver.settled;\n\t    }\n\t\n\t    if (!settlementLatch && latch >= 1 && maxFulfilled < latch\n\t      || !settlementLatch && latch < 1 && maxFulfilled / total < latch\n\t      || settlementLatch && latch >= 1 && total < latch\n\t      || settlementLatch && latch < 1 && total === 0\n\t    ) {\n\t      resolver.settled = true;\n\t      return resolver.reject(resolver.rejectedValues);\n\t    }\n\t\n\t    if (!settlementLatch && latch >= 1 && fulfilled >= latch\n\t      || !settlementLatch && latch < 1 && fulfilled / total >= latch\n\t      || settlementLatch && latch >= 1 && settled >= latch\n\t      || settlementLatch && latch < 1 && settled / total >= latch\n\t    ) {\n\t      resolver.settled = true;\n\t      return settlementLatch\n\t        ? resolver.fulfill(\n\t          resolver.fulfilledValues.concat(resolver.rejectedValues)\n\t        ) : resolver.fulfill(resolver.fulfilledValues);\n\t    }\n\t\n\t    return resolver.settled;\n\t  }\n\t\n\t  // Invokes a subscription with the required parameters and acts as an adapter\n\t  // for the different asynchronous mechanisms behavior. i.e. node-style\n\t  // callbacks and promises.\n\t  function subscriptionInvoker (subscription, data, topic) {\n\t    var result;\n\t\n\t    if (subscription.fn.length === 3) {\n\t      return new Promise(function promiseResolver (fulfill, reject) {\n\t        subscription.fn.call(\n\t          subscription.context, data, topic, function callback (err, succ) {\n\t            return err ? reject(err) : fulfill(succ);\n\t          }\n\t        );\n\t      });\n\t    }\n\t\n\t    try {\n\t      result = subscription.fn.call(subscription.context, data, topic);\n\t    } catch (e) {\n\t      return Promise.reject(e);\n\t    }\n\t\n\t    if (result && typeof result.then === 'function') {\n\t      return result;\n\t    }\n\t\n\t    return Promise.resolve(result);\n\t  }\n\t\n\t  // This coverts `topic`, which can represent multiple subscriptions and\n\t  // serializes them into individual topics for use with the `subscription`\n\t  function subscribeDispatcher (state, topic, subscriptions, options, context) {\n\t    topic = typeof topic === 'string' ? topic.split(/,\\s*/) : topic;\n\t    topic = topic && topic.length ? topic : [topic];\n\t\n\t    var result = curryMap(\n\t      [state, null, subscriptions, options, context],\n\t      subscribeTopicApplier,\n\t      topic\n\t    );\n\t\n\t    return result.length === 1 ? result[0] : result;\n\t  }\n\t\n\t  // This is (in combination with curryMap) is a hack to prevent us from\n\t  // creating a closures on every subscription.\n\t  function subscribeTopicApplier (args, topic) {\n\t    args[1] = topic;\n\t    return subscribe.apply(null, args);\n\t  }\n\t\n\t  // For all descendants of `topic` remove all elements of `node[property`.\n\t  function applyTopicDescendents (f, property, topic, topics) {\n\t    var node = ancestorTopicSearch(topic, topics);\n\t    if (node.topic === topic) {\n\t      return curryMap(property, f, descendents(node));\n\t    }\n\t\n\t    return null;\n\t  }\n\t\n\t  // Finds the subscription associated with a token and unsuspendes it.\n\t  // Returns false if it was removed and true it was unsuspended.\n\t  function unsuspendSubscriber (topic, token) {\n\t    if (typeof token === 'string') {\n\t      return !!applyTopicDescendents(\n\t        unsuspendTopic, 'subscriptions', token, topic\n\t      );\n\t    }\n\t\n\t    var node = ancestorTopicSearch(token.topic, topic);\n\t    if (node.topic !== token.topic) {\n\t      return false;\n\t    }\n\t\n\t    var i = searchAround(\n\t      getId, getPriority,\n\t      token.id, token.priority,\n\t      binaryIndexBy(getPriority, token.priority, node.subscriptions),\n\t      node.subscriptions\n\t    );\n\t\n\t    if (i === -1) {\n\t      return false;\n\t    }\n\t\n\t    return !!unsuspendNode(node.subscriptions[i]);\n\t  }\n\t\n\t  // Finds the subscription associated with a token and removes or suspends is.\n\t  // If the subscription associated with a token cannot be found then this\n\t  // returns false. This usually means that the token was already removed.\n\t  function removeSubscriber (args, token) {\n\t    var\n\t      topics = args.topics,\n\t      suspendSubs = args.suspend;\n\t\n\t    if (typeof token === 'string') {\n\t      return !!applyTopicDescendents(\n\t        suspendSubs ? suspendTopic : empty, 'subscriptions', token, topics\n\t      );\n\t    }\n\t\n\t    var node = ancestorTopicSearch(token.topic, topics);\n\t    if (node.topic !== token.topic) {\n\t      return false;\n\t    }\n\t\n\t    var i = searchAround(\n\t      getId, getPriority,\n\t      token.id, token.priority,\n\t      binaryIndexBy(getPriority, token.priority, node.subscriptions),\n\t      node.subscriptions\n\t    );\n\t\n\t    if (i === -1) {\n\t      return false;\n\t    }\n\t\n\t    if (suspendSubs) {\n\t      return !!suspendNode(node.subscriptions[i]);\n\t    }\n\t\n\t    return !!node.subscriptions.splice(i, 1);\n\t  }\n\t\n\t  // Finds the closest ancestor topic\n\t  function ancestorTopicSearch (topic, node) {\n\t    return ancestorSearch(getTopic, topic, isAncestorTopic, node);\n\t  }\n\t\n\t  // Takes a topic and an ancestor and adds all of the generations from the\n\t  // ancestor to the topic returning the topic that represents the node.\n\t  function addTopicLine (topic, ancestor) {\n\t    var\n\t      ancestorTopic = ancestor.topic,\n\t      additionalTopics = [];\n\t\n\t    if (ancestorTopic !== topic) {\n\t      // All of the generations to add seeded by the youngest existing ancestor\n\t      additionalTopics = reduce(\n\t        appendPrefixedTopic, [ancestorTopic],\n\t        topic.substr(ancestorTopic.length).replace(/^\\./, '').split('.')\n\t      );\n\t    }\n\t\n\t    // Add a node to the tree for each new topic\n\t    return addFamilyLine(\n\t      addChildTopic, map(createNode, additionalTopics.slice(1)), ancestor\n\t    );\n\t  }\n\t\n\t  // Adds a child to the tree sorted by the nodes topics. Note: The parameters\n\t  // are in the reverse order because the sole purpose of this function is to\n\t  // be fed into reduce.\n\t  function addChildTopic (tree, child) {\n\t    return addChild(getTopic, child, tree);\n\t  }\n\t\n\t  // Appends the fully qualified topic name to the array using the last\n\t  // element of the array. This array must have length 1. If it should start\n\t  // at the root, then the array should be [ '' ].\n\t  function appendPrefixedTopic (arr, topic) {\n\t    var prefix = arr[arr.length - 1] === ''\n\t      ? '' : arr[arr.length - 1] + '.';\n\t\n\t    arr.push(prefix + topic);\n\t    return arr;\n\t  }\n\t\n\t  // Finds the Ancestor of the specified topic or undefined\n\t  function isAncestorTopic (topic, node) {\n\t    var nodeTopic = getTopic(node);\n\t\n\t    return topic === nodeTopic\n\t      || startsWith(topic, nodeTopic + '.')\n\t      || nodeTopic === '';\n\t  }\n\t\n\t  // Given a fingerArray, return the order of current item\n\t  function getFingerArrayOrder (fingerArray) {\n\t    var item = getPointedFinger(fingerArray);\n\t    return item !== SYMBOL_NOTHING ? getOrder(item) : Infinity;\n\t  }\n\t\n\t  // Given a fingerArray, return the priority of current item\n\t  function getFingerArrayPriority (fingerArray) {\n\t    var item = getPointedFinger(fingerArray);\n\t    return item !== SYMBOL_NOTHING ? getPriority(item) : Infinity;\n\t  }\n\t\n\t  // Extracts the topic name from the provided node\n\t  function getTopic (node) {\n\t    return node.topic;\n\t  }\n\t\n\t  // Gets the order property from a persisted subscription\n\t  function getOrder (persistedSubscription) {\n\t    return persistedSubscription.order;\n\t  }\n\t\n\t  // Retrieves the persisted messages from a topic\n\t  function getPersisted (node) {\n\t    return node.persisted;\n\t  }\n\t\n\t  // Retrieves the id of an object\n\t  function getId (obj) {\n\t    return obj.id;\n\t  }\n\t\n\t  // Extracts the priority from a subscription\n\t  function getPriority (subscription) {\n\t    return subscription.priority;\n\t  }\n\t\n\t  // Produces the subscriptions from the provided node\n\t  function getSubscriptions (node) {\n\t    return node.subscriptions;\n\t  }\n\t\n\t  // Suspends all subscribers to a topic\n\t  function unsuspendTopic (prop, node) {\n\t    return map(unsuspendNode, node[prop]);\n\t  }\n\t\n\t  // Sets the suspend property to false\n\t  function unsuspendNode (node) {\n\t    node.suspended = false;\n\t    return node;\n\t  }\n\t\n\t  // Suspends all subscribers to a topic\n\t  function suspendTopic (prop, node) {\n\t    return map(suspendNode, node[prop]);\n\t  }\n\t\n\t  // Sets the suspend property to false\n\t  function suspendNode (node) {\n\t    node.suspended = true;\n\t    return node;\n\t  }\n\t\n\t  // Creates a resolver object that keeps track of promise related values\n\t  function createResolver () {\n\t    var\n\t      resolver = {\n\t        settled: false,\n\t        fulfilledValues: [],\n\t        rejectedValues: []\n\t      },\n\t      promise = new Promise(function promiseResolver (fulfill, reject) {\n\t        resolver.fulfill = fulfill;\n\t        resolver.reject = reject;\n\t      });\n\t\n\t    promise.fulfilled = 0;\n\t    promise.rejected = 0;\n\t    promise.pending = 0;\n\t    resolver.promise = promise;\n\t\n\t    return resolver;\n\t  }\n\t\n\t  // Creates a subscription object\n\t  function createSubscription (state, fn, options, context) {\n\t    return {\n\t      id: state.id(),\n\t      fn: typeof fn === 'function' ? fn : noop,\n\t      suspended: false,\n\t      priority: +options.priority || 0,\n\t      context: context || null\n\t    };\n\t  }\n\t\n\t  // Creates an empty node of the tree\n\t  function createNode (topic) {\n\t    return {topic: topic, subscriptions: [], children: [], persisted: []};\n\t  }\n\t\n\t  // *************************************************************************\n\t  //   Private Standard Data Structures Algorithms\n\t  // *************************************************************************\n\t\n\t  // Produces a path down the tree to a leaf of the ancestors of the topic\n\t  function findLineage (getValue, isAncestor, value, tree, path) {\n\t    path = path || [];\n\t\n\t    if (tree && isAncestor(value, tree)) {\n\t      path.push(tree);\n\t\n\t      var // The child is only correct if the children matches the value\n\t        childIndex = binaryIndexBy(getValue, value, tree.children), // exactly,\n\t        foundChild = tree.children[childIndex], // otherwise the index is where\n\t        child = foundChild && getValue(foundChild) === value // it would be\n\t          ? foundChild : tree.children[childIndex - 1]; // (i.e. One too high)\n\t\n\t      return findLineage(getValue, isAncestor, value, child, path);\n\t    }\n\t\n\t    return path;\n\t  }\n\t\n\t  // Searches a tree for the provided topic. If it cannot find\n\t  // a node with the topic, it returns the closest ancestor.\n\t  // `getValue(node) === value` means that the exact node was found\n\t  function ancestorSearch (getValue, value, isAncestor, tree) {\n\t    if (getValue(tree) === value) {\n\t      return tree;\n\t    }\n\t\n\t    var index = binaryIndexBy(getValue, value, tree.children);\n\t    var child1 = tree.children[index];\n\t    var child0 = tree.children[index - 1];\n\t\n\t    if (child1 && isAncestor(value, child1)) {\n\t      return ancestorSearch(getValue, value, isAncestor, child1);\n\t    }\n\t\n\t    if (child0 && isAncestor(value, child0)) {\n\t      return ancestorSearch(getValue, value, isAncestor, child0);\n\t    }\n\t\n\t    return tree;\n\t  }\n\t\n\t  // Produces an array of all the descendants of a node including itself. This\n\t  // means all children, grandchildren, great-grandchildren, etc...\n\t  function descendents (node) {\n\t    return reduce(appendDescendents, [node], node.children);\n\t  }\n\t\n\t  // Appends the descnedents of `next` to the array.\n\t  function appendDescendents (arr, next) {\n\t    return arr.concat(descendents(next));\n\t  }\n\t\n\t  // Each element of `line` is a node to add as a child to the previous\n\t  // element of `line` starting with `tree`\n\t  function addFamilyLine (addChildToTree, line, tree) {\n\t    return reduce(addChildToTree, tree, line);\n\t  }\n\t\n\t  // Adds a node child into the tree in order according to `getValue`\n\t  function addChild (getValue, newChild, tree) {\n\t    tree.children.splice(\n\t      binaryIndexBy(getValue, getValue(newChild), tree.children),\n\t      0, newChild\n\t    );\n\t\n\t    return newChild;\n\t  }\n\t\n\t  // In merge sort, two sorted array are combined to create a new sorted array\n\t  // with the contents of both. This is a generalization of 'merge' to n\n\t  // arrays and based on a computed function. O(n).\n\t  function mergeBy (getItemOrder, arrays) {\n\t    var\n\t      n = reduce(add, 0, map(getLength, arrays)),\n\t      result = new Array(n),\n\t      fingerArrays = map(mkFingerArray, arrays),\n\t\n\t      i, min;\n\t\n\t    for (i = 0; i < n; i++) {\n\t      min = minBy(getItemOrder, fingerArrays);\n\t\n\t      result[i] = getPointedFinger(min);\n\t      min.pointer += 1;\n\t    }\n\t\n\t    return result;\n\t  }\n\t\n\t  // Inserts an item in ascending order according to `getValue`.\n\t  function insert (getValue, item, list) {\n\t    var index = binaryIndexBy(getValue, getValue(item), list);\n\t\n\t    list.splice(index, 0, item);\n\t    return item;\n\t  }\n\t\n\t  // Searches all elements around `i` in `arr` that statisfy\n\t  // `conditionValue(elem) === conditionValue`. This will return and index\n\t  // such that `getValue(arr[i]) === value` or -1 if none can be found.\n\t  function searchAround (\n\t    getValue, getConditionValue, value, conditionValue, i, arr\n\t  ) {\n\t    var start = i;\n\t    var elm = arr[i];\n\t\n\t    while (elm && (\n\t      getValue(elm) !== value || getConditionValue(elm) !== conditionValue)\n\t    ) {\n\t      elm = arr[--i];\n\t    }\n\t\n\t    if (!elm || getValue(elm) !== value) {\n\t      i = Math.min(arr.length, start + 1);\n\t      elm = arr[i];\n\t    }\n\t\n\t    while (elm && (\n\t      getValue(elm) !== value || getConditionValue(elm) !== conditionValue)\n\t    ) {\n\t      elm = arr[++i];\n\t    }\n\t\n\t    if (!elm || getValue(elm) !== value) {\n\t      return -1;\n\t    }\n\t\n\t    return i;\n\t  }\n\t\n\t  // Locates an index to insert `item` that would keep `arr` sorted. This\n\t  // uses a binary search and has a worst and average case performance of\n\t  // O(lg n).\n\t  function binaryIndexBy (getValue, item, array) {\n\t    var\n\t      value = item,\n\t      low = 0,\n\t      high = array.length,\n\t      mid, elem;\n\t\n\t    while (low < high) {\n\t      // divide by two and floor\n\t      mid = low + high >>> 1;\n\t      elem = getValue(array[mid]);\n\t\n\t      if (elem < value) {\n\t        low = mid + 1;\n\t      } else {\n\t        high = mid;\n\t      }\n\t    }\n\t\n\t    return high;\n\t  }\n\t\n\t  // Finds the `minimum` element of an array according to the `valueComputer`\n\t  // function.\n\t  function minBy (valueComputer, list) {\n\t    var\n\t      idx = 0,\n\t      winner = list[idx],\n\t      computedWinner = valueComputer(winner),\n\t\n\t      computedCurrent;\n\t\n\t    while (++idx < list.length) {\n\t      computedCurrent = valueComputer(list[idx]);\n\t\n\t      if (computedCurrent < computedWinner) {\n\t        computedWinner = computedCurrent;\n\t        winner = list[idx];\n\t      }\n\t    }\n\t\n\t    return winner;\n\t  }\n\t\n\t  // Retrieves the element that is the current focus and apply a\n\t  function getPointedFinger (fArray) {\n\t    var\n\t      pointer = fArray.pointer,\n\t      array = fArray.array;\n\t\n\t    return array.length > pointer ? array[pointer] : SYMBOL_NOTHING;\n\t  }\n\t\n\t  // A finger list is a list with an additional pointer to an element.\n\t  function mkFingerArray (array) {\n\t    return {\n\t      pointer: 0,\n\t      array: array\n\t    };\n\t  }\n\t\n\t  // Creates a function that always returns a unique number\n\t  function mkGenerator () {\n\t    var i = -9007199254740992;\n\t    return function generator () {\n\t      return i++;\n\t    };\n\t  }\n\t\n\t  // Removes all elements of `node[property]`.\n\t  function empty (property, node) {\n\t    node[property].length = 0;\n\t    return node;\n\t  }\n\t\n\t  // A poor-mans ES6 Symbol. Comparing to this by reference to check for\n\t  // `Nothing` since `undefined` and `null` are valid values.\n\t  function SYMBOL_NOTHING () {}\n\t\n\t  // *************************************************************************\n\t  //   Private Utility Functions\n\t  // *************************************************************************\n\t\n\t  // Executes a function with the specified arguments asynchronously.\n\t  function async (f, args) {\n\t    new Promise(invoke).then(function asyncFulfill () {\n\t      return f.apply(null, args);\n\t    });\n\t  }\n\t\n\t  // Partially applies 1 argument to a function.\n\t  function partial1 (f, x) {\n\t    return function partiallyApplied1 () {\n\t      // Using slice or splice on `arguments` causes the function to be\n\t      // unoptimizable. Who doesn't like optimization?\n\t      var args = map(identity, arguments);\n\t\n\t      args.unshift(x);\n\t      return f.apply(null, args);\n\t    };\n\t  }\n\t\n\t  // Returns a new object will all the properties of `a` and `b` giving\n\t  // b the priority.\n\t  function merge (a, b) {\n\t    var result = {};\n\t    var x;\n\t\n\t    for (x in a) {\n\t      if (a.hasOwnProperty(x)) {\n\t        result[x] = a[x];\n\t      }\n\t    }\n\t\n\t    for (x in b) {\n\t      if (b.hasOwnProperty(x)) {\n\t        result[x] = b[x];\n\t      }\n\t    }\n\t\n\t    return result;\n\t  }\n\t\n\t  // Array.prototype.reduce has similar performance to Array.prototype.map, so\n\t  // we define a custom reduce function to increase performance\n\t  function reduce (f, seed, arr) {\n\t    var result = seed, i, n;\n\t    for (i = 0, n = arr.length; i < n; i++) {\n\t      result = f(result, arr[i]);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  // A special version of map to get around the performance hit for creating\n\t  // closures as a form of currying\n\t  function curryMap (args, f, arr) {\n\t    var result = [], i, n;\n\t    for (i = 0, n = arr.length; i < n; i++) {\n\t      result.push(f(args, arr[i]));\n\t    }\n\t    return result;\n\t  }\n\t\n\t  // Array.prototype.map is supeeeeer slow. In fact, it is slower than a\n\t  // custom map function, which is usually slower than an inline for loop, but\n\t  // is more maintainable.\n\t  function map (f, arr) {\n\t    var result = [], i, n;\n\t    for (i = 0, n = arr.length; i < n; i++) {\n\t      result.push(f(arr[i]));\n\t    }\n\t    return result;\n\t  }\n\t\n\t  // Determines whether a string begins with the characters of another string,\n\t  // returning true or false as appropriate.\n\t  function startsWith (haystack, needle, startPosition) {\n\t    startPosition = startPosition || 0;\n\t    return haystack.lastIndexOf(needle, startPosition) === startPosition;\n\t  }\n\t\n\t  // Invokes the first argument as a function without any arguments. Useful\n\t  // for resolving promises immediately.\n\t  function invoke (f) {\n\t    f();\n\t  }\n\t\n\t  // Gets the length of arrays and array-like objects.\n\t  function getLength (x) {\n\t    return x.length;\n\t  }\n\t\n\t  // \"Simple\" JavaScript addition ;-)\n\t  function add (x, y) {\n\t    return x + y;\n\t  }\n\t\n\t  // The only automorphism that is its own isomorphism\n\t  function identity (x) {\n\t    return x;\n\t  }\n\t\n\t  // This does nothing\n\t  function noop () {\n\t  }\n\t\n\t  // Throws an error if value !=== expected. This is useful for input\n\t  // validation.\n\t  function assert (value, expected, method, type, identifier) {\n\t    if (value !== expected) {\n\t      throw new Error(method + ' only accepts ' + type + ' as ' + identifier);\n\t    }\n\t  }\n\t}));\n\t\n\n\n/***/ },\n/* 3 */\n/*!************************!*\\\n  !*** ./store/index.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\tvar WatchJS = __webpack_require__(/*! watchjs */ 22);\n\tvar watch = WatchJS.watch;\n\tvar unwatch = WatchJS.unwatch;\n\t\n\tArbiter.subscribe('mutations', function (payload) {\n\t  var mutation = payload['mutation'];\n\t  var value = payload['value'];\n\t  console.log(mutation, mutations[mutation]);\n\t  mutations[mutation](value);\n\t});\n\t\n\tvar guid = function guid() {\n\t  function s4() {\n\t    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t  }\n\t  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n\t};\n\t\n\tvar store = {\n\t  profile: { 'username': null },\n\t  modals: {\n\t    'registration': {\n\t      'name': 'registration',\n\t      'title': 'Create your account',\n\t      'content': 'store.forms.registration',\n\t      'buttons': [{\n\t        'name': 'Submit',\n\t        'action': 'submit_registration',\n\t        'color': 'blue',\n\t        'state': 'pristine'\n\t      }, {\n\t        'name': 'Cancel',\n\t        'action': 'deactive_registration',\n\t        'color': 'red',\n\t        'state': 'pristine'\n\t      }],\n\t      'state': 'inactive'\n\t    },\n\t    'login': {\n\t      'name': 'login',\n\t      'title': 'Login to your account',\n\t      'content': 'store.forms.login',\n\t      'buttons': [{\n\t        'name': 'Submit',\n\t        'action': 'submit_login',\n\t        'color': 'blue',\n\t        'state': 'pristine'\n\t      }, {\n\t        'name': 'Cancel',\n\t        'action': 'deactive_login',\n\t        'color': 'red',\n\t        'state': 'pristine'\n\t      }],\n\t      'state': 'inactive'\n\t    }\n\t  },\n\t  forms: {\n\t    'registration': {\n\t      'title': 'Create your account',\n\t      'name': 'registration',\n\t      'fields': [{\n\t        'label': 'First Name',\n\t        'name': 'firstname',\n\t        'input_type': 'text',\n\t        'placeholder': 'Enter your first name',\n\t        'valid': true,\n\t        'pristine': true,\n\t        'error': null,\n\t        'value': null\n\t      }, {\n\t        'label': 'Last Name',\n\t        'name': 'lastname',\n\t        'input_type': 'text',\n\t        'placeholder': 'Enter your last name',\n\t        'valid': true,\n\t        'pristine': true,\n\t        'error': null,\n\t        'value': null\n\t      }, {\n\t        'label': 'Username',\n\t        'name': 'username',\n\t        'input_type': 'text',\n\t        'placeholder': 'Enter a username for this account',\n\t        'valid': true,\n\t        'pristine': true,\n\t        'error': null,\n\t        'value': null\n\t      }, {\n\t        'label': 'Password',\n\t        'name': 'password',\n\t        'input_type': 'password',\n\t        'placeholder': 'Enter your password',\n\t        'valid': true,\n\t        'pristine': true,\n\t        'error': null,\n\t        'value': null\n\t      }, {\n\t        'label': 'Confirm password',\n\t        'name': 'confirm_password',\n\t        'input_type': 'password',\n\t        'placeholder': 'Confirm your password',\n\t        'valid': true,\n\t        'pristine': true,\n\t        'error': null,\n\t        'value': null\n\t      }, {\n\t        'label': 'Mobile',\n\t        'name': 'mobile',\n\t        'input_type': 'text',\n\t        'placeholder': 'Enter your mobile number',\n\t        'valid': true,\n\t        'pristine': true,\n\t        'error': null,\n\t        'value': null\n\t      }, {\n\t        'label': 'Email',\n\t        'name': 'email',\n\t        'input_type': 'email',\n\t        'placeholder': 'Enter your email address',\n\t        'valid': true,\n\t        'pristine': true,\n\t        'error': null,\n\t        'value': null\n\t      }],\n\t      'action': 'submit_registration',\n\t      'state': 'pristine'\n\t    },\n\t    'login': {\n\t      'title': 'Login to your account',\n\t      'name': 'login',\n\t      'fields': [{\n\t        'label': 'Username',\n\t        'name': 'username',\n\t        'input_type': 'text',\n\t        'placeholder': 'Enter your username',\n\t        'valid': true,\n\t        'pristine': true,\n\t        'error': null,\n\t        'value': null\n\t      }, {\n\t        'label': 'Password',\n\t        'name': 'password',\n\t        'input_type': 'password',\n\t        'placeholder': 'Enter your password',\n\t        'valid': true,\n\t        'pristine': true,\n\t        'error': null,\n\t        'value': null\n\t      }],\n\t      'action': 'submit_login',\n\t      'state': 'pristine'\n\t    }\n\t  },\n\t  registration_flow: {\n\t    'registration_submitted': false,\n\t    'registration_sent_remote': false,\n\t    'registration_failed': { 'status': false, 'message': null },\n\t    'registration_succeeded': false\n\t  },\n\t  authentication_flow: {\n\t    'login_submitted': false,\n\t    'login_sent_remote': false,\n\t    'login_failed': { 'status': false, 'message': null },\n\t    'login_succeeded': false\n\t  },\n\t  macaroon: null,\n\t  remote_requests: [],\n\t  credentials: {\n\t    'username': null,\n\t    'password': null\n\t  },\n\t  authenticated: false,\n\t  route: '/',\n\t  routes: {},\n\t  startup_selected_or_created: 'selected'\n\t};\n\t\n\texports.store = store;\n\t\n\tvar mutations = {\n\t  change_registration_state: function change_registration_state(value) {\n\t    console.log('mutations---> change_registration_state', value);\n\t    var new_state = value['state'];\n\t    store.registration_flow[new_state] = true;\n\t    if (new_state == 'registration_submitted') {\n\t      store.registration_flow['registration_submitted'] = true;\n\t    }\n\t    if (new_state == 'registration_succeeded') {\n\t      store.registration_flow['registration_succeeded'] = true;\n\t    }\n\t    if (new_state == 'registration_failed') {\n\t      store.registration_flow['registration_failed'] = { 'status': true, 'message': value['value']['message'] };\n\t    }\n\t  },\n\t  update_modal_state: function update_modal_state(value) {\n\t    var modal_name = value['value']['modal_name'];\n\t    console.log('mutations---> change', modal_name, store.modals[modal_name]);\n\t    // if (modal_name=='registration'){\n\t    store.modals[modal_name].state = value['value']['modal_state'];\n\t    // }\n\t  },\n\t  change_form_state: function change_form_state(value) {},\n\t  update_form: function update_form(value) {\n\t    console.log('mutations---> update_form', value['value']);\n\t    var payload = value['value'];\n\t    var form = store.forms[payload['form']];\n\t    console.log(store.forms[payload['form']]);\n\t    for (var i = 0; i < form.fields.length; i++) {\n\t      if (form.fields[i].name == payload['field']) {\n\t        console.log('found a field match', form.fields[i]);\n\t        form.fields[i]['value'] = payload['value'];\n\t      }\n\t    };\n\t    console.log(form);\n\t  },\n\t  change_login_state: function change_login_state(value) {\n\t    console.log('mutations---> change_login_state', value);\n\t    var new_state = value['state'];\n\t    store.authentication_flow[new_state] = true;\n\t    if (new_state == 'login_submitted') {\n\t      store.credentials['username'] = value['credentials']['username'];\n\t      store.credentials['password'] = value['credentials']['password'];\n\t    }\n\t    if (new_state == 'login_succeeded') {\n\t      store.profile.username = value['value']['username'];\n\t    }\n\t    if (new_state == 'login_failed') {\n\t      console.log('FAILLLLLLLEEEEEDDDDDDD', value['value']);\n\t      store.authentication_flow['login_failed'] = { 'status': true, 'message': value['value']['message'] };\n\t    }\n\t  },\n\t  update_macaroon: function update_macaroon(value) {\n\t    store.macaroon = value['value'];\n\t  },\n\t  change_route: function change_route(value) {\n\t    console.log('mutations---> change route');\n\t    store.route = value['route'];\n\t  },\n\t  set_selected_or_created: function set_selected_or_created(value) {\n\t    store.startup_selected_or_created = value;\n\t  },\n\t  add_job_id: function add_job_id(payload) {\n\t    console.log('mutations---> add_job_id', payload);\n\t    var job_id = payload.value.job_id;\n\t    var request_id = payload.value.request_id;\n\t    console.log(store.remote_requests, request_id);\n\t    for (var n = 0; n < store.remote_requests.length; n++) {\n\t      if (store.remote_requests[n]['request_id'] == request_id) {\n\t        console.log(request_id, 'matched');\n\t        var obj = {};\n\t        obj.request_id = request_id;\n\t        obj.job_id = job_id;\n\t        obj.status = 'pending';\n\t        obj.action = store.remote_requests[n]['action'];\n\t        obj.success = store.remote_requests[n]['success'];\n\t        obj.failed = store.remote_requests[n]['failed'];\n\t        // store.remote_requests[n] = obj;\n\t        store.remote_requests.splice(n, 1);\n\t        console.log('deleted---->', store.remote_requests);\n\t        store.remote_requests.push(obj);\n\t\n\t        console.log('add_job_id---->', store.remote_requests);\n\t      }\n\t    }\n\t  },\n\t  created_job_request: function created_job_request(payload) {\n\t    console.log('payload', payload);\n\t    var action = payload.state;\n\t    var success = payload.value.success;\n\t    var failed = payload.value.failed;\n\t    console.log(success, failed);\n\t    // new_request_id = generates a new id for the request\n\t    var uuid = guid();\n\t\n\t    var obj = {};\n\t    obj.request_id = uuid;\n\t    obj.status = 'blank';\n\t    obj.payload = payload.value.payload;\n\t    obj.success = success;\n\t    obj.failed = failed;\n\t    obj.action = action;\n\t    console.log(obj);\n\t    store.remote_requests.push(obj);\n\t\n\t    console.log('remote_requests---->', store.remote_requests);\n\t  },\n\t\n\t  set_job_as_fulfilled: function set_job_as_fulfilled(payload) {\n\t    console.log('fulfilled', payload.value);\n\t    var job_id = payload.value.job_id;\n\t    for (var n = 0; n < store.remote_requests.length; n++) {\n\t      if (store.remote_requests[n]['job_id'] == job_id) {\n\t\n\t        var obj = {};\n\t        obj.request_id = payload.value.request_id;\n\t        obj.job_id = job_id;\n\t        obj.status = 'done';\n\t        obj.message = payload.value.message;\n\t        obj.status_code = payload.value.status_code;\n\t        obj.payload = payload.value.payload;\n\t        obj.action = store.remote_requests[n]['action'];\n\t        obj.success = store.remote_requests[n]['success'];\n\t        obj.failed = store.remote_requests[n]['failed'];\n\t\n\t        store.remote_requests.splice(n, 1);\n\t        console.log('deleted---->', store.remote_requests);\n\t        store.remote_requests.push(obj);\n\t        console.log('job fulfilled ---->', store.remote_requests);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\twatch(store, 'registration_flow', function (prop, action, newvalue, oldvalue) {\n\t  console.log(prop, action, newvalue, oldvalue);\n\t  if (prop == 'registration_submitted') {\n\t    Arbiter.publish('registration_flow', { 'prop': prop, 'oldvalue': oldvalue, 'newvalue': newvalue, 'registration_credentials': store['credentials'] });\n\t  } else {\n\t    Arbiter.publish('registration_flow', { 'prop': prop, 'oldvalue': oldvalue, 'newvalue': newvalue });\n\t  }\n\t});\n\t\n\twatch(store, 'authentication_flow', function (prop, action, newvalue, oldvalue) {\n\t  console.log(prop, action, newvalue, oldvalue);\n\t  if (prop == 'login_submitted') {\n\t    Arbiter.publish('authentication_flow', { 'prop': prop, 'oldvalue': oldvalue, 'newvalue': newvalue, 'login_credentials': store['credentials'] });\n\t  } else {\n\t    Arbiter.publish('authentication_flow', { 'prop': prop, 'oldvalue': oldvalue, 'newvalue': newvalue });\n\t  }\n\t});\n\t\n\twatch(store, 'profile', function (prop, action, newvalue, oldvalue) {\n\t  console.log('profile watch--->', prop, action, newvalue, oldvalue);\n\t  Arbiter.publish('profile', { 'prop': prop, 'oldvalue': oldvalue, 'newvalue': newvalue });\n\t});\n\t\n\twatch(store.modals.login, function (prop, action, newvalue, oldvalue) {\n\t  console.log('login modal watch--->', prop, action, newvalue, oldvalue);\n\t  if (newvalue == 'active') {\n\t    Arbiter.publish('activate_login_modal', { 'oldvalue': oldvalue, 'newvalue': newvalue });\n\t  }\n\t  if (newvalue == 'inactive') {\n\t    Arbiter.publish('deactivate_login_modal', { 'oldvalue': oldvalue, 'newvalue': newvalue });\n\t  }\n\t}, 2);\n\t\n\twatch(store.modals.registration, function (prop, action, newvalue, oldvalue) {\n\t  console.log('registration modal watch--->', prop, action, newvalue, oldvalue);\n\t  if (newvalue == 'active') {\n\t    Arbiter.publish('activate_registration_modal', { 'oldvalue': oldvalue, 'newvalue': newvalue });\n\t  }\n\t  if (newvalue == 'inactive') {\n\t    Arbiter.publish('deactivate_registration_modal', { 'oldvalue': oldvalue, 'newvalue': newvalue });\n\t  }\n\t}, 2);\n\t\n\twatch(store, 'macaroon', function (prop, action, newvalue, oldvalue) {\n\t  console.log('macaroon watch--->', prop, action, newvalue, oldvalue);\n\t  Arbiter.publish('macaroon', { 'prop': prop, 'oldvalue': oldvalue, 'newvalue': newvalue });\n\t});\n\t\n\twatch(store, 'remote_requests', function (prop, action, newvalue, oldvalue) {\n\t  console.log('remote requests watch--->', prop, action, newvalue, oldvalue);\n\t  Arbiter.publish('remote_requests', { 'prop': prop, 'oldvalue': oldvalue, 'newvalue': newvalue[0] });\n\t});\n\t\n\twatch(store, 'jobs', function (prop, action, newvalue, oldvalue) {\n\t  console.log('watch', prop, action, newvalue, oldvalue);\n\t  Arbiter.publish('jobs', { 'prop': prop, 'oldvalue': oldvalue, 'newvalue': newvalue });\n\t});\n\t\n\twatch(store, 'fulfilled_jobs', function (prop, action, newvalue, oldvalue) {\n\t  console.log(prop, action, newvalue, oldvalue);\n\t  Arbiter.publish('fulfilled_jobs', { 'prop': prop, 'oldvalue': oldvalue, 'newvalue': newvalue });\n\t});\n\n/***/ },\n/* 4 */\n/*!**************************************!*\\\n  !*** ./components/anon_homepage.tag ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {\"use strict\";\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\tvar Store = __webpack_require__(/*! ../store/index.js */ 3);\n\t\n\triot.tag2('anon_homepage', '<topnav></topnav> <div class=\"ui two column centered grid container\"> <div class=\"column\"> <div class=\"ui basic segment\"> <signuporsignin></signuporsignin> </div> </div> </div> <modal data=\"{login_modal}\" content=\"{login_form}\"> <tsform data=\"{data}\" content=\"{content}\"></tsform> </modal> <modal data=\"{registration_modal}\"></modal>', '', '', function (opts) {\n\t\n\t  var self = this;\n\t\n\t  this.on(\"update\", function () {\n\t\n\t    self.login_form = Store.store.forms.login;\n\t    console.log(\"loginform\", self.login_form);\n\t    self.login_modal = Store.store.modals.login;\n\t    self.registration_modal = Store.store.modals.registration;\n\t    console.log(\"anon_homepage----\", this.registration_modal);\n\t  });\n\t\n\t  this.on('mount', function () {\n\t    // this.registration_modal = Store.store.modals.registration;\n\t    // console.log(\"MODAL\", Store.store.modals.registration);\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 5 */\n/*!****************************!*\\\n  !*** ./components/app.tag ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('app', '<router></router> <control></control> <job></job> <poller></poller>', '', '', function (opts) {});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 6 */\n/*!********************************!*\\\n  !*** ./components/control.tag ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\triot.tag2('control', '', '', '', function (opts) {\n\t\n\t  Arbiter.subscribe('authentication_flow', function (value) {\n\t    var prop = value['prop'];\n\t    console.log('control tag --->', value);\n\t    if (prop == 'login_submitted') {\n\t      var login_credentials = value['login_credentials'];\n\t      var value = value['newvalue'];\n\t      console.log('login_credentials', login_credentials);\n\t      Arbiter.publish('actions', { 'action': 'submit_login_remote', 'value': { 'payload': login_credentials, 'success': 'login_succeeded', 'failed': 'login_failed' } });\n\t    }\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 7 */\n/*!**************************************!*\\\n  !*** ./components/drafteditpage.tag ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('drafteditpage', '<div class=\"ui container\"> <div class=\"{row:true, hide:data.view==\\'investor\\'||data.steps.display==false, show:data.view==\\'founder\\'&&data.steps.display==true}\"> <div class=\"{ui:true, text:true, small:true, grey:data.menutheme.color==\\'grey\\', teal:data.menutheme==\\'teal\\', blue:data.menutheme.color==\\'blue\\', red:data.menutheme==\\'red\\', inverted:data.menutheme.inverted, right:true, menu:true, show:steps.display, hide:steps.display==false}\"> <div class=\"right menu\"> <div class=\"item\"> <div class=\"ui small basic button\">Back</div> </div> <div class=\"item\"> <div class=\"ui small {data.menutheme.color} button\">Done</div> </div> </div> </div> <div class=\"{ui:true, four:true, column:true, grid:true}\"> <div class=\"{five:true, wide:true, column:true, show:data.steps.display, hide:data.steps.display==false}\"> <step steps=\"{data.steps.items}\" vertical=\"{data.steps.vertical}\"></step> </div> <div class=\"{eleven:data.steps.display==true, wide:true, column:true}\"> <div class=\"{ui:true, column:true, grid:true, show:data.active_step==\\'startup\\', hide:data.active_step!=\\'startup\\'}\"> <div class=\"column\"> <div class=\"ui segment\"> <div class=\"row\"> <startup></startup> </div> </div> </div> </div> <div class=\"{ui:true, column:true, grid:false, show:data.active_step==\\'tractionedit\\', hide:data.active_step!=\\'tractionedit\\'}\"> <div class=\"column\"> <tractionedit data=\"{data}\"></tractionedit> </div> </div> <div class=\"{ui:true, column:true, grid:true, show:data.active_step==\\'team\\', hide:data.active_step!=\\'team\\'}\"> <div class=\"column\"> <team></team> </div> </div> <div class=\"{ui:true, column:true, grid:true, show:data.active_step==\\'commercials\\', hide:data.active_step!=\\'commercials\\'}\"> <div class=\"column\"> <commercials></commercials> </div> </div> <div class=\"{ui:true, column:true, grid:true, show:data.active_step==\\'share\\', hide:data.active_step!=\\'share\\'}\"> <div class=\"column\"> <share data=\"{data}\" share=\"{data.share}\" steps=\"{data.steps}\"></share> </div> </div> <div class=\"{ui:true, text:true, small:true, grey:data.menutheme.color==\\'grey\\', teal:data.menutheme==\\'teal\\', blue:data.menutheme.color==\\'blue\\', red:data.menutheme==\\'red\\', inverted:data.menutheme.inverted, right:true, menu:true, show:steps.display, hide:steps.display==false}\"> <div class=\"right menu\"> <div class=\"item\"> <div class=\"ui small basic button\">Back</div> </div> <div class=\"item\"> <div class=\"ui small {data.menutheme.color} button\">Done</div> </div> </div> </div> </div> </div> </div> </div>', '', '', function (opts) {\n\t\n\t    this.data = {};\n\t\n\t    this.data.dropdownobservable = riot.observable();\n\t\n\t    console.log(opts.data);\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 8 */\n/*!*********************************!*\\\n  !*** ./components/homepage.tag ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\triot.tag2('homepage', '<macaroon></macaroon> <div class=\"{hide:authenticated==false}\"> <loggedin_homepage profile=\"{profile}\"></loggedin_homepage> </div> <div class=\"{hide:authenticated==true}\"> <anon_homepage></anon_homepage> </div>', '', '', function (opts) {\n\t\n\t\tvar self = this;\n\t\n\t\tvar login_failed = false;\n\t\n\t\tvar login_succeeded = false;\n\t\n\t\tthis.authenticated = false;\n\t\n\t\tthis.profile = {};\n\t\n\t\tArbiter.subscribe('authentication_flow', function (value) {\n\t\t\tself.update(value);\n\t\t});\n\t\n\t\tArbiter.subscribe('authentication_flow', function (value) {\n\t\t\tvar prop = value['prop'];\n\t\t\tconsole.log('control tag --->', value);\n\t\t\tif (prop == 'login_succeeded') {\n\t\t\t\tself.authenticated = true;\n\t\t\t\tself.update();\n\t\t\t}\n\t\t});\n\t\n\t\tArbiter.subscribe('profile', function (value) {\n\t\t\tvar prop = value['prop'];\n\t\t\tconsole.log('control tag --->', value);\n\t\t\tif (prop == 'username') {\n\t\t\t\tself.profile.username = value['newvalue'];\n\t\t\t\tself.update();\n\t\t\t}\n\t\t});\n\t\n\t\tthis.on('update', function (value) {\n\t\t\tif (value == undefined) {} else {\n\t\t\t\tvar authentication_flow = value;\n\t\t\t\tvar succeeded_or_failed = false;\n\t\t\t\tif (authentication_flow['login_failed']) {\n\t\t\t\t\tsucceeded_or_failed = true;\n\t\t\t\t}\n\t\t\t\tif (authentication_flow['login_submitted'] == true && succeeded_or_failed == false) {\n\t\t\t\t\tself.loading = true;\n\t\t\t\t} else {\n\t\t\t\t\tself.loading = false;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 9 */\n/*!****************************!*\\\n  !*** ./components/job.tag ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\tvar guid = function guid() {\n\t\tfunction s4() {\n\t\t\treturn Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t\t}\n\t\treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n\t};\n\t\n\triot.tag2('job', '', '', '', function (opts) {\n\t\n\t\tvar self = this;\n\t\n\t\tself.uuid = guid();\n\t\n\t\tself.remote_requests = [];\n\t\n\t\tself.macaroon = null;\n\t\n\t\tself.api = {\n\t\t\t'submit_login_remote': { 'type': 'POST', 'url': 'http://api.termsheet.io/login/' }\n\t\t};\n\t\n\t\tArbiter.subscribe('remote_requests', function (value, store) {\n\t\n\t\t\tvar new_job_id = null;\n\t\n\t\t\tconsole.log(store, value['newvalue']);\n\t\n\t\t\tif (value['newvalue']['status'] == 'blank') {\n\t\t\t\tvar request_id = value['newvalue']['request_id'];\n\t\t\t\t// get the latest job requests from the remote_request store\n\t\n\t\t\t\tvar payload = value['newvalue']['payload'];\n\t\t\t\tconsole.log('action', value['newvalue']['action'], 'payload', payload);\n\t\t\t\tself.remote_requests.push(request_id);\n\t\t\t\tconsole.log(self.api[value['newvalue']['action']]);\n\t\t\t\t// send the remote request to the server\n\t\t\t\t$.ajax({\n\t\t\t\t\ttype: self.api[value['newvalue']['action']]['type'],\n\t\t\t\t\turl: self.api[value['newvalue']['action']]['url'],\n\t\t\t\t\tdataType: 'json',\n\t\t\t\t\tcontentType: 'application/json',\n\t\t\t\t\tasync: true,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Authorization\": self.macaroon\n\t\t\t\t\t},\n\t\t\t\t\tdata: JSON.stringify(payload),\n\t\t\t\t\tsuccess: function success(data) {\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t\tnew_job_id = data['job_id'];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// get back a job id\n\t\t\t\t// var new_job_id = guid()\n\t\n\t\t\t\t// update store with the job id\n\t\t\t\tArbiter.publish('actions', { 'action': 'add_job_id', 'value': { 'job_id': new_job_id, 'request_id': request_id } });\n\t\t\t}\n\t\n\t\t\tif (value['newvalue']['status'] == 'done') {\n\t\t\t\tvar success = false;\n\t\t\t\tif (value['newvalue']['status_code'] == 200) {\n\t\t\t\t\tsuccess = true;\n\t\t\t\t}\n\t\t\t\tif (success == true) {\n\t\t\t\t\tvar event = value['newvalue']['success'];\n\t\t\t\t} else {\n\t\t\t\t\tvar event = value['newvalue']['failed'];\n\t\t\t\t}\n\t\n\t\t\t\tArbiter.publish('actions', { 'action': event, 'value': value['newvalue'] });\n\t\t\t}\n\t\t});\n\t\n\t\tArbiter.subscribe('macaroon', function (value) {\n\t\t\tself.macaroon = value['newvalue'];\n\t\t\tconsole.log('macaroon_received', self.macaroon);\n\t\t});\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 10 */\n/*!******************************************!*\\\n  !*** ./components/loggedin_homepage.tag ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('loggedin_homepage', '<div>{profile.username}</div>', '', '', function (opts) {\n\t\n\t\tvar self = this;\n\t\n\t\tthis.profile = opts.profile;\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 11 */\n/*!******************************!*\\\n  !*** ./components/login.tag ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\triot.tag2('login', '<div class=\"ui segment\"> <form class=\"ui form\" id=\"signinForm\" onsubmit=\"{loginUser}\"> <h4 class=\"ui dividing header\">Login</h4> <div> <div class=\"field\"> <label>Username</label> <input type=\"text\" name=\"username\" placeholder=\"username\"> </div> <div class=\"field\"> <label>Password</label> <input type=\"password\" name=\"password\" placeholder=\"password\"> </div> <button __disabled=\"{this.loading}\" class=\"{loading: this.loading, ui: true, primary:true, button: true}\" type=\"submit\" form=\"signinForm\" value=\"Submit\">Login</button> <div class=\"{hide:message==null}\">{message}</div> </div> </form> </div>', '', '', function (opts) {\n\t  var self = this;\n\t\n\t  this.loading = false;\n\t\n\t  this.message = null;\n\t\n\t  this.loginUser = function () {\n\t    console.log(this.username.value);\n\t    console.log('loginUser--->', self.username.value);\n\t    var login_credentials = { username: self.username.value, password: self.password.value };\n\t    // Action is submit_login and store's state is authentication_flow\n\t    Arbiter.publish('actions', { 'action': 'submit_login', 'value': login_credentials });\n\t  };\n\t\n\t  Arbiter.subscribe('authentication_flow', function (value) {\n\t    console.log('login.tag got data--->', value);\n\t    var prop = value['prop'];\n\t    var value = value['newvalue'];\n\t    if (prop == 'login_submitted') {\n\t      self.loading = value;\n\t    }\n\t    if (prop == 'login_succeeded') {\n\t      self.loading = false;\n\t    }\n\t    if (prop == 'login_failed') {\n\t      self.loading = false;\n\t      self.message = value['message'];\n\t    }\n\t    self.update();\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 12 */\n/*!*********************************!*\\\n  !*** ./components/macaroon.tag ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\triot.tag2('macaroon', '', '', '', function (opts) {\n\t\n\t\tvar self = this;\n\t\n\t\tthis.on('mount', function () {\n\t\n\t\t\t$.get('http://api.termsheet.io/get_anonymous_token/', function (value) {\n\t\t\t\tconsole.log(value);\n\t\t\t\tArbiter.publish('actions', { 'action': 'macaroon_received', 'value': value['Authorization'] });\n\t\t\t});\n\t\t});\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 13 */\n/*!******************************!*\\\n  !*** ./components/modal.tag ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\triot.tag2('modal', '<div id=\"{id}\" class=\"{ui:true, small:true, modal:true}\"> <i onclick=\"{cancelModal}\" class=\"close icon\"></i> <div class=\"header\"> {data.title} </div> <div class=\"{image:image_src, content:true}\"> <yield></yield> </div> <div class=\"actions\"> <div each=\"{data.buttons}\" class=\"{ui:true, button:true, blue:color==\\'blue\\', red:color==\\'red\\'}\" onclick=\"{buttonAction(action)}\">{name}</div> </div> </div>', '', '', function (opts) {\n\t\n\t\tvar self = this;\n\t\tthis.content = this.opts.content;\n\t\tthis.data = this.opts.data;\n\t\tthis.small = this.opts.data;\n\t\n\t\tthis.active = false;\n\t\n\t\tvar guid = function guid() {\n\t\t\tfunction s4() {\n\t\t\t\treturn Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t\t\t}\n\t\t\treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n\t\t};\n\t\n\t\tthis.id = guid();\n\t\n\t\tthis.on(\"update\", function () {\n\t\n\t\t\tself.content = self.opts.content;\n\t\t\tself.data = self.opts.data;\n\t\t\tconsole.log('this.content', this.opts);\n\t\n\t\t\tself.name = self.opts.data.name;\n\t\t\tself.title = self.opts.data.title;\n\t\t\tself.image_src = self.opts.data.image_src;\n\t\t\tself.image_description = self.opts.data.image_description;\n\t\t\tself.modal = $('#' + self.id);\n\t\t});\n\t\n\t\tthis.on(\"mount\", function () {\n\t\n\t\t\t// opens the specific modal\n\t\t\tself.modal_name = \"activate_\" + self.name + \"_modal\";\n\t\t\tself.hide_modal_name = \"deactivate_\" + self.name + \"_modal\";\n\t\n\t\t\tArbiter.subscribe(self.modal_name, function () {\n\t\t\t\tconsole.log('show', self.opts.data, self.modal, self.modal_name);\n\t\t\t\t// self.showModal();\n\t\t\t\t// self.update();\n\t\t\t\t$('#' + self.id).modal('show');\n\t\t\t});\n\t\n\t\t\tArbiter.subscribe(self.hide_modal_name, function () {\n\t\t\t\tconsole.log('hide', self.opts.data, self.modal, self.hide_modal_name);\n\t\t\t\t// self.hideModal();\n\t\t\t\t// self.update();\n\t\t\t\t$('#' + self.id).modal('hide');\n\t\t\t});\n\t\t});\n\t\n\t\tthis.cancelModal = function () {\n\t\t\tArbiter.publish('actions', { 'action': 'deactivate_modal', 'value': { 'modal_name': self.name, 'modal_state': 'inactive' } });\n\t\t};\n\t\n\t\tthis.buttonAction = function (action) {\n\t\t\tconsole.log(action);\n\t\t\tArbiter.publish('actions', { 'action': action, 'value': {} });\n\t\t};\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 14 */\n/*!**********************************!*\\\n  !*** ./components/only-logo.tag ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('only-logo', '<img src=\"img/log.png\">', '', '', function (opts) {});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 15 */\n/*!*******************************!*\\\n  !*** ./components/poller.tag ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\triot.tag2('poller', '', '', '', function (opts) {\n\t\n\t\tvar self = this;\n\t\n\t\tself.macaroon = null;\n\t\n\t\tArbiter.subscribe('macaroon', function (value) {\n\t\t\tself.macaroon = value['newvalue'];\n\t\t\tconsole.log('macaroon_received', self.macaroon);\n\t\t\tvar poller = self.startPoller();\n\t\t});\n\t\n\t\tthis.startPoller = function () {\n\t\t\tvar payload = null;\n\t\t\tvar x = setInterval(function () {\n\t\t\t\t$.ajax({\n\t\t\t\t\ttype: 'GET',\n\t\t\t\t\turl: 'http://api.termsheet.io/data.json',\n\t\t\t\t\tdataType: 'json',\n\t\t\t\t\tcontentType: 'application/json',\n\t\t\t\t\tasync: true,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Authorization\": self.macaroon\n\t\t\t\t\t},\n\t\t\t\t\tsuccess: function success(data) {\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t\tif (data.length > 0) {\n\t\n\t\t\t\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\t\t\t\tconsole.log('0------', data[i][Object.keys(data[i])[0]]);\n\t\t\t\t\t\t\t\tvar obj = data[i][Object.keys(data[i])[0]];\n\t\t\t\t\t\t\t\tvar job_id = obj['job_id'];\n\t\t\t\t\t\t\t\tvar status_code = obj['status_code'];\n\t\t\t\t\t\t\t\tvar payload = obj['payload'];\n\t\t\t\t\t\t\t\tvar message = obj['messsage'];\n\t\t\t\t\t\t\t\tconsole.log(job_id, message, payload);\n\t\n\t\t\t\t\t\t\t\tArbiter.publish('actions', { 'action': 'set_job_as_fulfilled', 'value': { 'value': obj } });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, 4000);\n\t\t\treturn x;\n\t\t};\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 16 */\n/*!*******************************!*\\\n  !*** ./components/router.tag ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\triot.tag2('router', '<div id=\"app\"></div>', '', '', function (opts) {\n\t\n\t\tvar self = this;\n\t\n\t\tvar routes = { '/': 'homepage', '/create': 'drafteditpage' };\n\t\tconsole.log('routes--->', routes);\n\t\n\t\tthis.currentPage = null;\n\t\tconsole.log(\"this.currentPage-->\", this.currentPage);\n\t\n\t\tvar goTo = function goTo(page) {\n\t\t\tconsole.log(\"goTo-->\", page, self.currentPage);\n\t\t\tif (self.currentPage) {\n\t\t\t\tconsole.log(\"goTo if self.currentPage-->\", self.currentPage);\n\t\t\t\tself.currentPage.unmount(true); //unmount and keep parent tag\n\t\t\t}\n\t\t\tself.currentPage = riot.mount('#app', page)[0];\n\t\t\tconsole.log(\"goTo mounted this.currentPage-->\", self.currentPage);\n\t\t\t// console.log(self.currentPage); //remember current page\n\t\t};\n\t\n\t\tArbiter.subscribe('route', function (state_value) {\n\t\t\tconsole.log(\"riotux.subscribe-->\", state_value);\n\t\t\tself.update(state_value);\n\t\t});\n\t\n\t\tthis.on('update', function (new_route) {\n\t\t\tconsole.log(\"update-->\");\n\t\t\tvar oldroute = self.route;\n\t\t\tif (new_route == undefined) {\n\t\t\t\tnew_route = '/';\n\t\t\t}\n\t\t\tself.route = new_route;\n\t\t\tconsole.log(\"update self.route-->\", self.route, routes[self.route]);\n\t\t\tgoTo(routes[self.route]);\n\t\t\triot.route(self.route);\n\t\t});\n\t\n\t\tthis.on('mount', function () {\n\t\t\tconsole.log(\"this.on('mount')-->\");\n\t\t\tself.route = '/';\n\t\t\tconsole.log(\"this.on('mount')\", self.currentPage, routes[self.route]);\n\t\t\tgoTo(routes[self.route]);\n\t\t\triot.route.start(true);\n\t\t});\n\t\n\t\tthis.on('unmount', function () {\n\t\t\triot.route.stop();\n\t\t});\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 17 */\n/*!***************************************!*\\\n  !*** ./components/signuporsignin.tag ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\triot.tag2('signuporsignin', '<div class=\"ui two column middle aligned very relaxed stackable padded grid\"> <div class=\"center aligned column\"> <div class=\"ui small blue labeled icon button\" onclick=\"{activeLogin}\"> <i class=\"sign in icon\"></i> Login </div> <div class=\"content\"> <div class=\"description light padding\">Sign in using your Open Account</div> </div> </div> <div class=\"ui vertical divider\"> Or </div> <div class=\"center aligned column\"> <div onclick=\"{registerUser}\" class=\"ui small green labeled icon button\"> <i class=\"signup icon\"></i> Sign Up </div> <div class=\"content\"> <div class=\"description light padding\">Create your Open Account</div> </div> </div> </div>', '', '', function (opts) {\n\t\n\t\tvar self = this;\n\t\n\t\tthis.activeLogin = function () {\n\t\t\tArbiter.publish('actions', { 'action': 'activate_modal', 'value': { 'modal_name': 'login', 'modal_state': 'active' } });\n\t\t};\n\t\tthis.registerUser = function () {\n\t\t\tArbiter.publish('actions', { 'action': 'activate_modal', 'value': { 'modal_name': 'registration', 'modal_state': 'active' } });\n\t\t};\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 18 */\n/*!*******************************!*\\\n  !*** ./components/topnav.tag ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('topnav', '<div class=\"ui container\"> <div class=\"ui text menu\"> <div class=\"item\"> <only-logo></only-logo> </div> </div> </div>', '', '', function (opts) {});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 19 */\n/*!*******************************!*\\\n  !*** ./components/tsform.tag ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {\"use strict\";\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\tvar Store = __webpack_require__(/*! ../store/index.js */ 3);\n\t\n\triot.tag2('tsform', '<div onsubmit=\"{submitForm}\" class=\"ui form\"> <div each=\"{form.fields}\" class=\"required field\"> <label>{label}</label> <input type=\"{input_type}\" name=\"{name}\" onkeyup=\"{updateStoreForm}\" placeholder=\"{placeholder}\"> </div> </div>', '', '', function (opts) {\n\t\n\t\tvar self = this;\n\t\n\t\tthis.submitForm = function () {\n\t\t\tArbiter.publish('actions', { 'action': self.content.action, 'payload': {} });\n\t\t};\n\t\n\t\tthis.updateStoreForm = function (e) {\n\t\t\tself[e.item.name] = e.target.value;\n\t\t\tvar name = self.opts.content.name;\n\t\t\tconsole.log('--------> field', self.opts.content.name, name, e.item.name, 'value', self[e.item.name]);\n\t\t\tArbiter.publish('actions', { 'action': 'update_form', 'value': { 'form': name, 'field': e.item.name, 'value': self[e.item.name] } });\n\t\t};\n\t\n\t\tthis.on(\"update\", function () {\n\t\t\tself.form = self.opts.content;\n\t\t\tconsole.log(\"form\", self.opts, self.content, self.data);\n\t\t});\n\t\n\t\tthis.on(\"mount\", function () {\n\t\t\tself.form = self.opts.formdata;\n\t\t\tconsole.log(\"form\", self.opts, self.content, self.data);\n\t\t});\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 20 */\n/*!**************************!*\\\n  !*** ./actions/index.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Arbiter = __webpack_require__(/*! promissory-arbiter */ 2);\n\t\n\tvar actions = {\n\t  macaroon_received: function macaroon_received(value) {\n\t    Arbiter.publish('mutations', { 'mutation': 'update_macaroon', 'value': { 'state': 'macaroon_received', 'value': value } });\n\t  },\n\t  activate_modal: function activate_modal(value) {\n\t    Arbiter.publish('mutations', { 'mutation': 'update_modal_state', 'value': { 'state': 'modal_activated', 'value': value } });\n\t  },\n\t  deactivate_modal: function deactivate_modal(value) {\n\t    Arbiter.publish('mutations', { 'mutation': 'update_modal_state', 'value': { 'state': 'modal_deactivated', 'value': value } });\n\t  },\n\t  update_form: function update_form(value) {\n\t    Arbiter.publish('mutations', { 'mutation': 'update_form', 'value': { 'state': 'update_form', 'value': value } });\n\t  },\n\t  login_succeeded: function login_succeeded(value) {\n\t    Arbiter.publish('mutations', { 'mutation': 'change_login_state', 'value': { 'state': 'login_succeeded', 'value': value } });\n\t  },\n\t  login_failed: function login_failed(value) {\n\t    Arbiter.publish('mutations', { 'mutation': 'change_login_state', 'value': { 'state': 'login_failed', 'value': value } });\n\t  },\n\t  submit_login: function submit_login(value) {\n\t    Arbiter.publish('mutations', { 'mutation': 'change_login_state', 'value': { 'state': 'login_submitted', 'credentials': value } });\n\t  },\n\t  submit_login_remote: function submit_login_remote(value) {\n\t    Arbiter.publish('mutations', { 'mutation': 'created_job_request', 'value': { 'state': 'submit_login_remote', 'value': value } });\n\t  },\n\t  change_route: function change_route(value) {\n\t    console.log('actions---> change route');\n\t    Arbiter.publish('change_route', value);\n\t  },\n\t  startup_selected_or_created: function startup_selected_or_created(value) {\n\t    Arbiter.publish('set_selected_or_created', value);\n\t  },\n\t  create_job: function create_job(value) {\n\t    Arbiter.publish('mutations', { 'mutation': 'created_job_request', 'value': { 'state': 'created_job_request', 'value': value } });\n\t  },\n\t  set_job_as_fulfilled: function set_job_as_fulfilled(payload) {\n\t    Arbiter.publish('mutations', { 'mutation': 'set_job_as_fulfilled', 'value': { 'state': 'set_job_as_fulfilled', 'value': payload['value'] } });\n\t  },\n\t  add_job_id: function add_job_id(value) {\n\t    Arbiter.publish('mutations', { 'mutation': 'add_job_id', 'value': { 'state': 'jobs', 'value': value } });\n\t  }\n\t};\n\t\n\tArbiter.subscribe('actions', function (value, action) {\n\t  console.log(\"actions--->\", action, \"value----->\", value['action']);\n\t  actions[value['action']](value['value']);\n\t});\n\n/***/ },\n/* 21 */\n/*!*****************!*\\\n  !*** ./main.js ***!\n  \\*****************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar riot = __webpack_require__(/*! riot */ 1);\n\t\n\t__webpack_require__(/*! ./components/router.tag */ 16);\n\t__webpack_require__(/*! ./components/macaroon.tag */ 12);\n\t__webpack_require__(/*! ./components/only-logo.tag */ 14);\n\t__webpack_require__(/*! ./components/topnav.tag */ 18);\n\t__webpack_require__(/*! ./components/modal.tag */ 13);\n\t__webpack_require__(/*! ./components/signuporsignin.tag */ 17);\n\t__webpack_require__(/*! ./components/job.tag */ 9);\n\t__webpack_require__(/*! ./components/control.tag */ 6);\n\t__webpack_require__(/*! ./components/app.tag */ 5);\n\t__webpack_require__(/*! ./components/poller.tag */ 15);\n\t__webpack_require__(/*! ./components/homepage.tag */ 8);\n\t__webpack_require__(/*! ./components/drafteditpage.tag */ 7);\n\t__webpack_require__(/*! ./components/anon_homepage.tag */ 4);\n\t__webpack_require__(/*! ./components/loggedin_homepage.tag */ 10);\n\t__webpack_require__(/*! ./components/login.tag */ 11);\n\t__webpack_require__(/*! ./components/tsform.tag */ 19);\n\t\n\triot.mount('#app', 'app');\n\n/***/ },\n/* 22 */\n/*!*********************************!*\\\n  !*** ../~/watchjs/src/watch.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * DEVELOPED BY\n\t * GIL LOPES BUENO\n\t * gilbueno.mail@gmail.com\n\t *\n\t * WORKS WITH:\n\t * IE 9+, FF 4+, SF 5+, WebKit, CH 7+, OP 12+, BESEN, Rhino 1.7+\n\t *\n\t * FORK:\n\t * https://github.com/melanke/Watch.JS\n\t */\n\t\n\t\"use strict\";\n\t(function (factory) {\n\t    if (true) {\n\t        // Node. Does not work with strict CommonJS, but\n\t        // only CommonJS-like enviroments that support module.exports,\n\t        // like Node.\n\t        module.exports = factory();\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        // AMD. Register as an anonymous module.\n\t        define(factory);\n\t    } else {\n\t        // Browser globals\n\t        window.WatchJS = factory();\n\t        window.watch = window.WatchJS.watch;\n\t        window.unwatch = window.WatchJS.unwatch;\n\t        window.callWatchers = window.WatchJS.callWatchers;\n\t    }\n\t}(function () {\n\t\n\t    var WatchJS = {\n\t        noMore: false\n\t    },\n\t    defineWatcher,\n\t    unwatchOne,\n\t    callWatchers;\n\t\n\t    var isFunction = function (functionToCheck) {\n\t            var getType = {};\n\t            return functionToCheck && getType.toString.call(functionToCheck) == '[object Function]';\n\t    };\n\t\n\t    var isInt = function (x) {\n\t        return x % 1 === 0;\n\t    };\n\t\n\t    var isArray = function(obj) {\n\t        return Object.prototype.toString.call(obj) === '[object Array]';\n\t    };\n\t\n\t    var isModernBrowser = function () {\n\t        return Object.defineProperty || Object.prototype.__defineGetter__;\n\t    };\n\t\n\t    var defineGetAndSet = function (obj, propName, getter, setter) {\n\t        try {\n\t                Object.defineProperty(obj, propName, {\n\t                        get: getter,\n\t                        set: setter,\n\t                        enumerable: true,\n\t                        configurable: true\n\t                });\n\t        } catch(error) {\n\t            try{\n\t                Object.prototype.__defineGetter__.call(obj, propName, getter);\n\t                Object.prototype.__defineSetter__.call(obj, propName, setter);\n\t            }catch(error2){\n\t                throw \"watchJS error: browser not supported :/\"\n\t            }\n\t        }\n\t    };\n\t\n\t    var defineProp = function (obj, propName, value) {\n\t        try {\n\t            Object.defineProperty(obj, propName, {\n\t                enumerable: false,\n\t                configurable: true,\n\t                writable: false,\n\t                value: value\n\t            });\n\t        } catch(error) {\n\t            obj[propName] = value;\n\t        }\n\t    };\n\t\n\t    var watch = function () {\n\t\n\t        if (isFunction(arguments[1])) {\n\t            watchAll.apply(this, arguments);\n\t        } else if (isArray(arguments[1])) {\n\t            watchMany.apply(this, arguments);\n\t        } else {\n\t            watchOne.apply(this, arguments);\n\t        }\n\t\n\t    };\n\t\n\t\n\t    var watchAll = function (obj, watcher, level) {\n\t\n\t        if (obj instanceof String || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\n\t            return;\n\t        }\n\t\n\t        var props = [];\n\t\n\t\n\t        if(isArray(obj)) {\n\t            for (var prop = 0; prop < obj.length; prop++) { //for each item if obj is an array\n\t                props.push(prop); //put in the props\n\t            }\n\t        } else {\n\t            for (var prop2 in obj) { //for each attribute if obj is an object\n\t                props.push(prop2); //put in the props\n\t            }\n\t        }\n\t\n\t        watchMany(obj, props, watcher, level); //watch all itens of the props\n\t    };\n\t\n\t\n\t    var watchMany = function (obj, props, watcher, level) {\n\t\n\t        for (var prop in props) { //watch each attribute of \"props\" if is an object\n\t            watchOne(obj, props[prop], watcher, level);\n\t        }\n\t\n\t    };\n\t\n\t    var watchOne = function (obj, prop, watcher, level) {\n\t\n\t        if(isFunction(obj[prop])) { //dont watch if it is a function\n\t            return;\n\t        }\n\t\n\t        if(obj[prop] != null && (level === undefined || level > 0)){\n\t            if(level !== undefined){\n\t                level--;\n\t            }\n\t            watchAll(obj[prop], watcher, level); //recursively watch all attributes of this\n\t        }\n\t\n\t        defineWatcher(obj, prop, watcher);\n\t\n\t    };\n\t\n\t    var unwatch = function () {\n\t\n\t        if (isFunction(arguments[1])) {\n\t            unwatchAll.apply(this, arguments);\n\t        } else if (isArray(arguments[1])) {\n\t            unwatchMany.apply(this, arguments);\n\t        } else {\n\t            unwatchOne.apply(this, arguments);\n\t        }\n\t\n\t    };\n\t\n\t    var unwatchAll = function (obj, watcher) {\n\t\n\t        if (obj instanceof String || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\n\t            return;\n\t        }\n\t\n\t        var props = [];\n\t\n\t\n\t        if (isArray(obj)) {\n\t            for (var prop = 0; prop < obj.length; prop++) { //for each item if obj is an array\n\t                props.push(prop); //put in the props\n\t            }\n\t        } else {\n\t            for (var prop2 in obj) { //for each attribute if obj is an object\n\t                props.push(prop2); //put in the props\n\t            }\n\t        }\n\t\n\t        unwatchMany(obj, props, watcher); //watch all itens of the props\n\t    };\n\t\n\t\n\t    var unwatchMany = function (obj, props, watcher) {\n\t\n\t        for (var prop2 in props) { //watch each attribute of \"props\" if is an object\n\t            unwatchOne(obj, props[prop2], watcher);\n\t        }\n\t    };\n\t\n\t    if(isModernBrowser()){\n\t\n\t        defineWatcher = function (obj, prop, watcher) {\n\t\n\t            var val = obj[prop];\n\t\n\t            watchFunctions(obj, prop);\n\t\n\t            if (!obj.watchers) {\n\t                defineProp(obj, \"watchers\", {});\n\t            }\n\t\n\t            if (!obj.watchers[prop]) {\n\t                obj.watchers[prop] = [];\n\t            }\n\t\n\t\n\t            obj.watchers[prop].push(watcher); //add the new watcher in the watchers array\n\t\n\t\n\t            var getter = function () {\n\t                return val;\n\t            };\n\t\n\t\n\t            var setter = function (newval) {\n\t                var oldval = val;\n\t                val = newval;\n\t\n\t                if (obj[prop]){\n\t                    watchAll(obj[prop], watcher);\n\t                }\n\t\n\t                watchFunctions(obj, prop);\n\t\n\t                if (!WatchJS.noMore){\n\t                    if (JSON.stringify(oldval) !== JSON.stringify(newval)) {\n\t                        callWatchers(obj, prop, \"set\", newval, oldval);\n\t                        WatchJS.noMore = false;\n\t                    }\n\t                }\n\t            };\n\t\n\t            defineGetAndSet(obj, prop, getter, setter);\n\t\n\t        };\n\t\n\t        callWatchers = function (obj, prop, action, newval, oldval) {\n\t\n\t            for (var wr in obj.watchers[prop]) {\n\t                if (isInt(wr)){\n\t                    obj.watchers[prop][wr].call(obj, prop, action, newval, oldval);\n\t                }\n\t            }\n\t        };\n\t\n\t        // @todo code related to \"watchFunctions\" is certainly buggy\n\t        var methodNames = ['pop', 'push', 'reverse', 'shift', 'sort', 'slice', 'unshift'];\n\t        var defineArrayMethodWatcher = function (obj, prop, original, methodName) {\n\t            defineProp(obj[prop], methodName, function () {\n\t                var response = original.apply(obj[prop], arguments);\n\t                watchOne(obj, obj[prop]);\n\t                if (methodName !== 'slice') {\n\t                    callWatchers(obj, prop, methodName,arguments);\n\t                }\n\t                return response;\n\t            });\n\t        };\n\t\n\t        var watchFunctions = function(obj, prop) {\n\t\n\t            if ((!obj[prop]) || (obj[prop] instanceof String) || (!isArray(obj[prop]))) {\n\t                return;\n\t            }\n\t\n\t            for (var i = methodNames.length, methodName; i--;) {\n\t                methodName = methodNames[i];\n\t                defineArrayMethodWatcher(obj, prop, obj[prop][methodName], methodName);\n\t            }\n\t\n\t        };\n\t\n\t        unwatchOne = function (obj, prop, watcher) {\n\t            for(var i in obj.watchers[prop]){\n\t                var w = obj.watchers[prop][i];\n\t\n\t                if(w == watcher) {\n\t                    obj.watchers[prop].splice(i, 1);\n\t                }\n\t            }\n\t        };\n\t\n\t    } else {\n\t        //this implementation dont work because it cant handle the gap between \"settings\".\n\t        //I mean, if you use a setter for an attribute after another setter of the same attribute it will only fire the second\n\t        //but I think we could think something to fix it\n\t\n\t        var subjects = [];\n\t\n\t        defineWatcher = function(obj, prop, watcher){\n\t\n\t            subjects.push({\n\t                obj: obj,\n\t                prop: prop,\n\t                serialized: JSON.stringify(obj[prop]),\n\t                watcher: watcher\n\t            });\n\t\n\t        };\n\t\n\t        unwatchOne = function (obj, prop, watcher) {\n\t\n\t            for (var i in subjects) {\n\t                var subj = subjects[i];\n\t\n\t                if (subj.obj == obj && subj.prop == prop && subj.watcher == watcher) {\n\t                    subjects.splice(i, 1);\n\t                }\n\t\n\t            }\n\t\n\t        };\n\t\n\t        callWatchers = function (obj, prop, action, value) {\n\t\n\t            for (var i in subjects) {\n\t                var subj = subjects[i];\n\t\n\t                if (subj.obj == obj && subj.prop == prop) {\n\t                    subj.watcher.call(obj, prop, action, value);\n\t                }\n\t\n\t            }\n\t\n\t        };\n\t\n\t        var loop = function(){\n\t\n\t            for(var i in subjects){\n\t\n\t                var subj = subjects[i];\n\t                var newSer = JSON.stringify(subj.obj[subj.prop]);\n\t                if(newSer != subj.serialized){\n\t                    subj.watcher.call(subj.obj, subj.prop, subj.obj[subj.prop], JSON.parse(subj.serialized));\n\t                    subj.serialized = newSer;\n\t                }\n\t\n\t            }\n\t\n\t        };\n\t\n\t        setInterval(loop, 50);\n\t\n\t    }\n\t\n\t    WatchJS.watch = watch;\n\t    WatchJS.unwatch = unwatch;\n\t    WatchJS.callWatchers = callWatchers;\n\t\n\t    return WatchJS;\n\t\n\t}));\n\n\n/***/ },\n/* 23 */\n/*!*******************************************!*\\\n  !*** ../~/webpack/buildin/amd-options.js ***!\n  \\*******************************************/\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** app.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ddb8f9f6711a7d473cad\n **/","/* Riot v2.4.1, @license MIT */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.4.1', settings: {} },\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n  // tags instances cache\n  __virtualDom = [],\n  // tags implementation cache\n  __tagImpl = {},\n\n  /**\n   * Const\n   */\n  GLOBAL_MIXIN = '__global_mixin',\n\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n  RIOT_TAG_IS = 'data-is',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n  RESERVED_WORDS_BLACKLIST = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|parent|opts|trigger|o(?:n|ff|ne))$/,\n  // SVG tags list https://www.w3.org/TR/SVG/attindex.html#PresentationAttributes\n  SVG_TAGS_LIST = ['altGlyph', 'animate', 'animateColor', 'circle', 'clipPath', 'defs', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feGaussianBlur', 'feImage', 'feMerge', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence', 'filter', 'font', 'foreignObject', 'g', 'glyph', 'glyphRef', 'image', 'line', 'linearGradient', 'marker', 'mask', 'missing-glyph', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'switch', 'symbol', 'text', 'textPath', 'tref', 'tspan', 'use'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0,\n\n  // detect firefox to fix #1374\n  FIREFOX = window && !!window.InstallTrigger\n/* istanbul ignore next */\nriot.observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice\n\n  /**\n   * Private Methods\n   */\n\n  /**\n   * Helper function needed to get and loop all the events in a string\n   * @param   { String }   e - event string\n   * @param   {Function}   fn - callback\n   */\n  function onEachEvent(e, fn) {\n    var es = e.split(' '), l = es.length, i = 0, name, indx\n    for (; i < l; i++) {\n      name = es[i]\n      indx = name.indexOf('.')\n      if (name) fn( ~indx ? name.substring(0, indx) : name, i, ~indx ? name.slice(indx + 1) : null)\n    }\n  }\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given space separated list of `events` and\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } events - events ids\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(events, fn) {\n        if (typeof fn != 'function')  return el\n\n        onEachEvent(events, function(name, pos, ns) {\n          (callbacks[name] = callbacks[name] || []).push(fn)\n          fn.typed = pos > 0\n          fn.ns = ns\n        })\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given space separated list of `events` listeners\n     * @param   { String } events - events ids\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(events, fn) {\n        if (events == '*' && !fn) callbacks = {}\n        else {\n          onEachEvent(events, function(name, pos, ns) {\n            if (fn || ns) {\n              var arr = callbacks[name]\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn || ns && cb.ns == ns) arr.splice(i--, 1)\n              }\n            } else delete callbacks[name]\n          })\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given space separated list of `events` and\n     * execute the `callback` at most once\n     * @param   { String } events - events ids\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(events, fn) {\n        function on() {\n          el.off(events, on)\n          fn.apply(el, arguments)\n        }\n        return el.on(events, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given space separated list of `events`\n     * @param   { String } events - events ids\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(events) {\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns\n\n        for (var i = 0; i < arglen; i++) {\n          args[i] = arguments[i + 1] // skip first argument\n        }\n\n        onEachEvent(events, function(name, pos, ns) {\n\n          fns = slice.call(callbacks[name] || [], 0)\n\n          for (var i = 0, fn; fn = fns[i]; ++i) {\n            if (fn.busy) continue\n            fn.busy = 1\n            if (!ns || fn.ns == ns) fn.apply(el, fn.typed ? [name].concat(args) : args)\n            if (fns[i] !== fn) { i-- }\n            fn.busy = 0\n          }\n\n          if (callbacks['*'] && name != '*')\n            el.trigger.apply(el, ['*', name].concat(args))\n\n        })\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  })\n\n  return el\n\n}\n/* istanbul ignore next */\n;(function(riot) {\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\n\nvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  REPLACE = 'replace',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = typeof window != 'undefined' && window,\n  doc = typeof document != 'undefined' && document,\n  hist = win && history,\n  loc = win && (hist.location || win.location), // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  started = false,\n  central = riot.observable(),\n  routeFound = false,\n  debouncedEmit,\n  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n    args = path.match(re)\n\n  if (args) return args.slice(1)\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t\n  return function () {\n    clearTimeout(t)\n    t = setTimeout(fn, delay)\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1)\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n  doc[ADD_EVENT_LISTENER](clickEvent, click)\n  if (autoExec) emit(true)\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = []\n  riot.observable(this) // make it observable\n  central.on('stop', this.s.bind(this))\n  central.on('emit', this.e.bind(this))\n}\n\nfunction normalize(path) {\n  return path[REPLACE](/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] == '#'\n    ? (href || loc.href || '').split(base)[1] || ''\n    : (loc ? getPathFromRoot(href) : href || '')[REPLACE](base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel == 0\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\n  emitStackLevel++\n  emitStack.push(function() {\n    var path = getPathFromBase()\n    if (force || path != current) {\n      central[TRIGGER]('emit', path)\n      current = path\n    }\n  })\n  if (isRoot) {\n    while (emitStack.length) {\n      emitStack[0]()\n      emitStack.shift()\n    }\n    emitStackLevel = 0\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which != 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) return\n\n  var el = e.target\n  while (el && el.nodeName != 'A') el = el.parentNode\n\n  if (\n    !el || el.nodeName != 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target != '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n  ) return\n\n  if (el.href != loc.href) {\n    if (\n      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    ) return\n  }\n\n  e.preventDefault()\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @param {boolean} shouldReplace - use replaceState or pushState\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title, shouldReplace) {\n  if (hist) { // if a browser\n    path = base + normalize(path)\n    title = title || doc.title\n    // browsers ignores the second parameter `title`\n    shouldReplace\n      ? hist.replaceState(null, title, path)\n      : hist.pushState(null, title, path)\n    // so we need to set it manually\n    doc.title = title\n    routeFound = false\n    emit()\n    return routeFound\n  }\n\n  // Server-side usage: directly execute handlers for the path\n  return central[TRIGGER]('emit', getPathFromBase(path))\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * two strings and boolean:        replace history with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n * @param {boolean} third - replace flag\n */\nprot.m = function(first, second, third) {\n  if (isString(first) && (!second || isString(second))) go(first, second, third || false)\n  else if (second) this.r(first, second)\n  else this.r('@', first)\n}\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*')\n  this.$ = []\n}\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args))\n      return routeFound = true // exit from loop\n    }\n  }, this)\n}\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter != '@') {\n    filter = '/' + normalize(filter)\n    this.$.push(filter)\n  }\n  this.on(filter, action)\n}\n\nvar mainRouter = new Router()\nvar route = mainRouter.m.bind(mainRouter)\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router()\n  // assign sub-router's main method\n  var router = newSubRouter.m.bind(newSubRouter)\n  // stop only this sub-router\n  router.stop = newSubRouter.s.bind(newSubRouter)\n  return router\n}\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#'\n  current = getPathFromBase() // recalculate current path\n}\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true)\n}\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER\n    secondParser = DEFAULT_SECOND_PARSER\n  }\n  if (fn) parser = fn\n  if (fn2) secondParser = fn2\n}\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {}\n  var href = loc.href || current\n  href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n  return q\n}\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    if (win) {\n      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n      doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n    }\n    central[TRIGGER]('stop')\n    started = false\n  }\n}\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (win) {\n      if (document.readyState == 'complete') start(autoExec)\n      // the timeout is needed to solve\n      // a weird safari bug https://github.com/riot/route/issues/33\n      else win[ADD_EVENT_LISTENER]('load', function() {\n        setTimeout(function() { start(autoExec) }, 1)\n      })\n    }\n    started = true\n  }\n}\n\n/** Prepare the router **/\nroute.base()\nroute.parser()\n\nriot.route = route\n})(riot)\n/* istanbul ignore next */\n\n/**\n * The riot template engine\n * @version v2.4.0\n */\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n    },\n\n    DEFAULT = '{ }'\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ]\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) bp = _cache\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) return _pairs\n\n    var arr = pair.split(' ')\n\n    if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) { // eslint-disable-line\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr)\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr)\n    arr[6] = _rewrite(_pairs[6], arr)\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB)\n    arr[8] = pair\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) _bp = _cache\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6]\n\n    isexpr = start = re.lastIndex = 0\n\n    while ((match = re.exec(str))) {\n\n      pos = match.index\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(str, match[2], re.lastIndex)\n          continue\n        }\n        if (!match[3]) {\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos))\n        start = re.lastIndex\n        re = _bp[6 + (isexpr ^= 1)]\n        re.lastIndex = start\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start))\n    }\n\n    return parts\n\n    function unescapeStr (s) {\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'))\n      } else {\n        parts.push(s)\n      }\n    }\n\n    function skipBraces (s, ch, ix) {\n      var\n        match,\n        recch = FINDBRACES[ch]\n\n      recch.lastIndex = ix\n      ix = 1\n      while ((match = recch.exec(s))) {\n        if (match[1] &&\n          !(match[1] === ch ? ++ix : --ix)) break\n      }\n      return ix ? s.length : recch.lastIndex\n    }\n  }\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  }\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9])\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  }\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  }\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair)\n      _regex = pair === DEFAULT ? _loopback : _rewrite\n      _cache[9] = _regex(_pairs[9])\n    }\n    cachedBrackets = pair\n  }\n\n  function _setSettings (o) {\n    var b\n\n    o = o || {}\n    b = o.brackets\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    })\n    _settings = o\n    _reset(b)\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  })\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n  _brackets.set = _reset\n\n  _brackets.R_STRINGS = R_STRINGS\n  _brackets.R_MLCOMMS = R_MLCOMMS\n  _brackets.S_QBLOCKS = S_QBLOCKS\n\n  return _brackets\n\n})()\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {}\n\n  function _tmpl (str, data) {\n    if (!str) return str\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.haveRaw = brackets.hasRaw\n\n  _tmpl.hasExpr = brackets.hasExpr\n\n  _tmpl.loopKeys = brackets.loopKeys\n\n  _tmpl.errorHandler = null\n\n  function _logErr (err, ctx) {\n\n    if (_tmpl.errorHandler) {\n\n      err.riotData = {\n        tagName: ctx && ctx.root && ctx.root.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      }\n      _tmpl.errorHandler(err)\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str)\n\n    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\n/* eslint-disable */\n\n    return new Function('E', expr + ';')\n/* eslint-enable */\n  }\n\n  var\n    CH_IDEXPR = '\\u2057',\n    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_DQUOTE = /\\u2057/g,\n    RE_QBMARK = /\\u2057(\\d+)~/g\n\n  function _getTmpl (str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1)\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = []\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i]\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) list[j++] = expr\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")'\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr)\n    }\n\n    if (qstr[0]) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      })\n    }\n    return expr\n  }\n\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    }\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g\n\n        expr = RegExp.rightContext\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\n        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\n        jsb  = expr.slice(0, match.index)\n        expr = RegExp.rightContext\n\n        list[cnt++] = _wrapExpr(jsb, 1, key)\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch]\n\n      ir.lastIndex = re.lastIndex\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) ++lv\n        else if (!--lv) break\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/\n\n  function _wrapExpr (expr, asText, key) {\n    var tb\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos))\n        }\n      }\n      return match\n    })\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"'\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)'\n    }\n\n    return expr\n  }\n\n  // istanbul ignore next: compatibility fix for beta versions\n  _tmpl.parse = function (s) { return s }\n\n  _tmpl.version = brackets.version = 'v2.4.0'\n\n  return _tmpl\n\n})()\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\nvar mkdom = (function _mkdom() {\n  var\n    reHasYield  = /<yield\\b/i,\n    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n    reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig\n  var\n    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n    tblTags = IE_VERSION && IE_VERSION < 10\n      ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/\n\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   {string} templ  - The template coming from the custom tag definition\n   * @param   {string} [html] - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.\n   */\n  function _mkdom(templ, html) {\n    var\n      match   = templ && templ.match(/^\\s*<([-\\w]+)/),\n      tagName = match && match[1].toLowerCase(),\n      el = mkEl('div', isSVGTag(tagName))\n\n    // replace all the yield tags with the tag inner html\n    templ = replaceYield(templ, html)\n\n    /* istanbul ignore next */\n    if (tblTags.test(tagName))\n      el = specialTags(el, templ, tagName)\n    else\n      setInnerHTML(el, templ)\n\n    el.stub = true\n\n    return el\n  }\n\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n  function specialTags(el, templ, tagName) {\n    var\n      select = tagName[0] === 'o',\n      parent = select ? 'select>' : 'table>'\n\n    // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n    el.innerHTML = '<' + parent + templ.trim() + '</' + parent\n    parent = el.firstChild\n\n    // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n    if (select) {\n      parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior\n    } else {\n      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n      var tname = rootEls[tagName]\n      if (tname && parent.childElementCount === 1) parent = $(tname, parent)\n    }\n    return parent\n  }\n\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n  function replaceYield(templ, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(templ)) return templ\n\n    // be careful with #1343 - string on the source having `$1`\n    var src = {}\n\n    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n      src[ref] = src[ref] || text   // preserve first definition\n      return ''\n    }).trim()\n\n    return templ\n      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n        return src[ref] || def || ''\n      })\n      .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n        return html || def || ''\n      })\n  }\n\n  return _mkdom\n\n})()\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n\n  var i = tags.length,\n    j = items.length,\n    t\n\n  while (i > j) {\n    t = tags[--i]\n    tags.splice(i, 1)\n    t.unmount()\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @param   { Object } child - non custom loop tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(child, i) {\n  Object.keys(child.tags).forEach(function(tagName) {\n    var tag = child.tags[tagName]\n    if (isArray(tag))\n      each(tag, function (t) {\n        moveChildTag(t, tagName, i)\n      })\n    else\n      moveChildTag(tag, tagName, i)\n  })\n}\n\n/**\n * Adds the elements for a virtual tag\n * @param { Tag } tag - the tag whose root's children will be inserted or appended\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction addVirtual(tag, src, target) {\n  var el = tag._root, sib\n  tag._virts = []\n  while (el) {\n    sib = el.nextSibling\n    if (target)\n      src.insertBefore(el, target._root)\n    else\n      src.appendChild(el)\n\n    tag._virts.push(el) // hold for unmounting\n    el = sib\n  }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @param { Tag } tag - first child reference used to start move\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n * @param { Number } len - how many child nodes to move\n */\nfunction moveVirtual(tag, src, target, len) {\n  var el = tag._root, sib, i = 0\n  for (; i < len; i++) {\n    sib = el.nextSibling\n    src.insertBefore(el, target._root)\n    el = sib\n  }\n}\n\n\n/**\n * Manage tags having the 'each'\n * @param   { Object } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each')\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __tagImpl[tagName] || { tmpl: getOuterHTML(dom) },\n    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n    root = dom.parentNode,\n    ref = document.createTextNode(''),\n    child = getTag(dom),\n    isOption = tagName.toLowerCase() === 'option', // the option tags must be treated differently\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isVirtual = dom.tagName == 'VIRTUAL'\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr)\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom)\n\n  // clean template code\n  parent.one('before-mount', function () {\n\n    // remove the original DOM node\n    dom.parentNode.removeChild(dom)\n    if (root.stub) root = parent.root\n\n  }).on('update', function () {\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      // create a fragment to hold the new DOM nodes to inject in the parent tag\n      frag = document.createDocumentFragment()\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, key, items[key])\n        }) : []\n    }\n\n    // loop all the new items\n    var i = 0,\n      itemsLength = items.length\n\n    for (; i < itemsLength; i++) {\n      // reorder only if the items are objects\n      var\n        item = items[i],\n        _mustReorder = mustReorder && typeof item == T_OBJECT && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos]\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n      ) {\n\n        tag = new Tag(impl, {\n          parent: parent,\n          isLoop: true,\n          hasImpl: !!__tagImpl[tagName],\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML)\n\n        tag.mount()\n\n        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n        // this tag must be appended\n        if (i == tags.length || !tags[i]) { // fix 1581\n          if (isVirtual)\n            addVirtual(tag, frag)\n          else frag.appendChild(tag.root)\n        }\n        // this tag must be insert\n        else {\n          if (isVirtual)\n            addVirtual(tag, root, tags[i])\n          else root.insertBefore(tag.root, tags[i].root) // #1374 some browsers reset selected here\n          oldItems.splice(i, 0, item)\n        }\n\n        tags.splice(i, 0, tag)\n        pos = i // handled here so no move\n      } else tag.update(item, true)\n\n      // reorder the tag if it's not located in its previous position\n      if (\n        pos !== i && _mustReorder &&\n        tags[i] // fix 1581 unable to reproduce it in a test!\n      ) {\n        // update the DOM\n        if (isVirtual)\n          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n        else root.insertBefore(tag.root, tags[i].root)\n        // update the position attribute if it exists\n        if (expr.pos)\n          tag[expr.pos] = i\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0])\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) moveNestedTags(tag, i)\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent)\n    }\n\n    // remove the redundant tags\n    unmountRedundant(items, tags)\n\n    // insert the new nodes\n    if (isOption) {\n      root.appendChild(frag)\n\n      // #1374 FireFox bug in <option selected={expression}>\n      if (FIREFOX && !root.multiple) {\n        for (var n = 0; n < root.length; n++) {\n          if (root[n].__riot1374) {\n            root.selectedIndex = n  // clear other options\n            delete root[n].__riot1374\n            break\n          }\n        }\n      }\n    }\n    else root.insertBefore(frag, ref)\n\n    // set the 'tags' property of the parent tag\n    // if child is 'undefined' it means that we don't need to set this property\n    // for example:\n    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n    if (child) parent.tags[tagName] = tags\n\n    // clone the items array\n    oldItems = items.slice()\n\n  })\n\n}\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = (function(_riot) {\n\n  if (!window) return { // skip injection on the server\n    add: function () {},\n    inject: function () {}\n  }\n\n  var styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style')\n    setAttr(newNode, 'type', 'text/css')\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]')\n    if (userNode) {\n      if (userNode.id) newNode.id = userNode.id\n      userNode.parentNode.replaceChild(newNode, userNode)\n    }\n    else document.getElementsByTagName('head')[0].appendChild(newNode)\n\n    return newNode\n  })()\n\n  // Create cache and shortcut to the correct property\n  var cssTextProp = styleNode.styleSheet,\n    stylesToInject = ''\n\n  // Expose the style node in a non-modificable property\n  Object.defineProperty(_riot, 'styleNode', {\n    value: styleNode,\n    writable: true\n  })\n\n  /**\n   * Public api\n   */\n  return {\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param   { String } css [description]\n     */\n    add: function(css) {\n      stylesToInject += css\n    },\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function() {\n      if (stylesToInject) {\n        if (cssTextProp) cssTextProp.cssText += stylesToInject\n        else styleNode.innerHTML += stylesToInject\n        stylesToInject = ''\n      }\n    }\n  }\n\n})(riot)\n\n\nfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop ||\n                  (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each'))\n                    ? 1 : 0\n\n      // custom child tag\n      if (childTags) {\n        var child = getTag(dom)\n\n        if (child && !dom.isLoop)\n          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n      }\n\n      if (!dom.isLoop || forceParsingNamed)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (tmpl.hasExpr(val)) {\n      expressions.push(extend({ dom: dom, expr: val }, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType,\n      attr\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    attr = getAttr(dom, 'each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n    opts = inherit(conf.opts) || {},\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    hasImpl = conf.hasImpl,\n    item = cleanUpData(conf.item),\n    expressions = [],\n    childTags = [],\n    root = conf.root,\n    tagName = root.tagName.toLowerCase(),\n    attr = {},\n    propsInSyncWithParent = [],\n    dom\n\n  // only call unmount if we have a valid __tagImpl (has name property)\n  if (impl.name && root._tag) root._tag.unmount(true)\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts}, item)\n  // protect the \"tags\" property from being overridden\n  defineProperty(this, 'tags', {})\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (tmpl.hasExpr(val)) attr[el.name] = val\n  })\n\n  dom = mkdom(impl.tmpl, innerHTML)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      var val = el.value\n      opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[toCamel(name)] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !RESERVED_WORDS_BLACKLIST.test(k) && contains(propsInSyncWithParent, k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @param   { Boolean } isInherited - is this update coming from a parent tag?\n   * @returns { self }\n   */\n  defineProperty(this, 'update', function(data, isInherited) {\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (data && isObject(item)) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n\n    // the updated event will be triggered\n    // once the DOM will be ready and all the re-flows are completed\n    // this is useful if you want to get the \"real\" root properties\n    // 4 ex: root.offsetWidth ...\n    if (isInherited && self.parent)\n      // closes #1599\n      self.parent.one('updated', function() { self.trigger('updated') })\n    else rAF(function() { self.trigger('updated') })\n\n    return this\n  })\n\n  defineProperty(this, 'mixin', function() {\n    each(arguments, function(mix) {\n      var instance\n\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix()\n        // save the prototype to loop it afterwards\n        mix = mix.prototype\n      } else instance = mix\n\n      // loop the keys in the function prototype or the all object keys\n      each(Object.getOwnPropertyNames(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(instance[key]) ?\n                        instance[key].bind(self) :\n                        instance[key]\n      })\n\n      // init method will be called automatically\n      if (instance.init) instance.init.bind(self)()\n    })\n    return this\n  })\n\n  defineProperty(this, 'mount', function() {\n\n    updateOpts()\n\n    // add global mixins\n    var globalMixin = riot.mixin(GLOBAL_MIXIN)\n    if (globalMixin)\n      for (var i in globalMixin)\n        if (globalMixin.hasOwnProperty(i))\n          self.mixin(globalMixin[i])\n\n    // initialiation\n    if (impl.fn) impl.fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (impl.attrs)\n      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n    if (impl.attrs || hasImpl)\n      parseExpressions(self.root, self, expressions)\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('before-mount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      root = dom.firstChild\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) root = parent.root\n    }\n\n    defineProperty(self, 'root', root)\n\n    // parse the named dom nodes in the looped child\n    // adding them to the parent as well\n    if (isLoop)\n      parseNamedElements(self.root, self.parent, null, true)\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  })\n\n\n  defineProperty(this, 'unmount', function(keepRootTag) {\n    var el = root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __virtualDom.indexOf(self)\n\n    self.trigger('before-unmount')\n\n    // remove this tag instance from the global virtualDom variable\n    if (~tagIndex)\n      __virtualDom.splice(tagIndex, 1)\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._riot_id == self._riot_id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else {\n        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n        remAttr(p, RIOT_TAG_IS)\n        remAttr(p, RIOT_TAG) // this will be removed in riot 3.0.0\n      }\n\n    }\n\n    if (this._virts) {\n      each(this._virts, function(v) {\n        if (v.parentNode) v.parentNode.removeChild(v)\n      })\n    }\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    self.isMounted = false\n    delete root._tag\n\n  })\n\n  // proxy function to bind updates\n  // dispatched from a parent tag\n  function onChildUpdate(data) { self.update(data, true) }\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (!parent) return\n    var evt = isMount ? 'on' : 'off'\n\n    // the loop tags will be always in sync with the parent automatically\n    if (isLoop)\n      parent[evt]('unmount', self.unmount)\n    else {\n      parent[evt]('update', onChildUpdate)[evt]('unmount', self.unmount)\n    }\n  }\n\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n}\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // override the event properties\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n\n/**\n * Insert a DOM node replacing another one (used by if- attribute)\n * @param   { Object } root - parent node\n * @param   { Object } node - node replaced\n * @param   { Object } before - node added\n */\nfunction insertTo(root, node, before) {\n  if (!root) return\n  root.insertBefore(before, node)\n  root.removeChild(node)\n}\n\n/**\n * Update the expressions in a Tag instance\n * @param   { Array } expressions - expression that must be re evaluated\n * @param   { Tag } tag - tag instance\n */\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n      attrName = expr.attr,\n      value = tmpl(expr.expr, tag),\n      parent = expr.dom.parentNode\n\n    if (expr.bool) {\n      value = !!value\n    } else if (value == null) {\n      value = ''\n    }\n\n    // #1638: regression of #1612, update the dom only if the value of the\n    // expression was changed\n    if (expr.value === value) {\n      return\n    }\n    expr.value = value\n\n    // textarea and text nodes has no attribute name\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += ''\n      // test for parent avoids error with invalid assignment to nodeValue\n      if (parent) {\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value                    // #1113\n          if (!IE_VERSION) dom.nodeValue = value  // #1625 IE throws here, nodeValue\n        }                                         // will be available on 'updated'\n        else dom.nodeValue = value\n      }\n      return\n    }\n\n    // ~~#1612: look for changes in dom.value when updating the value~~\n    if (attrName === 'value') {\n      dom.value = value\n      return\n    }\n\n    // remove original attribute\n    remAttr(dom, attrName)\n\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n        add = function() { insertTo(stub.parentNode, stub, dom) },\n        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted)\n                el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        // otherwise we need to wait the updated event\n        else (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (attrName === 'show') {\n      dom.style.display = value ? '' : 'none'\n\n    } else if (attrName === 'hide') {\n      dom.style.display = value ? 'none' : ''\n\n    } else if (expr.bool) {\n      dom[attrName] = value\n      if (value) setAttr(dom, attrName, attrName)\n      if (FIREFOX && attrName === 'selected' && dom.tagName === 'OPTION') {\n        dom.__riot1374 = value   // #1374\n      }\n\n    } else if (value === 0 || value && typeof value !== T_OBJECT) {\n      // <img src=\"{ expr }\">\n      if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n        attrName = attrName.slice(RIOT_PREFIX.length)\n      }\n      setAttr(dom, attrName, value)\n    }\n\n  })\n\n}\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } els - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(els, fn) {\n  var len = els ? els.length : 0\n\n  for (var i = 0, el; i < len; i++) {\n    el = els[i]\n    // return false -> current item was removed by fn during the loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\n/**\n * Detect if the argument passed is a function\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\n/**\n * Get the outer html of any DOM node SVGs included\n * @param   { Object } el - DOM node to parse\n * @returns { String } el.outerHTML\n */\nfunction getOuterHTML(el) {\n  if (el.outerHTML) return el.outerHTML\n  // some browsers do not support outerHTML on the SVGs tags\n  else {\n    var container = mkEl('div')\n    container.appendChild(el.cloneNode(true))\n    return container.innerHTML\n  }\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we will inject the new html\n * @param { String } html - html to inject\n */\nfunction setInnerHTML(container, html) {\n  if (typeof container.innerHTML != T_UNDEF) container.innerHTML = html\n  // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml')\n    container.appendChild(\n      container.ownerDocument.importNode(doc.documentElement, true)\n    )\n  }\n}\n\n/**\n * Checks wether a DOM node must be considered part of an svg document\n * @param   { String }  name - tag name\n * @returns { Boolean } -\n */\nfunction isSVGTag(name) {\n  return ~SVG_TAGS_LIST.indexOf(name)\n}\n\n/**\n * Detect if the argument passed is an object, exclude null.\n * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isObject(v) {\n  return v && typeof v === T_OBJECT         // typeof null is 'object'\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } string - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(string) {\n  return string.replace(/-(\\w)/g, function(_, c) {\n    return c.toUpperCase()\n  })\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  dom.setAttribute(name, val)\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG_IS) ||\n    getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n/**\n * Add a child tag to its parent into the `tags` object\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the new tag will be stored\n * @param   { Object } parent - tag instance where the new child tag will be included\n */\nfunction addChildTag(tag, tagName, parent) {\n  var cachedTag = parent.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      // don't add the same tag twice\n      if (cachedTag !== tag)\n        parent.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!contains(parent.tags[tagName], tag))\n      parent.tags[tagName].push(tag)\n  } else {\n    parent.tags[tagName] = tag\n  }\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tag, tagName, newPos) {\n  var parent = tag.parent,\n    tags\n  // no parent no move\n  if (!parent) return\n\n  tags = parent.tags[tagName]\n\n  if (isArray(tags))\n    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n  else addChildTag(tag, tagName, parent)\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag(child, opts, innerHTML),\n    tagName = getTagName(opts.root),\n    ptag = getImmediateCustomParentTag(parent)\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent\n\n  // add this tag to the custom parent tag\n  addChildTag(tag, tagName, ptag)\n  // and also to the real parent tag\n  if (ptag !== parent)\n    addChildTag(tag, tagName, parent)\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = ''\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n* @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options))\n  return el\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = getAttr(dom, 'name'),\n    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } arr - target array\n * @param   { * } item - item to test\n * @returns { Boolean } Does 'arr' contain 'item'?\n */\nfunction contains(arr, item) {\n  return ~arr.indexOf(item)\n}\n\n/**\n * Check whether an object is a kind of array\n * @param   { * } a - anything\n * @returns {Boolean} is 'a' an array?\n */\nfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\n/**\n * Detect whether a property of an object could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } is this property writable?\n */\nfunction isWritable(obj, key) {\n  var props = Object.getOwnPropertyDescriptor(obj, key)\n  return typeof obj[key] === T_UNDEF || props && props.writable\n}\n\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))\n    return data\n\n  var o = {}\n  for (var key in data) {\n    if (!RESERVED_WORDS_BLACKLIST.test(key)) o[key] = data[key]\n  }\n  return o\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n */\nfunction walk(dom, fn) {\n  if (dom) {\n    // stop the recursion\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  var m,\n    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while (m = re.exec(html)) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @param   { Boolean } isSvg - should we use a SVG as parent node?\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name, isSvg) {\n  return isSvg ?\n    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n    document.createElement(name)\n}\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Simple object prototypal inheritance\n * @param   { Object } parent - parent object\n * @returns { Object } child instance\n */\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\n/**\n * Get the name property needed to identify a DOM node in riot\n * @param   { Object } dom - DOM node we need to parse\n * @returns { String | undefined } give us back a string to identify this dom node\n */\nfunction getNamedKey(dom) {\n  return getAttr(dom, 'id') || getAttr(dom, 'name')\n}\n\n/**\n * Set the named properties of a tag element\n * @param { Object } dom - DOM node we need to parse\n * @param { Object } parent - tag instance where the named dom element will be eventually added\n * @param { Array } keys - list of all the tag instance properties\n */\nfunction setNamed(dom, parent, keys) {\n  // get the key value we want to add to the tag instance\n  var key = getNamedKey(dom),\n    isArr,\n    // add the node detected to a tag instance using the named property\n    add = function(value) {\n      // avoid to override the tag properties already set\n      if (contains(keys, key)) return\n      // check whether this value is an array\n      isArr = isArray(value)\n      // if the key was never set\n      if (!value)\n        // set it once on the tag instance\n        parent[key] = dom\n      // if it was an array and not yet set\n      else if (!isArr || isArr && !contains(value, dom)) {\n        // add the dom node into the array\n        if (isArr)\n          value.push(dom)\n        else\n          parent[key] = [value, dom]\n      }\n    }\n\n  // skip the elements with no named properties\n  if (!key) return\n\n  // check whether this key has been already evaluated\n  if (tmpl.hasExpr(key))\n    // wait the first updated event only once\n    parent.one('mount', function() {\n      key = getNamedKey(dom)\n      add(parent[key])\n    })\n  else\n    add(parent[key])\n\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } src - source string\n * @param   { String } str - test string\n * @returns { Boolean } -\n */\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/**\n * requestAnimationFrame function\n * Adapted from https://gist.github.com/paulirish/1579671, license MIT\n */\nvar rAF = (function (w) {\n  var raf = w.requestAnimationFrame    ||\n            w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame\n\n  if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {  // buggy iOS6\n    var lastTime = 0\n\n    raf = function (cb) {\n      var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0)\n      setTimeout(function () { cb(lastTime = nowtime + timeout) }, timeout)\n    }\n  }\n  return raf\n\n})(window || {})\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts) {\n  var tag = __tagImpl[tagName],\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    // add this tag to the virtualDom variable\n    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n  }\n\n  return tag\n}\n/**\n * Riot public api\n */\n\n// share methods for other riot parts, e.g. compiler\nriot.util = { brackets: brackets, tmpl: tmpl }\n\n/**\n * Create a mixin that could be globally shared across all the tags\n */\nriot.mixin = (function() {\n  var mixins = {},\n    globals = mixins[GLOBAL_MIXIN] = {},\n    _id = 0\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String }  name - mixin name (global mixin if object)\n   * @param   { Object }  mixin - mixin logic\n   * @param   { Boolean } g - is global?\n   * @returns { Object }  the mixin logic\n   */\n  return function(name, mixin, g) {\n    // Unnamed global\n    if (isObject(name)) {\n      riot.mixin('__unnamed_'+_id++, name, true)\n      return\n    }\n\n    var store = g ? globals : mixins\n\n    // Getter\n    if (!mixin) {\n      if (typeof store[name] === T_UNDEF) {\n        throw new Error('Unregistered mixin: ' + name)\n      }\n      return store[name]\n    }\n    // Setter\n    if (isFunction(mixin)) {\n      extend(mixin.prototype, store[name] || {})\n      store[name] = mixin\n    }\n    else {\n      store[name] = extend(store[name] || {}, mixin)\n    }\n  }\n\n})()\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else styleManager.add(css)\n  }\n  name = name.toLowerCase()\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag2 = function(name, html, css, attrs, fn) {\n  if (css) styleManager.add(css)\n  //if (bpair) riot.settings.brackets = bpair\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { String } selector - tag DOM selector\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n    allTags,\n    tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      if (!/[^-\\w]/.test(e)) {\n        e = e.trim().toLowerCase()\n        list += ',[' + RIOT_TAG_IS + '=\"' + e + '\"],[' + RIOT_TAG + '=\"' + e + '\"]'\n      }\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(__tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, RIOT_TAG_IS) || getAttr(root, RIOT_TAG)\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName\n        setAttr(root, RIOT_TAG_IS, tagName)\n        setAttr(root, RIOT_TAG, tagName) // this will be removed in riot 3.0.0\n      }\n      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    } else if (root.length) {\n      each(root, pushTags)   // assume nodeList\n    }\n  }\n\n  // ----- mount code -----\n\n  // inject styles into DOM\n  styleManager.inject()\n\n  if (isObject(tagName)) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(/, */))\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    els = selector ? $$(selector) : []\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  pushTags(els)\n\n  return tags\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nriot.update = function() {\n  return each(__virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n/**\n * Export the Virtual DOM\n */\nriot.vdom = __virtualDom\n\n/**\n * Export the Tag constructor\n */\nriot.Tag = Tag\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF)\n    define(function() { return riot })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/riot/riot.js\n ** module id = 1\n ** module chunks = 0\n **/","(function iife (root, factory) {\n  'use strict';\n\n  var moduleName = 'Arbiter';\n\n  // Detect AMD/RequireJS environments and register as an anonymous module\n  if (typeof root.define === 'function') {\n    root.define(['exports'], factory);\n\n  // Detect CommonJS/Node environments and export arbiter\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n\n  // Other \"global\" environments such as browsers. Attempt to expose itself\n  // using the revealing module pattern.\n  } else {\n    root[moduleName] = factory();\n  }\n  // TODO When a browser ships ES6 modules support, detect it and expose the\n  // goods. This is not done because there is some uncertainty how browsers will\n  // handle these features. Possible methods are:\n  // 1) Using try/catching around import/export statement\n  // 2) Try some sort of lazy loading mechanism\n}(this, function factory () {\n  'use strict';\n\n  return create();\n\n  /**\n   * A Topic is simply a string. This string is can contain any character, but\n   * two characters have special meanings. The comma `','`, with optional\n   * whitespace, separates individual Topics. This means that `\"a, b\"` is the\n   * same as two separate topics, `[\"a\", \"b\"]`. The second special character is\n   * the period or dot `'.'`. This character separates generations. In the\n   * example `\"a.b\"`, `\"a\"` is an ancestor of it and `\"a.b.c\"` is a descendent\n   * of it. This creates a hierarchical relationship between topics. When\n   * you publish a topic all of the ancestors or parents are also\n   * notified. The empty string is an ancestor all topics. When publishing\n   * to `\"a.b.c.d\"`, all subscribers to `\"\"`, `\"a\"`, `\"a.b\"`, `\"a.b.c\"`,\n   * `\"a.b.c.d\"` will be executed in priority order. If there is a\n   * subscriber to `\"\"` with a very high priority, it will be notified\n   * before `\"a\"` with a much lower priority.\n   *\n   * @typedef Topic\n   * @memberof Arbiter\n   * @example\n   *\n   * Arbiter.subscribe('', function f1 () {});\n   * Arbiter.subscribe('a', function f2 () {});\n   * Arbiter.subscribe('a.b', function f3 () {});\n   * Arbiter.subscribe('a.c', function f4 () {});\n   * Arbiter.subscribe('a.b.c', function f5 () {});\n   * Arbiter.publish('a.b'); // Executes f1, f2, f3 in priority order\n   */\n\n  // *************************************************************************\n  //   Public Instance Functions\n  // *************************************************************************\n\n  /**\n   * `Arbiter.subscribe` registers a subscription to a topic and its\n   * descendants. When a publication occurs it will be notified. The behavior\n   * can be modified by using the options parameter. `options.priority`\n   * establishes the order to notify subscribers when multiple subscribers\n   * exist. The other option is `ignorePersisted`. This allows a subscriber\n   * to skip being notified of saved messages.\n   *\n   * @function subscribe\n   * @memberof Arbiter\n   *\n   * @param {Topic|Topic[]} topic The title of the topic to listen for\n   *   publications. Topics are hierarchical can be separated by `\",\"`.\n   * @param {Subscription} subscription The function to invoke every\n   *   time a publication occurs. If `subscription` is not a function, a\n   *   no-operation is put in its place.\n   * @param {Object} [options]. An object that can have two properties.\n   *   `ignorePersited` and `priority`.\n   * @param {Object} [context=null] The value of `this` for the subscription.\n   * @return {Token} A unique token to remove this subscription from\n   *   the distribution list.\n   *\n   * @example\n   * Arbiter.publish('my.topic', null, {persist: true});\n   * Arbiter.subscribe('my.topic', log, {ignorePersisted: true}); // => Nothing\n   */\n\n  /**\n   * A Subscription is a function provided to the `subscribe` method. It is used\n   * as a callback when a publication occurs. The subscriber is considered\n   * \"done working\" if it returns a value (even `undefined`). If an error is\n   * thrown, then it is assumed that the subscriber failed. If it returns a\n   * `Promise`, then it is \"done\" when the `Promise` is fulfilled. If rejected,\n   * it is assumed to fail. If the subscriber function has a length of 3\n   * or more, then it is provided with callback function as the third argument\n   * to be treated as a node-style callback. The first argument to the callback\n   * is the error and the second is the \"return value\".\n   *\n   * @callback Subscription\n   * @memberof Arbiter\n   * @param {Object} data The data associated with the publication.\n   * @param {Topic} topic The topic to which the publication belongs.\n   * @param {Function} [callback] A node style callback.\n   * @return {Object} This is either a `Promise` or a value used to\n   *   communicate when the subscriber is done.\n   *\n   * @example\n   *\n   * // All of the following look the same from a publishers perspective.\n   * Arbiter.subscribe('my.topic', function() {\n   *   return new Promise(function(fulfill, reject) {\n   *     Math.random() > 0.5 ? fulfill('hi') : reject('bye');\n   *   });\n   * });\n   *\n   * Arbiter.subscribe('my.topic', function(data, topic, done) {\n   *   Math.random() > 0.5 ? done(null, 'hi') : done('bye');\n   * });\n   *\n   * Arbiter.subscribe('my.topic', function() {\n   *   if (Math.random() > 0.5) {\n   *     return 'hi';\n   *   } else {\n   *     throw 'bye';\n   *   }\n   * });\n   */\n  function subscribe (state, topic, subscription, options, context) {\n    assert(typeof topic, 'string', 'Arbiter.subscribe', 'strings', 'topics');\n    options = merge(state.options, options);\n\n    var\n      ancestor = addTopicLine(\n        topic, ancestorTopicSearch(topic, state._topics)\n      ),\n      node = insert(\n        getPriority,\n        createSubscription(state, subscription, options, context),\n        ancestor.subscriptions\n      ),\n      subscriptionToken = {\n        topic: topic,\n        id: node.id,\n        priority: node.priority\n      };\n\n    // Notify late subscribers of persisted messages\n    if (!options.ignorePersisted) {\n      var\n        persistedDescendents = map(getPersisted, descendents(ancestor)),\n        persistedMessages = mergeBy(getFingerArrayOrder, persistedDescendents),\n\n        persisted, i, n;\n\n      for (i = 0, n = persistedMessages.length; i < n; i++) {\n        persisted = persistedMessages[i];\n        !subscription.suspended // eslint-disable-line no-unused-expressions\n          && subscription.call(\n            subscription.context, persisted.data, persisted.topic\n          );\n      }\n    }\n\n    return subscriptionToken;\n  }\n\n  /**\n   * `Arbiter.publish` notifies all subscribers of a publication by invoking\n   * their subscription function with the data and topic associated with the\n   * publication.\n   *\n   * @function publish\n   * @memberof Arbiter\n   *\n   * @param {Topic} topic All subscribers to this topic, will be notified of\n   *   the publication\n   * @param {Object} [data] This data is the publication that all subscribers\n   *   will receive.\n   * @param {Object} [options] These options override the options in\n   *   Arbiter.options for this publication only. See [`Options`](#options) for\n   *   a complete list\n   * @return {PublicationPromise} This resolves according to\n   *   [`Options`](#options)\n   *\n   * @example\n   *\n   * var options = {persist: true, preventBubble: true};\n   * Arbiter.publish('app.init', 'initialization', options);\n   * Arbiter.subscribe('app', log); // => Nothing because of `preventBubble`\n   * Arbiter.subscribe('app.init', log); // => logs app.init initialization\n   */\n\n  /**\n   * `publish` returns a `PublicationPromise`. This is a regular old\n   * promise with some additional properties described below. Each property is\n   * updated in real time as updates occur; it stops updating when the promise\n   * fulfills. This can be changed with\n   * `Arbiter.options.updateAfterSettlement`.\n   *\n   * @typedef PublicationPromise PublicationPromise\n   * @memberof Arbiter\n   * @property {number} fulfilled The number of promises fulfilled when this\n   *   promise settles.\n   * @property {number} rejected The number of promises rejected when this\n   *   promise settles.\n   * @property {number} pending The number of promises pending when this\n   *   promise settles.\n   * @property {Token} token If the `options.persist` is true, then a token is\n   *   added to the promise so it can be removed later.\n   *\n   * @example\n   *\n   * Arbiter.subscribe('get', getFromCache);\n   * Arbiter.subscribe('get', getFromAjax);\n   * Arbiter.publish('get', {latch: 1})\n   *   .then(function(data) {\n   *     // This is fulfilled when one of the subscribers fulfills because\n   *     // of `latch: 1`. In this case we could also use `latch: 0.5`.\n   *   }, function(errs) {\n   *     // This occurs when it is impossible to satisify the latch. In this\n   *     // case, both have to fail.\n   *   });\n   *\n   */\n  function publish (state, topic, data, options) {\n    assert(typeof topic, 'string', 'Arbiter.publish', 'strings', 'topics');\n    options = merge(state.options, options);\n\n    var args = [state, topic, data, options];\n    if (options.sync) {\n      return hierarchicalTopicDispatcher(state, topic, data, options);\n    }\n\n    return async(hierarchicalTopicDispatcher, args);\n  }\n\n  /**\n   *  `Arbiter.unsubscribe` removes the subscribers associated with a token or\n   *  a topic. This prevents them from being notified when a publication\n   *  occurs. By default these cannot be recovered, however this also allows\n   *  us to temporarily suspend them instead.\n   *\n   * @function unsubscribe\n   * @memberof Arbiter\n   *\n   * @param {Token|Topic} token Removes the subscription associated with the\n   *   provided token. If a topic is provided, then this removes all\n   *   subscribers and their descendants are removed.\n   * @param {Boolean} [suspend=false] If this true, then the subscriptions\n   *   are only suspended. This means that they will not be notified of any\n   *   publications, but they can be re-enabled with [Arbiter.resubscribe].\n   * @return {Boolean} Returns false if the token's subscription cannot be\n   *   located and true otherwise. This returns an array if multiple tokens\n   *   or topics used.\n   *\n   * @example\n   *\n   * Arbiter.subscribe('a', function a () {});\n   * Arbiter.subscribe('a.b', function ab () {});\n   * var bToken = Arbiter.subscribe('b', function b () {});\n   * Arbiter.subscribe('c', function c () {});\n   * Arbiter.unsubscribe(bToken); // 'a', 'a.b', 'c' remain\n   * Arbiter.unsubscribe('a'); // Only 'c' remains\n   * Arbiter.unsubscribe(''); // Removes all subscriptions\n   */\n  function unsubscribe (state, tokens, suspend) {\n    tokens = typeof tokens === 'string' ? tokens.split(/,\\s*/) : tokens;\n    tokens = !tokens.length ? [tokens] : tokens;\n\n    var result = curryMap(\n      {topics: state._topics, suspend: suspend}, removeSubscriber, tokens\n    );\n\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n   *  Reactivates all subscriptions associated with a token or all\n   *  subscriptions that are descendants of a topic.\n   *\n   * @function resubscribe\n   * @memberof Arbiter\n   *\n   * @param {Token|Topic} token The token or topic to reactivates\n   * @return {Boolean} Returns false if the token's subscription cannot be\n   *   located and true otherwise. This returns an array if multiple tokens\n   *   or topics used.\n   *\n   * @example\n   *\n   * Arbiter.subscribe('a, b, c', function() {}); // Create 3 listeners\n   * Arbiter.unsubscribe('', true); // Suspends all listeners\n   * Arbiter.resubscribe(''); // Resumes all listeners\n   */\n  function resubscribe (state, tokens) {\n    tokens = typeof tokens === 'string' ? tokens.split(/,\\s*/) : tokens;\n    tokens = !tokens.length ? [tokens] : tokens;\n\n    var result = curryMap(state._topics, unsuspendSubscriber, tokens);\n\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n   * Removes the publications that are stored (persisted) for late subscribers\n   * by providing either a `Token` or a `Topic`.\n   *\n   * @memberof Arbiter\n   * @param {Token|Topic} token The publication or topics to remove. Note: If\n   *   provided the [PublicationPromise], then this uses the token\n   *   associated with it.\n   * @return {Boolean} `false` if the topic or token does not exist, `true`\n   *   otherwise.\n   *\n   * @example\n   *\n   * Arbiter.publish('a', null, {persist: true});\n   * Arbiter.subscribe('a', function a1 () {}); // Executes a1\n   * Arbiter.removedPersisted();\n   * Arbiter.subscribe('a', function a2 () {}); // Does not execute a2\n   */\n  function removePersisted (topics, token) {\n    if (typeof token === 'string') {\n      return !!applyTopicDescendents(empty, 'persisted', token, topics);\n    }\n\n    var\n      tokenTopic = token.topic,\n      node = ancestorTopicSearch(tokenTopic, topics);\n\n    if (node.topic !== tokenTopic) {\n      return false;\n    }\n\n    var\n      id = token.id,\n      persisted = node.persisted,\n      i = binaryIndexBy(getId, id, node.persisted),\n      persistedMessage = persisted[i];\n\n    if (persistedMessage && persistedMessage.order === id) {\n      persisted.splice(i, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Creates a new instance of Arbiter that is completely separate from the\n   * original. It has its own set of topics, subscribers, and options.\n   *\n   * @function create\n   * @memberof Arbiter\n   *\n   * @return {Arbiter} The new instance.\n   *\n   * @example\n   *\n   * var arbiter = Arbiter.create();\n   * Arbiter.subscribe('a', function a () {});\n   * arbiter.publish('a'); // Does not execute a\n   */\n  function create () {\n    /**\n     * Arbiter has a few options to affect the way that subscribers are\n     * notified and PublicationPromises are resolved.\n     *\n     * @typedef Options\n     * @memberof Arbiter\n     *\n     * @property {boolean} persist=false When true, subscribers are notified\n     *   of past messages.\n     * @property {boolean} sync=false When true, invokes the subscription\n     *   functions synchronously.\n     * @property {boolean} preventBubble=false When true, only the topics\n     *   that match the published topics exactly are invoked.\n     * @property {number} latch=0.9999999999999999 When this number is less\n     *   than one, it is the ratio of subscribers that must fulfilled before\n     *   resolving the `PublicationPromise`. If greater or equal to one,\n     *   then it is a count of the subscribers that must fulfill.\n     * @property {boolean} settlementLatch=false Changes the resolving logic\n     *   of `PublicationPromise` to be based off resolved rather than\n     *   fulfilled promises. This means that failed subscribers will count\n     *   toward the tally of latch.\n     * @property {number} semaphor=Infinity The maximum number of subscribers\n     *   to allowed to be pending at any given point in time.\n     * @property {boolean} updateAfterSettlement=false If true, updates the\n     *   `PublicationPromise` after it resolves.\n     *\n     * @example\n     *\n     * Arbiter.subscribe('a', log);\n     * Arbiter.subscribe('a.b', log);\n     * Arbiter.subscribe('a.b.c', log);\n     * var promise = Arbiter.publish('a.b.c', {latch: 1});\n     *\n     * // Remeber publish is async by default?\n     * // promise.pending === 3;\n     * // promise.fulfilled === 0;\n     * // promise.rejected === 0;\n     */\n    var\n      topics = createNode(''),\n      options = {\n        persist: false,\n        sync: false,\n        preventBubble: false,\n        latch: 0.9999999999999999,\n        settlementLatch: false,\n        semaphor: Infinity,\n        updateAfterSettlement: false\n      },\n      arbiter = {\n        _topics: topics,\n        options: options,\n        version: 'v1.0.0',\n        id: mkGenerator(),\n        create: create\n      };\n\n    arbiter.subscribe = partial1(subscribeDispatcher, arbiter);\n    arbiter.publish = partial1(publish, arbiter);\n    arbiter.unsubscribe = partial1(unsubscribe, arbiter);\n    arbiter.resubscribe = partial1(resubscribe, arbiter);\n    arbiter.removePersisted = partial1(removePersistedDispatcher, arbiter);\n\n    return arbiter;\n  }\n\n  // *************************************************************************\n  //   Private Arbiter Data Structures Functions\n  // *************************************************************************\n\n  // Takes care of all the heavy lifting of publishing a message. This\n  // includes locating all topics, their subscribers, publishing the data and,\n  // if necessary, storing the message for late subscribers.\n  function hierarchicalTopicDispatcher (state, topic, data, options) {\n    var\n      lineage = findLineage(getTopic, isAncestorTopic, topic, state._topics),\n      topicNode = lineage[lineage.length - 1],\n      subscriptions = options.preventBubble\n        ? topicNode.topic === topic ? topicNode.subscriptions : []\n        : mergeBy(getFingerArrayPriority, map(getSubscriptions, lineage)),\n      fulfilledPromise = subscriptionDispatcher(\n        topic, data, options, subscriptions\n      );\n\n    if (options.persist) {\n      var id = state.id();\n\n      topicNode = addTopicLine(topic, topicNode);\n      topicNode.persisted.push(\n        {topic: topic, data: data, order: id}\n      );\n      fulfilledPromise.token = {\n        topic: topic,\n        id: id\n      };\n    }\n\n    return fulfilledPromise;\n  }\n\n  // Invokes the next set of subscriptions\n  function resumeSubscriptionDispatcher (\n    topic, data, options, subscriptions, resolver, fulfill, reject\n  ) {\n    var\n      promise = resolver.promise,\n\n      subscription;\n\n    for (\n      ;\n      resolver.i >= 0 && promise.pending < options.semaphor;\n      resolver.i -= 1\n    ) {\n      subscription = subscriptions[resolver.i];\n      if (!subscription.suspended) {\n        promise.pending += 1;\n        subscriptionInvoker(subscription, data, topic).then(fulfill, reject);\n      }\n    }\n  }\n\n  // Takes care of sending all the requests on their way\n  function removePersistedDispatcher (state, tokens) {\n    tokens = tokens && tokens.token || tokens || '';\n    tokens = typeof tokens === 'string' ? tokens.split(/,\\s*/) : tokens;\n    tokens = !tokens.length ? [tokens] : tokens;\n\n    var result = curryMap(state._topics, removePersisted, tokens);\n\n    return result.length === 1 ? result[0] : result;\n  }\n\n  // Invokes all the subscriptions according to `options` and returns a promise\n  // that resolves according to `options`.\n  function subscriptionDispatcher (topic, data, options, subscriptions) {\n    var\n      resolver = createResolver(),\n      fulfill = resolveUse('fulfilledValues', 'fulfilled', options, resolver),\n      reject = resolveUse('rejectedValues', 'rejected', options, resolver);\n\n    resolver.i = subscriptions.length - 1;\n    resolver.resume = {\n      topic: topic,\n      data: data,\n      subscriptions: subscriptions,\n      fulfill: fulfill,\n      reject: reject\n    };\n\n    resumeSubscriptionDispatcher(\n      topic, data, options, subscriptions, resolver, fulfill, reject\n    );\n    evaluateLatch(resolver, options);\n\n    return resolver.promise;\n  }\n\n  // Takes care all the bookkeeping work surrounding a subscriber resolving\n  // resolving.\n  function resolveUse (appendList, increment, options, resolver) {\n    return function resolveUseClosure (value) {\n      // TODO This should state.options('update..\n      // TODO look at all of options.xxxx\n      if (resolver.settled && !options.updateAfterSettlement) {\n        return;\n      }\n\n      var promise = resolver.promise;\n      resolver[appendList].push(value);\n      promise[increment] += 1;\n      promise.pending -= 1;\n\n      if (resolver.i >= 0) {\n        var resume = resolver.resume;\n\n        resumeSubscriptionDispatcher(\n          resume.topic, resume.data, options, resume.subscriptions,\n          resolver, resume.fulfill, resume.reject\n        );\n        return;\n      }\n\n      evaluateLatch(resolver, options);\n    };\n  }\n\n  // Resolves the latch according to `options`. Computes the hypothetical max\n  // and resolves if is not met.\n  function evaluateLatch (resolver, options) {\n    var\n      settlementLatch = options.settlementLatch,\n      latch = options.latch,\n      promise = resolver.promise,\n      fulfilled = promise.fulfilled,\n      pending = promise.pending,\n      rejected = promise.rejected,\n      settled = fulfilled + rejected,\n      maxFulfilled = fulfilled + pending,\n      total = fulfilled + pending + rejected;\n\n    if (resolver.settled) {\n      return resolver.settled;\n    }\n\n    if (!settlementLatch && latch >= 1 && maxFulfilled < latch\n      || !settlementLatch && latch < 1 && maxFulfilled / total < latch\n      || settlementLatch && latch >= 1 && total < latch\n      || settlementLatch && latch < 1 && total === 0\n    ) {\n      resolver.settled = true;\n      return resolver.reject(resolver.rejectedValues);\n    }\n\n    if (!settlementLatch && latch >= 1 && fulfilled >= latch\n      || !settlementLatch && latch < 1 && fulfilled / total >= latch\n      || settlementLatch && latch >= 1 && settled >= latch\n      || settlementLatch && latch < 1 && settled / total >= latch\n    ) {\n      resolver.settled = true;\n      return settlementLatch\n        ? resolver.fulfill(\n          resolver.fulfilledValues.concat(resolver.rejectedValues)\n        ) : resolver.fulfill(resolver.fulfilledValues);\n    }\n\n    return resolver.settled;\n  }\n\n  // Invokes a subscription with the required parameters and acts as an adapter\n  // for the different asynchronous mechanisms behavior. i.e. node-style\n  // callbacks and promises.\n  function subscriptionInvoker (subscription, data, topic) {\n    var result;\n\n    if (subscription.fn.length === 3) {\n      return new Promise(function promiseResolver (fulfill, reject) {\n        subscription.fn.call(\n          subscription.context, data, topic, function callback (err, succ) {\n            return err ? reject(err) : fulfill(succ);\n          }\n        );\n      });\n    }\n\n    try {\n      result = subscription.fn.call(subscription.context, data, topic);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    if (result && typeof result.then === 'function') {\n      return result;\n    }\n\n    return Promise.resolve(result);\n  }\n\n  // This coverts `topic`, which can represent multiple subscriptions and\n  // serializes them into individual topics for use with the `subscription`\n  function subscribeDispatcher (state, topic, subscriptions, options, context) {\n    topic = typeof topic === 'string' ? topic.split(/,\\s*/) : topic;\n    topic = topic && topic.length ? topic : [topic];\n\n    var result = curryMap(\n      [state, null, subscriptions, options, context],\n      subscribeTopicApplier,\n      topic\n    );\n\n    return result.length === 1 ? result[0] : result;\n  }\n\n  // This is (in combination with curryMap) is a hack to prevent us from\n  // creating a closures on every subscription.\n  function subscribeTopicApplier (args, topic) {\n    args[1] = topic;\n    return subscribe.apply(null, args);\n  }\n\n  // For all descendants of `topic` remove all elements of `node[property`.\n  function applyTopicDescendents (f, property, topic, topics) {\n    var node = ancestorTopicSearch(topic, topics);\n    if (node.topic === topic) {\n      return curryMap(property, f, descendents(node));\n    }\n\n    return null;\n  }\n\n  // Finds the subscription associated with a token and unsuspendes it.\n  // Returns false if it was removed and true it was unsuspended.\n  function unsuspendSubscriber (topic, token) {\n    if (typeof token === 'string') {\n      return !!applyTopicDescendents(\n        unsuspendTopic, 'subscriptions', token, topic\n      );\n    }\n\n    var node = ancestorTopicSearch(token.topic, topic);\n    if (node.topic !== token.topic) {\n      return false;\n    }\n\n    var i = searchAround(\n      getId, getPriority,\n      token.id, token.priority,\n      binaryIndexBy(getPriority, token.priority, node.subscriptions),\n      node.subscriptions\n    );\n\n    if (i === -1) {\n      return false;\n    }\n\n    return !!unsuspendNode(node.subscriptions[i]);\n  }\n\n  // Finds the subscription associated with a token and removes or suspends is.\n  // If the subscription associated with a token cannot be found then this\n  // returns false. This usually means that the token was already removed.\n  function removeSubscriber (args, token) {\n    var\n      topics = args.topics,\n      suspendSubs = args.suspend;\n\n    if (typeof token === 'string') {\n      return !!applyTopicDescendents(\n        suspendSubs ? suspendTopic : empty, 'subscriptions', token, topics\n      );\n    }\n\n    var node = ancestorTopicSearch(token.topic, topics);\n    if (node.topic !== token.topic) {\n      return false;\n    }\n\n    var i = searchAround(\n      getId, getPriority,\n      token.id, token.priority,\n      binaryIndexBy(getPriority, token.priority, node.subscriptions),\n      node.subscriptions\n    );\n\n    if (i === -1) {\n      return false;\n    }\n\n    if (suspendSubs) {\n      return !!suspendNode(node.subscriptions[i]);\n    }\n\n    return !!node.subscriptions.splice(i, 1);\n  }\n\n  // Finds the closest ancestor topic\n  function ancestorTopicSearch (topic, node) {\n    return ancestorSearch(getTopic, topic, isAncestorTopic, node);\n  }\n\n  // Takes a topic and an ancestor and adds all of the generations from the\n  // ancestor to the topic returning the topic that represents the node.\n  function addTopicLine (topic, ancestor) {\n    var\n      ancestorTopic = ancestor.topic,\n      additionalTopics = [];\n\n    if (ancestorTopic !== topic) {\n      // All of the generations to add seeded by the youngest existing ancestor\n      additionalTopics = reduce(\n        appendPrefixedTopic, [ancestorTopic],\n        topic.substr(ancestorTopic.length).replace(/^\\./, '').split('.')\n      );\n    }\n\n    // Add a node to the tree for each new topic\n    return addFamilyLine(\n      addChildTopic, map(createNode, additionalTopics.slice(1)), ancestor\n    );\n  }\n\n  // Adds a child to the tree sorted by the nodes topics. Note: The parameters\n  // are in the reverse order because the sole purpose of this function is to\n  // be fed into reduce.\n  function addChildTopic (tree, child) {\n    return addChild(getTopic, child, tree);\n  }\n\n  // Appends the fully qualified topic name to the array using the last\n  // element of the array. This array must have length 1. If it should start\n  // at the root, then the array should be [ '' ].\n  function appendPrefixedTopic (arr, topic) {\n    var prefix = arr[arr.length - 1] === ''\n      ? '' : arr[arr.length - 1] + '.';\n\n    arr.push(prefix + topic);\n    return arr;\n  }\n\n  // Finds the Ancestor of the specified topic or undefined\n  function isAncestorTopic (topic, node) {\n    var nodeTopic = getTopic(node);\n\n    return topic === nodeTopic\n      || startsWith(topic, nodeTopic + '.')\n      || nodeTopic === '';\n  }\n\n  // Given a fingerArray, return the order of current item\n  function getFingerArrayOrder (fingerArray) {\n    var item = getPointedFinger(fingerArray);\n    return item !== SYMBOL_NOTHING ? getOrder(item) : Infinity;\n  }\n\n  // Given a fingerArray, return the priority of current item\n  function getFingerArrayPriority (fingerArray) {\n    var item = getPointedFinger(fingerArray);\n    return item !== SYMBOL_NOTHING ? getPriority(item) : Infinity;\n  }\n\n  // Extracts the topic name from the provided node\n  function getTopic (node) {\n    return node.topic;\n  }\n\n  // Gets the order property from a persisted subscription\n  function getOrder (persistedSubscription) {\n    return persistedSubscription.order;\n  }\n\n  // Retrieves the persisted messages from a topic\n  function getPersisted (node) {\n    return node.persisted;\n  }\n\n  // Retrieves the id of an object\n  function getId (obj) {\n    return obj.id;\n  }\n\n  // Extracts the priority from a subscription\n  function getPriority (subscription) {\n    return subscription.priority;\n  }\n\n  // Produces the subscriptions from the provided node\n  function getSubscriptions (node) {\n    return node.subscriptions;\n  }\n\n  // Suspends all subscribers to a topic\n  function unsuspendTopic (prop, node) {\n    return map(unsuspendNode, node[prop]);\n  }\n\n  // Sets the suspend property to false\n  function unsuspendNode (node) {\n    node.suspended = false;\n    return node;\n  }\n\n  // Suspends all subscribers to a topic\n  function suspendTopic (prop, node) {\n    return map(suspendNode, node[prop]);\n  }\n\n  // Sets the suspend property to false\n  function suspendNode (node) {\n    node.suspended = true;\n    return node;\n  }\n\n  // Creates a resolver object that keeps track of promise related values\n  function createResolver () {\n    var\n      resolver = {\n        settled: false,\n        fulfilledValues: [],\n        rejectedValues: []\n      },\n      promise = new Promise(function promiseResolver (fulfill, reject) {\n        resolver.fulfill = fulfill;\n        resolver.reject = reject;\n      });\n\n    promise.fulfilled = 0;\n    promise.rejected = 0;\n    promise.pending = 0;\n    resolver.promise = promise;\n\n    return resolver;\n  }\n\n  // Creates a subscription object\n  function createSubscription (state, fn, options, context) {\n    return {\n      id: state.id(),\n      fn: typeof fn === 'function' ? fn : noop,\n      suspended: false,\n      priority: +options.priority || 0,\n      context: context || null\n    };\n  }\n\n  // Creates an empty node of the tree\n  function createNode (topic) {\n    return {topic: topic, subscriptions: [], children: [], persisted: []};\n  }\n\n  // *************************************************************************\n  //   Private Standard Data Structures Algorithms\n  // *************************************************************************\n\n  // Produces a path down the tree to a leaf of the ancestors of the topic\n  function findLineage (getValue, isAncestor, value, tree, path) {\n    path = path || [];\n\n    if (tree && isAncestor(value, tree)) {\n      path.push(tree);\n\n      var // The child is only correct if the children matches the value\n        childIndex = binaryIndexBy(getValue, value, tree.children), // exactly,\n        foundChild = tree.children[childIndex], // otherwise the index is where\n        child = foundChild && getValue(foundChild) === value // it would be\n          ? foundChild : tree.children[childIndex - 1]; // (i.e. One too high)\n\n      return findLineage(getValue, isAncestor, value, child, path);\n    }\n\n    return path;\n  }\n\n  // Searches a tree for the provided topic. If it cannot find\n  // a node with the topic, it returns the closest ancestor.\n  // `getValue(node) === value` means that the exact node was found\n  function ancestorSearch (getValue, value, isAncestor, tree) {\n    if (getValue(tree) === value) {\n      return tree;\n    }\n\n    var index = binaryIndexBy(getValue, value, tree.children);\n    var child1 = tree.children[index];\n    var child0 = tree.children[index - 1];\n\n    if (child1 && isAncestor(value, child1)) {\n      return ancestorSearch(getValue, value, isAncestor, child1);\n    }\n\n    if (child0 && isAncestor(value, child0)) {\n      return ancestorSearch(getValue, value, isAncestor, child0);\n    }\n\n    return tree;\n  }\n\n  // Produces an array of all the descendants of a node including itself. This\n  // means all children, grandchildren, great-grandchildren, etc...\n  function descendents (node) {\n    return reduce(appendDescendents, [node], node.children);\n  }\n\n  // Appends the descnedents of `next` to the array.\n  function appendDescendents (arr, next) {\n    return arr.concat(descendents(next));\n  }\n\n  // Each element of `line` is a node to add as a child to the previous\n  // element of `line` starting with `tree`\n  function addFamilyLine (addChildToTree, line, tree) {\n    return reduce(addChildToTree, tree, line);\n  }\n\n  // Adds a node child into the tree in order according to `getValue`\n  function addChild (getValue, newChild, tree) {\n    tree.children.splice(\n      binaryIndexBy(getValue, getValue(newChild), tree.children),\n      0, newChild\n    );\n\n    return newChild;\n  }\n\n  // In merge sort, two sorted array are combined to create a new sorted array\n  // with the contents of both. This is a generalization of 'merge' to n\n  // arrays and based on a computed function. O(n).\n  function mergeBy (getItemOrder, arrays) {\n    var\n      n = reduce(add, 0, map(getLength, arrays)),\n      result = new Array(n),\n      fingerArrays = map(mkFingerArray, arrays),\n\n      i, min;\n\n    for (i = 0; i < n; i++) {\n      min = minBy(getItemOrder, fingerArrays);\n\n      result[i] = getPointedFinger(min);\n      min.pointer += 1;\n    }\n\n    return result;\n  }\n\n  // Inserts an item in ascending order according to `getValue`.\n  function insert (getValue, item, list) {\n    var index = binaryIndexBy(getValue, getValue(item), list);\n\n    list.splice(index, 0, item);\n    return item;\n  }\n\n  // Searches all elements around `i` in `arr` that statisfy\n  // `conditionValue(elem) === conditionValue`. This will return and index\n  // such that `getValue(arr[i]) === value` or -1 if none can be found.\n  function searchAround (\n    getValue, getConditionValue, value, conditionValue, i, arr\n  ) {\n    var start = i;\n    var elm = arr[i];\n\n    while (elm && (\n      getValue(elm) !== value || getConditionValue(elm) !== conditionValue)\n    ) {\n      elm = arr[--i];\n    }\n\n    if (!elm || getValue(elm) !== value) {\n      i = Math.min(arr.length, start + 1);\n      elm = arr[i];\n    }\n\n    while (elm && (\n      getValue(elm) !== value || getConditionValue(elm) !== conditionValue)\n    ) {\n      elm = arr[++i];\n    }\n\n    if (!elm || getValue(elm) !== value) {\n      return -1;\n    }\n\n    return i;\n  }\n\n  // Locates an index to insert `item` that would keep `arr` sorted. This\n  // uses a binary search and has a worst and average case performance of\n  // O(lg n).\n  function binaryIndexBy (getValue, item, array) {\n    var\n      value = item,\n      low = 0,\n      high = array.length,\n      mid, elem;\n\n    while (low < high) {\n      // divide by two and floor\n      mid = low + high >>> 1;\n      elem = getValue(array[mid]);\n\n      if (elem < value) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n\n    return high;\n  }\n\n  // Finds the `minimum` element of an array according to the `valueComputer`\n  // function.\n  function minBy (valueComputer, list) {\n    var\n      idx = 0,\n      winner = list[idx],\n      computedWinner = valueComputer(winner),\n\n      computedCurrent;\n\n    while (++idx < list.length) {\n      computedCurrent = valueComputer(list[idx]);\n\n      if (computedCurrent < computedWinner) {\n        computedWinner = computedCurrent;\n        winner = list[idx];\n      }\n    }\n\n    return winner;\n  }\n\n  // Retrieves the element that is the current focus and apply a\n  function getPointedFinger (fArray) {\n    var\n      pointer = fArray.pointer,\n      array = fArray.array;\n\n    return array.length > pointer ? array[pointer] : SYMBOL_NOTHING;\n  }\n\n  // A finger list is a list with an additional pointer to an element.\n  function mkFingerArray (array) {\n    return {\n      pointer: 0,\n      array: array\n    };\n  }\n\n  // Creates a function that always returns a unique number\n  function mkGenerator () {\n    var i = -9007199254740992;\n    return function generator () {\n      return i++;\n    };\n  }\n\n  // Removes all elements of `node[property]`.\n  function empty (property, node) {\n    node[property].length = 0;\n    return node;\n  }\n\n  // A poor-mans ES6 Symbol. Comparing to this by reference to check for\n  // `Nothing` since `undefined` and `null` are valid values.\n  function SYMBOL_NOTHING () {}\n\n  // *************************************************************************\n  //   Private Utility Functions\n  // *************************************************************************\n\n  // Executes a function with the specified arguments asynchronously.\n  function async (f, args) {\n    new Promise(invoke).then(function asyncFulfill () {\n      return f.apply(null, args);\n    });\n  }\n\n  // Partially applies 1 argument to a function.\n  function partial1 (f, x) {\n    return function partiallyApplied1 () {\n      // Using slice or splice on `arguments` causes the function to be\n      // unoptimizable. Who doesn't like optimization?\n      var args = map(identity, arguments);\n\n      args.unshift(x);\n      return f.apply(null, args);\n    };\n  }\n\n  // Returns a new object will all the properties of `a` and `b` giving\n  // b the priority.\n  function merge (a, b) {\n    var result = {};\n    var x;\n\n    for (x in a) {\n      if (a.hasOwnProperty(x)) {\n        result[x] = a[x];\n      }\n    }\n\n    for (x in b) {\n      if (b.hasOwnProperty(x)) {\n        result[x] = b[x];\n      }\n    }\n\n    return result;\n  }\n\n  // Array.prototype.reduce has similar performance to Array.prototype.map, so\n  // we define a custom reduce function to increase performance\n  function reduce (f, seed, arr) {\n    var result = seed, i, n;\n    for (i = 0, n = arr.length; i < n; i++) {\n      result = f(result, arr[i]);\n    }\n    return result;\n  }\n\n  // A special version of map to get around the performance hit for creating\n  // closures as a form of currying\n  function curryMap (args, f, arr) {\n    var result = [], i, n;\n    for (i = 0, n = arr.length; i < n; i++) {\n      result.push(f(args, arr[i]));\n    }\n    return result;\n  }\n\n  // Array.prototype.map is supeeeeer slow. In fact, it is slower than a\n  // custom map function, which is usually slower than an inline for loop, but\n  // is more maintainable.\n  function map (f, arr) {\n    var result = [], i, n;\n    for (i = 0, n = arr.length; i < n; i++) {\n      result.push(f(arr[i]));\n    }\n    return result;\n  }\n\n  // Determines whether a string begins with the characters of another string,\n  // returning true or false as appropriate.\n  function startsWith (haystack, needle, startPosition) {\n    startPosition = startPosition || 0;\n    return haystack.lastIndexOf(needle, startPosition) === startPosition;\n  }\n\n  // Invokes the first argument as a function without any arguments. Useful\n  // for resolving promises immediately.\n  function invoke (f) {\n    f();\n  }\n\n  // Gets the length of arrays and array-like objects.\n  function getLength (x) {\n    return x.length;\n  }\n\n  // \"Simple\" JavaScript addition ;-)\n  function add (x, y) {\n    return x + y;\n  }\n\n  // The only automorphism that is its own isomorphism\n  function identity (x) {\n    return x;\n  }\n\n  // This does nothing\n  function noop () {\n  }\n\n  // Throws an error if value !=== expected. This is useful for input\n  // validation.\n  function assert (value, expected, method, type, identifier) {\n    if (value !== expected) {\n      throw new Error(method + ' only accepts ' + type + ' as ' + identifier);\n    }\n  }\n}));\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/promissory-arbiter/src/promissory-arbiter.js\n ** module id = 2\n ** module chunks = 0\n **/","\nvar Arbiter = require(\"promissory-arbiter\")\n\nvar WatchJS = require(\"watchjs\") \nvar watch = WatchJS.watch;\nvar unwatch = WatchJS.unwatch;\n\nArbiter.subscribe('mutations', function(payload){\n  var mutation = payload['mutation'];\n  var value = payload['value'];  \n  console.log(mutation, mutations[mutation]);\n  mutations[mutation](value);\n});\n\n\nvar guid = function() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n    s4() + '-' + s4() + s4() + s4();\n}\n\nvar store =  {\n    profile:{'username':null},\n    modals:{\n      'registration':{\n        'name':'registration',\n        'title':'Create your account',\n        'content':'store.forms.registration',\n        'buttons':[\n          {\n            'name':'Submit',\n            'action':'submit_registration',\n            'color':'blue',\n            'state':'pristine'\n          },\n          {\n            'name':'Cancel',\n            'action':'deactive_registration',\n            'color':'red',\n            'state':'pristine'\n          }\n          ],\n        'state':'inactive'\n      },\n      'login':{\n        'name':'login',\n        'title':'Login to your account',\n        'content':'store.forms.login',\n        'buttons':[\n          {\n            'name':'Submit',\n            'action':'submit_login',\n            'color':'blue',\n            'state':'pristine'\n          },\n          {\n            'name':'Cancel',\n            'action':'deactive_login',\n            'color':'red',\n            'state':'pristine'\n          }\n          ],\n        'state':'inactive'\n      }\n    },\n    forms:{\n      'registration':{\n        'title': 'Create your account',\n        'name':'registration',\n        'fields':[\n          {\n            'label':'First Name',\n            'name':'firstname',\n            'input_type':'text',\n            'placeholder':'Enter your first name',\n            'valid':true,\n            'pristine':true,\n            'error':null,\n            'value':null\n          },\n          {\n            'label':'Last Name',\n            'name':'lastname',\n            'input_type':'text',\n            'placeholder':'Enter your last name',\n            'valid':true,\n            'pristine':true,\n            'error':null,\n            'value':null\n          },\n          {\n            'label':'Username',\n            'name':'username',\n            'input_type':'text',\n            'placeholder':'Enter a username for this account',\n            'valid':true,\n            'pristine':true,\n            'error':null,\n            'value':null\n          },\n          {\n            'label':'Password',\n            'name':'password',\n            'input_type':'password',\n            'placeholder':'Enter your password',\n            'valid':true,\n            'pristine':true,\n            'error':null,\n            'value':null\n          },\n          {\n            'label':'Confirm password',\n            'name':'confirm_password',\n            'input_type':'password',\n            'placeholder':'Confirm your password',\n            'valid':true,\n            'pristine':true,\n            'error':null,\n            'value':null\n          },\n          {\n            'label':'Mobile',\n            'name':'mobile',\n            'input_type':'text',\n            'placeholder':'Enter your mobile number',\n            'valid':true,\n            'pristine':true,\n            'error':null,\n            'value':null\n          },\n          {\n            'label':'Email',\n            'name':'email',\n            'input_type':'email',\n            'placeholder':'Enter your email address',\n            'valid':true,\n            'pristine':true,\n            'error':null,\n            'value':null\n          },\n        ],\n        'action':'submit_registration', \n        'state':'pristine'\n    },\n    'login':{\n        'title': 'Login to your account',\n        'name':'login',\n        'fields':[\n          {\n            'label':'Username',\n            'name':'username',\n            'input_type':'text',\n            'placeholder':'Enter your username',\n            'valid':true,\n            'pristine':true,\n            'error':null,\n            'value':null\n          },\n          {\n            'label':'Password',\n            'name':'password',\n            'input_type':'password',\n            'placeholder':'Enter your password',\n            'valid':true,\n            'pristine':true,\n            'error':null,\n            'value':null\n          },\n        ],\n        'action':'submit_login', \n        'state':'pristine'\n    }\n     },\n     registration_flow: {\n      'registration_submitted':false,\n      'registration_sent_remote':false,\n      'registration_failed':{'status':false, 'message':null},\n      'registration_succeeded':false\n    },\n    authentication_flow: {\n      'login_submitted':false,\n      'login_sent_remote':false,\n      'login_failed':{'status':false, 'message':null},\n      'login_succeeded':false\n    },\n    macaroon:null,\n    remote_requests: [],\n    credentials: {\n      'username':null,\n      'password':null\n    },\n    authenticated:false,\n    route:'/',\n    routes: {},\n    startup_selected_or_created: 'selected',\n  }\n\nexports.store = store;\n\nvar mutations = {  \n    change_registration_state: function(value){\n      console.log('mutations---> change_registration_state', value);\n      var new_state = value['state']; \n      store.registration_flow[new_state] = true;\n      if (new_state=='registration_submitted'){\n        store.registration_flow['registration_submitted'] = true;\n      } \n      if (new_state=='registration_succeeded'){\n        store.registration_flow['registration_succeeded'] = true;\n      }\n      if (new_state=='registration_failed'){\n        store.registration_flow['registration_failed'] = {'status':true, 'message':value['value']['message']};\n      }\n    },\n    update_modal_state: function(value){\n      var modal_name = value['value']['modal_name'];\n      console.log('mutations---> change', modal_name,store.modals[modal_name]);\n      // if (modal_name=='registration'){\n        store.modals[modal_name].state = value['value']['modal_state'];\n      // }\n    },\n    change_form_state: function(value){\n\n    },\n    update_form: function(value){\n      console.log('mutations---> update_form', value['value']);\n      var payload = value['value'];\n      var form = store.forms[payload['form']];\n      console.log(store.forms[payload['form']]);\n      for (var i = 0; i <form.fields.length; i++){\n        if (form.fields[i].name==payload['field']){\n          console.log('found a field match', form.fields[i]);\n          form.fields[i]['value'] = payload['value'];\n        }\n      };\n      console.log(form);\n    },\n    change_login_state: function(value){\n      console.log('mutations---> change_login_state', value);\n      var new_state = value['state']; \n      store.authentication_flow[new_state] = true;\n      if (new_state=='login_submitted'){\n        store.credentials['username'] = value['credentials']['username'];\n        store.credentials['password'] = value['credentials']['password'];\n      } \n      if (new_state=='login_succeeded'){\n        store.profile.username=value['value']['username'];\n      }\n      if (new_state=='login_failed'){\n        console.log('FAILLLLLLLEEEEEDDDDDDD', value['value']);\n        store.authentication_flow['login_failed'] = {'status':true, 'message':value['value']['message']};\n      }\n    },\n    update_macaroon: function(value){\n      store.macaroon = value['value'];\n    },\n    change_route: function(value) {\n      console.log('mutations---> change route');\n      store.route = value['route'];\n    },\n    set_selected_or_created: function (value ) {\n      store.startup_selected_or_created = value;\n    },\n    add_job_id: function(payload){\n      console.log('mutations---> add_job_id', payload);\n      var job_id = payload.value.job_id;\n      var request_id = payload.value.request_id;\n      console.log(store.remote_requests, request_id);\n      for (var n = 0; n <store.remote_requests.length; n++){\n        if (store.remote_requests[n]['request_id']==request_id){\n          console.log(request_id, 'matched');\n          var obj = {}\n          obj.request_id = request_id;\n          obj.job_id = job_id;\n          obj.status = 'pending';\n          obj.action = store.remote_requests[n]['action'];\n          obj.success = store.remote_requests[n]['success'];\n          obj.failed = store.remote_requests[n]['failed'];\n          // store.remote_requests[n] = obj;\n          store.remote_requests.splice(n, 1);\n          console.log('deleted---->', store.remote_requests);\n          store.remote_requests.push(obj);\n\n\n          console.log('add_job_id---->', store.remote_requests);\n        }\n      }\n    },\n    created_job_request: function(payload) {\n      console.log('payload', payload);\n      var action = payload.state;\n      var success = payload.value.success;\n      var failed = payload.value.failed;\n      console.log(success, failed)\n      // new_request_id = generates a new id for the request\n      var uuid = guid();\n\n      var obj = {};\n      obj.request_id = uuid;\n      obj.status = 'blank';\n      obj.payload = payload.value.payload;\n      obj.success = success;\n      obj.failed = failed;\n      obj.action = action;\n      console.log(obj);\n      store.remote_requests.push(obj);\n\n      console.log('remote_requests---->', store.remote_requests);\n    },\n\n    set_job_as_fulfilled: function(payload){\n      console.log('fulfilled', payload.value);\n      var job_id = payload.value.job_id;\n      for (var n = 0; n <store.remote_requests.length; n++){\n        if (store.remote_requests[n]['job_id']==job_id){\n\n          var obj = {};\n          obj.request_id = payload.value.request_id;\n          obj.job_id = job_id;\n          obj.status = 'done';\n          obj.message = payload.value.message;\n          obj.status_code = payload.value.status_code;\n          obj.payload = payload.value.payload;\n          obj.action = store.remote_requests[n]['action'];\n          obj.success = store.remote_requests[n]['success'];\n          obj.failed = store.remote_requests[n]['failed'];\n\n          store.remote_requests.splice(n, 1);\n          console.log('deleted---->', store.remote_requests);\n          store.remote_requests.push(obj);\n          console.log('job fulfilled ---->', store.remote_requests);\n        }\n      }\n    }\n  }\n\nwatch(store, 'registration_flow', function(prop, action, newvalue, oldvalue){\n  console.log(prop, action, newvalue, oldvalue);\n  if (prop=='registration_submitted'){\n    Arbiter.publish('registration_flow', {'prop':prop, 'oldvalue':oldvalue, 'newvalue':newvalue, 'registration_credentials':store['credentials']});\n  } else {\n    Arbiter.publish('registration_flow', {'prop':prop, 'oldvalue':oldvalue, 'newvalue':newvalue});    \n  }\n});\n\nwatch(store, 'authentication_flow', function(prop, action, newvalue, oldvalue){\n  console.log(prop, action, newvalue, oldvalue);\n  if (prop=='login_submitted'){\n    Arbiter.publish('authentication_flow', {'prop':prop, 'oldvalue':oldvalue, 'newvalue':newvalue, 'login_credentials':store['credentials']});\n  } else {\n    Arbiter.publish('authentication_flow', {'prop':prop, 'oldvalue':oldvalue, 'newvalue':newvalue});    \n  }\n});\n\nwatch(store, 'profile', function(prop, action, newvalue, oldvalue){\n  console.log('profile watch--->',prop, action, newvalue, oldvalue);\n  Arbiter.publish('profile', {'prop':prop, 'oldvalue':oldvalue, 'newvalue':newvalue});\n});\n\nwatch(store.modals.login, function(prop, action, newvalue, oldvalue){\n  console.log('login modal watch--->',prop, action, newvalue, oldvalue);\n  if (newvalue=='active'){\n    Arbiter.publish('activate_login_modal', {'oldvalue':oldvalue, 'newvalue':newvalue});\n  }\n  if (newvalue=='inactive'){\n    Arbiter.publish('deactivate_login_modal', {'oldvalue':oldvalue, 'newvalue':newvalue});    \n  }\n}, 2);\n\nwatch(store.modals.registration, function(prop, action, newvalue, oldvalue){\n  console.log('registration modal watch--->',prop, action, newvalue, oldvalue);\n  if (newvalue=='active'){\n    Arbiter.publish('activate_registration_modal', {'oldvalue':oldvalue, 'newvalue':newvalue});\n  }\n  if (newvalue=='inactive'){\n    Arbiter.publish('deactivate_registration_modal', {'oldvalue':oldvalue, 'newvalue':newvalue});    \n  }\n}, 2);\n\n\nwatch(store, 'macaroon', function(prop, action, newvalue, oldvalue){\n  console.log('macaroon watch--->',prop, action, newvalue, oldvalue);\n  Arbiter.publish('macaroon', {'prop':prop, 'oldvalue':oldvalue, 'newvalue':newvalue});\n});\n\nwatch(store, 'remote_requests', function(prop, action, newvalue, oldvalue){\n  console.log('remote requests watch--->',prop, action, newvalue, oldvalue);\n  Arbiter.publish('remote_requests', {'prop':prop, 'oldvalue':oldvalue, 'newvalue':newvalue[0]});\n});\n\nwatch(store, 'jobs', function(prop, action, newvalue, oldvalue){\n  console.log('watch',prop, action, newvalue, oldvalue);\n  Arbiter.publish('jobs', {'prop':prop, 'oldvalue':oldvalue, 'newvalue':newvalue});\n});\n\nwatch(store, 'fulfilled_jobs', function(prop, action, newvalue, oldvalue){\n  console.log(prop, action, newvalue, oldvalue);\n  Arbiter.publish('fulfilled_jobs', {'prop':prop, 'oldvalue':oldvalue, 'newvalue':newvalue});\n});\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./store/index.js\n **/","var Arbiter = require(\"promissory-arbiter\");\n\nvar Store = require(\"../store/index.js\");\n\n\nriot.tag2('anon_homepage', '<topnav></topnav> <div class=\"ui two column centered grid container\"> <div class=\"column\"> <div class=\"ui basic segment\"> <signuporsignin></signuporsignin> </div> </div> </div> <modal data=\"{login_modal}\" content=\"{login_form}\"> <tsform data=\"{data}\" content=\"{content}\"></tsform> </modal> <modal data=\"{registration_modal}\"></modal>', '', '', function(opts) {\n\n  \tvar self = this;\n\n  \tthis.on(\"update\", function(){\n\n  \t\tself.login_form = Store.store.forms.login;\n  \t\tconsole.log(\"loginform\", self.login_form);\n  \t\tself.login_modal = Store.store.modals.login;\n  \t\tself.registration_modal = Store.store.modals.registration;\n  \t\tconsole.log(\"anon_homepage----\", this.registration_modal);\n  \t})\n\n  \tthis.on('mount', function(){\n\t  \t// this.registration_modal = Store.store.modals.registration;\n\t  \t// console.log(\"MODAL\", Store.store.modals.registration);\n  \t});\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/anon_homepage.tag\n **/","riot.tag2('app', '<router></router> <control></control> <job></job> <poller></poller>', '', '', function(opts) {\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/app.tag\n **/","var Arbiter = require(\"promissory-arbiter\")\n\nriot.tag2('control', '', '', '', function(opts) {\n\n\nArbiter.subscribe('authentication_flow', function(value){\n  \t\t\t  \tvar prop = value['prop'];\n\t\t\t\tconsole.log('control tag --->',value);\n\t\t\t\tif (prop=='login_submitted'){\n  \t\t\t  \tvar login_credentials = value['login_credentials'];\n  \t\t\t  \tvar value = value['newvalue'];\n  \t\t\t  \tconsole.log('login_credentials', login_credentials);\n\t\t\t\tArbiter.publish('actions', {'action':'submit_login_remote', 'value':{'payload':login_credentials, 'success':'login_succeeded', 'failed':'login_failed'}});\n\t\t\t\t}\n\n  \t\t\t  });\n\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/control.tag\n **/","riot.tag2('drafteditpage', '<div class=\"ui container\"> <div class=\"{row:true, hide:data.view==\\'investor\\'||data.steps.display==false, show:data.view==\\'founder\\'&&data.steps.display==true}\"> <div class=\"{ui:true, text:true, small:true, grey:data.menutheme.color==\\'grey\\', teal:data.menutheme==\\'teal\\', blue:data.menutheme.color==\\'blue\\', red:data.menutheme==\\'red\\', inverted:data.menutheme.inverted, right:true, menu:true, show:steps.display, hide:steps.display==false}\"> <div class=\"right menu\"> <div class=\"item\"> <div class=\"ui small basic button\">Back</div> </div> <div class=\"item\"> <div class=\"ui small {data.menutheme.color} button\">Done</div> </div> </div> </div> <div class=\"{ui:true, four:true, column:true, grid:true}\"> <div class=\"{five:true, wide:true, column:true, show:data.steps.display, hide:data.steps.display==false}\"> <step steps=\"{data.steps.items}\" vertical=\"{data.steps.vertical}\"></step> </div> <div class=\"{eleven:data.steps.display==true, wide:true, column:true}\"> <div class=\"{ui:true, column:true, grid:true, show:data.active_step==\\'startup\\', hide:data.active_step!=\\'startup\\'}\"> <div class=\"column\"> <div class=\"ui segment\"> <div class=\"row\"> <startup></startup> </div> </div> </div> </div> <div class=\"{ui:true, column:true, grid:false, show:data.active_step==\\'tractionedit\\', hide:data.active_step!=\\'tractionedit\\'}\"> <div class=\"column\"> <tractionedit data=\"{data}\"></tractionedit> </div> </div> <div class=\"{ui:true, column:true, grid:true, show:data.active_step==\\'team\\', hide:data.active_step!=\\'team\\'}\"> <div class=\"column\"> <team></team> </div> </div> <div class=\"{ui:true, column:true, grid:true, show:data.active_step==\\'commercials\\', hide:data.active_step!=\\'commercials\\'}\"> <div class=\"column\"> <commercials></commercials> </div> </div> <div class=\"{ui:true, column:true, grid:true, show:data.active_step==\\'share\\', hide:data.active_step!=\\'share\\'}\"> <div class=\"column\"> <share data=\"{data}\" share=\"{data.share}\" steps=\"{data.steps}\"></share> </div> </div> <div class=\"{ui:true, text:true, small:true, grey:data.menutheme.color==\\'grey\\', teal:data.menutheme==\\'teal\\', blue:data.menutheme.color==\\'blue\\', red:data.menutheme==\\'red\\', inverted:data.menutheme.inverted, right:true, menu:true, show:steps.display, hide:steps.display==false}\"> <div class=\"right menu\"> <div class=\"item\"> <div class=\"ui small basic button\">Back</div> </div> <div class=\"item\"> <div class=\"ui small {data.menutheme.color} button\">Done</div> </div> </div> </div> </div> </div> </div> </div>', '', '', function(opts) {\n\n    this.data={}\n\n    this.data.dropdownobservable = riot.observable()\n\n    console.log(opts.data)\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/drafteditpage.tag\n **/","var Arbiter = require(\"promissory-arbiter\");\n\nriot.tag2('homepage', '<macaroon></macaroon> <div class=\"{hide:authenticated==false}\"> <loggedin_homepage profile=\"{profile}\"></loggedin_homepage> </div> <div class=\"{hide:authenticated==true}\"> <anon_homepage></anon_homepage> </div>', '', '', function(opts) {\n\n\tvar self = this;\n\n\tvar login_failed = false;\n\n\tvar login_succeeded = false;\n\n\tthis.authenticated = false;\n\n\tthis.profile = {};\n\n\tArbiter.subscribe('authentication_flow', function(value){\n\t\tself.update(value);\n\t});\n\n\tArbiter.subscribe('authentication_flow', function(value){\n  \t\t\t  \tvar prop = value['prop'];\n\t\t\t\tconsole.log('control tag --->',value);\n\t\t\t\tif (prop=='login_succeeded'){\n\t\t\t\t\tself.authenticated = true;\n\t\t\t\t\tself.update();\n\t\t\t\t}\n  \t\t\t  });\n\n\tArbiter.subscribe('profile', function(value){\n  \t\t\t  \tvar prop = value['prop'];\n\t\t\t\tconsole.log('control tag --->',value);\n\t\t\t\tif (prop=='username'){\n\t\t\t\t\tself.profile.username = value['newvalue'];\n\t\t\t\t\tself.update();\n\t\t\t\t}\n  \t\t\t  });\n\n\tthis.on('update', function(value){\n\t\tif (value==undefined){}else{\n\t\t\tvar authentication_flow = value;\n\t\t\tvar succeeded_or_failed = false;\n\t\t\tif (authentication_flow['login_failed']){\n\t\t\t\tsucceeded_or_failed = true;\n\t\t\t}\n\t\t  \tif (authentication_flow['login_submitted']==true&&succeeded_or_failed==false){\n\t\t  \t\tself.loading = true;\n\t\t  \t} else {\n\t\t  \t\tself.loading = false;\n\t\t  \t}\n\t\t}\n\n\t  });\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/homepage.tag\n **/","var Arbiter = require(\"promissory-arbiter\");\n\nvar guid = function() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n    s4() + '-' + s4() + s4() + s4();\n}\n\nriot.tag2('job', '', '', '', function(opts) {\n\n\tvar self = this;\n\n\tself.uuid = guid()\n\n\tself.remote_requests = [];\n\n\tself.macaroon = null;\n\n\tself.api = {\n\t\t'submit_login_remote': {'type':'POST', 'url':'http://api.termsheet.io/login/'}\n\t}\n\n\tArbiter.subscribe('remote_requests', function(value, store){\n\n\t\tvar new_job_id = null;\n\n\t\tconsole.log(store, value['newvalue']);\n\n\t\tif (value['newvalue']['status']=='blank'){\n\t\t\tvar request_id = value['newvalue']['request_id'];\n\t\t  \t// get the latest job requests from the remote_request store\n\n\t\t  \t var payload = value['newvalue']['payload'];\n\t\t  \t console.log('action', value['newvalue']['action'], 'payload',payload);\n\t\t  \t self.remote_requests.push(request_id);\n\t\t  \t console.log(self.api[value['newvalue']['action']]);\n\t\t  \t// send the remote request to the server\n\t\t  \t$.ajax({\n\t\t\t  type: self.api[value['newvalue']['action']]['type'],\n\t\t\t  url: self.api[value['newvalue']['action']]['url'],\n\t\t\t  dataType: 'json',\n\t\t\t  contentType: 'application/json',\n\t\t\t  async: true,\n\t\t\t  headers: {\n\t\t\t    \"Authorization\": self.macaroon\n\t\t\t  },\n\t\t\t  data: JSON.stringify(payload),\n\t\t\t  success: function (data){\n\t\t\t    console.log(data);\n\t\t\t    new_job_id = data['job_id'];\n\t\t\t  }\n\t\t\t});\n\t\t  \t// get back a job id\n\t\t\t// var new_job_id = guid()\n\n\t\t  \t// update store with the job id\n\t\t  \tArbiter.publish('actions', {'action':'add_job_id', 'value':{'job_id':new_job_id, 'request_id':request_id}});\n\n\t\t}\n\n\t\tif (value['newvalue']['status']=='done'){\n\t\t\tvar success=false;\n\t\t\tif (value['newvalue']['status_code']==200){\n\t\t\t\tsuccess=true;\n\t\t\t}\n\t\t\tif (success==true){\n\t\t\t\tvar event = value['newvalue']['success'];\n\n\t\t\t}else {\n\t\t\t\tvar event = value['newvalue']['failed'];\n\t\t\t}\n\n\t\t\tArbiter.publish('actions', {'action':event, 'value':value['newvalue']});\n\n\t\t}\n\n  });\n\n\t\tArbiter.subscribe('macaroon', function(value){\n\t\tself.macaroon = value['newvalue'];\n\t\tconsole.log('macaroon_received', self.macaroon);\n\t});\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/job.tag\n **/","riot.tag2('loggedin_homepage', '<div>{profile.username}</div>', '', '', function(opts) {\n\n\tvar self = this;\n\n\tthis.profile = opts.profile;\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/loggedin_homepage.tag\n **/","var Arbiter = require(\"promissory-arbiter\");\n\n\n\nriot.tag2('login', '<div class=\"ui segment\"> <form class=\"ui form\" id=\"signinForm\" onsubmit=\"{loginUser}\"> <h4 class=\"ui dividing header\">Login</h4> <div> <div class=\"field\"> <label>Username</label> <input type=\"text\" name=\"username\" placeholder=\"username\"> </div> <div class=\"field\"> <label>Password</label> <input type=\"password\" name=\"password\" placeholder=\"password\"> </div> <button __disabled=\"{this.loading}\" class=\"{loading: this.loading, ui: true, primary:true, button: true}\" type=\"submit\" form=\"signinForm\" value=\"Submit\">Login</button> <div class=\"{hide:message==null}\">{message}</div> </div> </form> </div>', '', '', function(opts) {\n  \t\t\t  var self = this\n\n  \t\t\t  this.loading = false;\n\n  \t\t\t  this.message = null;\n\n  \t\t\t  this.loginUser = function(){\n  \t\t\t  \tconsole.log(this.username.value);\n  \t\t\t  \tconsole.log('loginUser--->', self.username.value);\n  \t\t\t  \t var login_credentials = {username: self.username.value, password:self.password.value};\n  \t\t\t  \t // Action is submit_login and store's state is authentication_flow\n  \t\t\t  \t Arbiter.publish('actions', {'action':'submit_login', 'value':login_credentials});\n  \t\t\t  }\n\n\t\t\tArbiter.subscribe('authentication_flow', function(value){\n\t\t\tconsole.log('login.tag got data--->',value);\n  \t\t\t  \tvar prop = value['prop'];\n  \t\t\t  \tvar value = value['newvalue'];\n\t\t\t\tif (prop=='login_submitted'){\n\t\t\t\t\tself.loading = value;\n\t\t\t\t}\n\t\t\t\tif (prop=='login_succeeded'){\n\t\t\t\t\tself.loading = false;\n\t\t\t\t}\n\t\t\t\tif (prop=='login_failed'){\n\t\t\t\t\tself.loading = false;\n\t\t\t\t\tself.message = value['message'];\n\t\t\t\t}\n\t\t\t\tself.update();\n  \t\t\t  });\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/login.tag\n **/","var Arbiter = require(\"promissory-arbiter\");\nriot.tag2('macaroon', '', '', '', function(opts) {\n\n\tvar self = this;\n\n\tthis.on('mount', function(){\n\n\t\t$.get('http://api.termsheet.io/get_anonymous_token/', function(value){\n\t\t\tconsole.log(value);\n\t\t\tArbiter.publish('actions', {'action':'macaroon_received', 'value':value['Authorization']});\n\t\t});\n\n\t})\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/macaroon.tag\n **/","var Arbiter = require(\"promissory-arbiter\");\nriot.tag2('modal', '<div id=\"{id}\" class=\"{ui:true, small:true, modal:true}\"> <i onclick=\"{cancelModal}\" class=\"close icon\"></i> <div class=\"header\"> {data.title} </div> <div class=\"{image:image_src, content:true}\"> <yield></yield> </div> <div class=\"actions\"> <div each=\"{data.buttons}\" class=\"{ui:true, button:true, blue:color==\\'blue\\', red:color==\\'red\\'}\" onclick=\"{buttonAction(action)}\">{name}</div> </div> </div>', '', '', function(opts) {\n\n\tvar self = this;\n\tthis.content = this.opts.content;\n\tthis.data = this.opts.data;\n\tthis.small = this.opts.data;\n\n\tthis.active = false;\n\n\tvar guid = function() {\n\t  function s4() {\n\t    return Math.floor((1 + Math.random()) * 0x10000)\n\t      .toString(16)\n\t      .substring(1);\n\t  }\n\t  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n\t    s4() + '-' + s4() + s4() + s4();\n\t}\n\n\tthis.id = guid();\n\n\tthis.on(\"update\", function(){\n\n\t\tself.content = self.opts.content;\n\t\tself.data = self.opts.data;\n\t\tconsole.log('this.content', this.opts);\n\n\t\tself.name = self.opts.data.name;\n\t\tself.title = self.opts.data.title;\n\t\tself.image_src = self.opts.data.image_src;\n\t\tself.image_description = self.opts.data.image_description;\n\t\tself.modal = $('#'+self.id);\n\n\t});\n\n\tthis.on(\"mount\", function(){\n\n\t\t// opens the specific modal\n\t\tself.modal_name = \"activate_\"+self.name+\"_modal\";\n\t\tself.hide_modal_name = \"deactivate_\"+self.name+\"_modal\";\n\n\t\tArbiter.subscribe(self.modal_name, function(){\n\t\t\tconsole.log('show', self.opts.data, self.modal, self.modal_name);\n\t\t\t// self.showModal();\n\t\t\t// self.update();\n\t\t\t$('#'+self.id).modal('show');\n\t\t\t});\n\n\t\tArbiter.subscribe(self.hide_modal_name, function(){\n\t\t\tconsole.log('hide', self.opts.data, self.modal, self.hide_modal_name);\n\t\t\t// self.hideModal();\n\t\t\t// self.update();\n\t\t\t$('#'+self.id).modal('hide');\n\t\t});\n\n\t});\n\n\tthis.cancelModal = function(){\n\t\tArbiter.publish('actions', {'action':'deactivate_modal', 'value':{'modal_name':self.name, 'modal_state':'inactive'}});\n\t}\n\n\tthis.buttonAction = function(action){\n\t\tconsole.log(action);\n\t\tArbiter.publish('actions',{'action':action, 'value':{}});\n\t}\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/modal.tag\n **/","riot.tag2('only-logo', '<img src=\"img/log.png\">', '', '', function(opts) {\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/only-logo.tag\n **/","var Arbiter = require(\"promissory-arbiter\")\n\nriot.tag2('poller', '', '', '', function(opts) {\n\n\tvar self = this;\n\n\tself.macaroon = null;\n\n\t\tArbiter.subscribe('macaroon', function(value){\n\t\tself.macaroon = value['newvalue'];\n\t\tconsole.log('macaroon_received', self.macaroon);\n\t\tvar poller = self.startPoller();\n\t});\n\n\tthis.startPoller = function(){\n\t\tvar payload = null;\n\t\tvar x = setInterval(function(){\n\t\t\t$.ajax({\n\t\t\t  type: 'GET',\n\t\t\t  url: 'http://api.termsheet.io/data.json',\n\t\t\t  dataType: 'json',\n\t\t\t  contentType: 'application/json',\n\t\t\t  async: true,\n\t\t\t  headers: {\n\t\t\t    \"Authorization\": self.macaroon\n\t\t\t  },\n\t\t\t  success: function (data){\n\t\t\t    console.log(data);\n\t\t\t    if (data.length>0){\n\n\t\t\t      \tfor (var i = 0; i <data.length; i++){\n\t\t\t      \t\tconsole.log('0------', data[i][Object.keys(data[i])[0]]);\n\t\t\t      \t\tvar obj = data[i][Object.keys(data[i])[0]];\n\t\t\t      \t\tvar job_id = obj['job_id'];\n\t\t\t      \t\tvar status_code = obj['status_code'];\n\t\t\t      \t\tvar payload = obj['payload'];\n\t\t\t      \t\tvar message = obj['messsage'];\n\t\t\t      \t\tconsole.log(job_id, message, payload);\n\n\t\t\t\t\t    Arbiter.publish('actions', {'action':'set_job_as_fulfilled', 'value': {'value':obj} })\n\t\t\t\t\t}\n\n\t\t\t    }\n\t\t\t  }\n\t\t\t});\n\t\t}, 4000);\n\t\treturn x;\n\t}\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/poller.tag\n **/","var Arbiter = require(\"promissory-arbiter\");\n\nriot.tag2('router', '<div id=\"app\"></div>', '', '', function(opts) {\n\n\tvar self = this;\n\n\tvar routes = {'/': 'homepage', '/create': 'drafteditpage'};\n\tconsole.log('routes--->',routes);\n\n\tthis.currentPage = null;\n\tconsole.log(\"this.currentPage-->\",this.currentPage);\n\n\tvar goTo = function(page){\n\t\tconsole.log(\"goTo-->\",page, self.currentPage);\n\t  if (self.currentPage) {\n\t  \tconsole.log(\"goTo if self.currentPage-->\",self.currentPage);\n\t    self.currentPage.unmount(true); //unmount and keep parent tag\n\t  }\n\t  self.currentPage = riot.mount('#app', page)[0];\n\t console.log(\"goTo mounted this.currentPage-->\",self.currentPage);\n\t  // console.log(self.currentPage); //remember current page\n\t};\n\n\tArbiter.subscribe('route', function(state_value){\n\t\tconsole.log(\"riotux.subscribe-->\", state_value);\n\t\tself.update(state_value);\n\t})\n\n\tthis.on('update', function(new_route){\n\t\tconsole.log(\"update-->\");\n\t\tvar oldroute = self.route;\n\t\tif (new_route==undefined){\n\t\t\tnew_route = '/';\n\t\t}\n\t\tself.route = new_route;\n\t\tconsole.log(\"update self.route-->\",self.route, routes[self.route]);\n\t\tgoTo(routes[self.route]);\n\t\triot.route(self.route)\n\t})\n\n\tthis.on('mount', function(){\n\t\tconsole.log(\"this.on('mount')-->\");\n\t\tself.route = '/';\n\t\tconsole.log(\"this.on('mount')\", self.currentPage, routes[self.route]);\n\t\tgoTo(routes[self.route]);\n\t\triot.route.start(true)\n\t})\n\n\tthis.on('unmount', function(){\n\t\triot.route.stop()\n\t})\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/router.tag\n **/","var Arbiter = require(\"promissory-arbiter\");\n\nriot.tag2('signuporsignin', '<div class=\"ui two column middle aligned very relaxed stackable padded grid\"> <div class=\"center aligned column\"> <div class=\"ui small blue labeled icon button\" onclick=\"{activeLogin}\"> <i class=\"sign in icon\"></i> Login </div> <div class=\"content\"> <div class=\"description light padding\">Sign in using your Open Account</div> </div> </div> <div class=\"ui vertical divider\"> Or </div> <div class=\"center aligned column\"> <div onclick=\"{registerUser}\" class=\"ui small green labeled icon button\"> <i class=\"signup icon\"></i> Sign Up </div> <div class=\"content\"> <div class=\"description light padding\">Create your Open Account</div> </div> </div> </div>', '', '', function(opts) {\n\n\tvar self = this;\n\n\tthis.activeLogin = function(){\n\t\tArbiter.publish('actions', {'action':'activate_modal', 'value':{'modal_name':'login', 'modal_state':'active'}});\n\t}\n\tthis.registerUser = function(){\n\t\tArbiter.publish('actions', {'action':'activate_modal', 'value':{'modal_name':'registration', 'modal_state':'active'}});\n\t}\n\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/signuporsignin.tag\n **/","riot.tag2('topnav', '<div class=\"ui container\"> <div class=\"ui text menu\"> <div class=\"item\"> <only-logo></only-logo> </div> </div> </div>', '', '', function(opts) {\n});\n\n\n/** WEBPACK FOOTER **\n ** ./components/topnav.tag\n **/","var Arbiter = require(\"promissory-arbiter\");\n\nvar Store = require(\"../store/index.js\");\n\n\nriot.tag2('tsform', '<div onsubmit=\"{submitForm}\" class=\"ui form\"> <div each=\"{form.fields}\" class=\"required field\"> <label>{label}</label> <input type=\"{input_type}\" name=\"{name}\" onkeyup=\"{updateStoreForm}\" placeholder=\"{placeholder}\"> </div> </div>', '', '', function(opts) {\n\n\n\tvar self = this;\n\n\tthis.submitForm = function(){\n\t\tArbiter.publish('actions', {'action':self.content.action, 'payload': {}});\n\t}\n\n\tthis.updateStoreForm = function(e){\n\t\tself[e.item.name] = e.target.value;\n\t\tvar name = self.opts.content.name;\n\t\tconsole.log('--------> field', self.opts.content.name, name, e.item.name, 'value', self[e.item.name]);\n\t\tArbiter.publish('actions', {'action':'update_form', 'value': {'form': name, 'field':e.item.name, 'value':self[e.item.name]}});\n\t}\n\n\tthis.on(\"update\", function(){\n\t\tself.form = self.opts.content;\n\t\tconsole.log(\"form\", self.opts, self.content, self.data);\n\t});\n\n\tthis.on(\"mount\", function(){\n\t\tself.form = self.opts.formdata;\n\t\tconsole.log(\"form\", self.opts, self.content, self.data);\n\t});\n\n});\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/tsform.tag\n **/","var Arbiter = require(\"promissory-arbiter\");\n\nvar actions = {\n  macaroon_received: function(value) {\n\tArbiter.publish('mutations', {'mutation':'update_macaroon', 'value':{'state':'macaroon_received', 'value':value}});\n  },\n  activate_modal: function(value) {\n  \tArbiter.publish('mutations', {'mutation':'update_modal_state', 'value':{'state':'modal_activated', 'value':value}});\n  },\n  deactivate_modal: function(value) {\n  \tArbiter.publish('mutations', {'mutation':'update_modal_state', 'value':{'state':'modal_deactivated', 'value':value}});\n  },\n  update_form: function(value) {\n    Arbiter.publish('mutations', {'mutation': 'update_form', 'value': {'state': 'update_form', 'value':value}});\n  },\n  login_succeeded: function(value) {\n\tArbiter.publish('mutations', {'mutation':'change_login_state', 'value':{'state':'login_succeeded', 'value':value}});\n  },\n  login_failed: function(value) {\n\tArbiter.publish('mutations', {'mutation':'change_login_state', 'value':{'state':'login_failed', 'value':value}});\n  },\n  submit_login: function(value) {\n\tArbiter.publish('mutations', {'mutation':'change_login_state', 'value':{'state':'login_submitted', 'credentials':value}});\n  },\n  submit_login_remote: function(value){\n  \tArbiter.publish('mutations', {'mutation':'created_job_request', 'value':{'state':'submit_login_remote',  'value':value}});\n  },\t\n  change_route: function(value) {\n    console.log('actions---> change route');\n  \tArbiter.publish('change_route', value);\n  },\n  startup_selected_or_created: function (value) {\n    Arbiter.publish('set_selected_or_created', value);\n  },\n  create_job: function (value) {\n    Arbiter.publish('mutations', {'mutation':'created_job_request', 'value':{'state':'created_job_request', 'value':value}});\n  },\n  set_job_as_fulfilled: function(payload){\n  \tArbiter.publish('mutations', {'mutation':'set_job_as_fulfilled', 'value': {'state':'set_job_as_fulfilled', 'value':payload['value']}});\n  },\n  add_job_id: function (value) {\n    Arbiter.publish('mutations', {'mutation': 'add_job_id', 'value':{'state':'jobs', 'value':value}});\n  }\n};\n\nArbiter.subscribe('actions', function(value, action){\n\tconsole.log(\"actions--->\", action,\"value----->\", value['action'])\n\tactions[value['action']](value['value']);\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./actions/index.js\n **/","var riot = require(\"riot\")\n\nrequire('./components/router.tag')\nrequire('./components/macaroon.tag')\nrequire('./components/only-logo.tag')\nrequire('./components/topnav.tag')\nrequire('./components/modal.tag')\nrequire('./components/signuporsignin.tag')\nrequire('./components/job.tag')\nrequire('./components/control.tag')\nrequire('./components/app.tag')\nrequire('./components/poller.tag')\nrequire('./components/homepage.tag')\nrequire('./components/drafteditpage.tag')\nrequire('./components/anon_homepage.tag')\nrequire('./components/loggedin_homepage.tag')\nrequire('./components/login.tag')\nrequire('./components/tsform.tag')\n\nriot.mount('#app', 'app')\n\n\n\n/** WEBPACK FOOTER **\n ** ./main.js\n **/","/**\n * DEVELOPED BY\n * GIL LOPES BUENO\n * gilbueno.mail@gmail.com\n *\n * WORKS WITH:\n * IE 9+, FF 4+, SF 5+, WebKit, CH 7+, OP 12+, BESEN, Rhino 1.7+\n *\n * FORK:\n * https://github.com/melanke/Watch.JS\n */\n\n\"use strict\";\n(function (factory) {\n    if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like enviroments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(factory);\n    } else {\n        // Browser globals\n        window.WatchJS = factory();\n        window.watch = window.WatchJS.watch;\n        window.unwatch = window.WatchJS.unwatch;\n        window.callWatchers = window.WatchJS.callWatchers;\n    }\n}(function () {\n\n    var WatchJS = {\n        noMore: false\n    },\n    defineWatcher,\n    unwatchOne,\n    callWatchers;\n\n    var isFunction = function (functionToCheck) {\n            var getType = {};\n            return functionToCheck && getType.toString.call(functionToCheck) == '[object Function]';\n    };\n\n    var isInt = function (x) {\n        return x % 1 === 0;\n    };\n\n    var isArray = function(obj) {\n        return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n\n    var isModernBrowser = function () {\n        return Object.defineProperty || Object.prototype.__defineGetter__;\n    };\n\n    var defineGetAndSet = function (obj, propName, getter, setter) {\n        try {\n                Object.defineProperty(obj, propName, {\n                        get: getter,\n                        set: setter,\n                        enumerable: true,\n                        configurable: true\n                });\n        } catch(error) {\n            try{\n                Object.prototype.__defineGetter__.call(obj, propName, getter);\n                Object.prototype.__defineSetter__.call(obj, propName, setter);\n            }catch(error2){\n                throw \"watchJS error: browser not supported :/\"\n            }\n        }\n    };\n\n    var defineProp = function (obj, propName, value) {\n        try {\n            Object.defineProperty(obj, propName, {\n                enumerable: false,\n                configurable: true,\n                writable: false,\n                value: value\n            });\n        } catch(error) {\n            obj[propName] = value;\n        }\n    };\n\n    var watch = function () {\n\n        if (isFunction(arguments[1])) {\n            watchAll.apply(this, arguments);\n        } else if (isArray(arguments[1])) {\n            watchMany.apply(this, arguments);\n        } else {\n            watchOne.apply(this, arguments);\n        }\n\n    };\n\n\n    var watchAll = function (obj, watcher, level) {\n\n        if (obj instanceof String || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\n            return;\n        }\n\n        var props = [];\n\n\n        if(isArray(obj)) {\n            for (var prop = 0; prop < obj.length; prop++) { //for each item if obj is an array\n                props.push(prop); //put in the props\n            }\n        } else {\n            for (var prop2 in obj) { //for each attribute if obj is an object\n                props.push(prop2); //put in the props\n            }\n        }\n\n        watchMany(obj, props, watcher, level); //watch all itens of the props\n    };\n\n\n    var watchMany = function (obj, props, watcher, level) {\n\n        for (var prop in props) { //watch each attribute of \"props\" if is an object\n            watchOne(obj, props[prop], watcher, level);\n        }\n\n    };\n\n    var watchOne = function (obj, prop, watcher, level) {\n\n        if(isFunction(obj[prop])) { //dont watch if it is a function\n            return;\n        }\n\n        if(obj[prop] != null && (level === undefined || level > 0)){\n            if(level !== undefined){\n                level--;\n            }\n            watchAll(obj[prop], watcher, level); //recursively watch all attributes of this\n        }\n\n        defineWatcher(obj, prop, watcher);\n\n    };\n\n    var unwatch = function () {\n\n        if (isFunction(arguments[1])) {\n            unwatchAll.apply(this, arguments);\n        } else if (isArray(arguments[1])) {\n            unwatchMany.apply(this, arguments);\n        } else {\n            unwatchOne.apply(this, arguments);\n        }\n\n    };\n\n    var unwatchAll = function (obj, watcher) {\n\n        if (obj instanceof String || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\n            return;\n        }\n\n        var props = [];\n\n\n        if (isArray(obj)) {\n            for (var prop = 0; prop < obj.length; prop++) { //for each item if obj is an array\n                props.push(prop); //put in the props\n            }\n        } else {\n            for (var prop2 in obj) { //for each attribute if obj is an object\n                props.push(prop2); //put in the props\n            }\n        }\n\n        unwatchMany(obj, props, watcher); //watch all itens of the props\n    };\n\n\n    var unwatchMany = function (obj, props, watcher) {\n\n        for (var prop2 in props) { //watch each attribute of \"props\" if is an object\n            unwatchOne(obj, props[prop2], watcher);\n        }\n    };\n\n    if(isModernBrowser()){\n\n        defineWatcher = function (obj, prop, watcher) {\n\n            var val = obj[prop];\n\n            watchFunctions(obj, prop);\n\n            if (!obj.watchers) {\n                defineProp(obj, \"watchers\", {});\n            }\n\n            if (!obj.watchers[prop]) {\n                obj.watchers[prop] = [];\n            }\n\n\n            obj.watchers[prop].push(watcher); //add the new watcher in the watchers array\n\n\n            var getter = function () {\n                return val;\n            };\n\n\n            var setter = function (newval) {\n                var oldval = val;\n                val = newval;\n\n                if (obj[prop]){\n                    watchAll(obj[prop], watcher);\n                }\n\n                watchFunctions(obj, prop);\n\n                if (!WatchJS.noMore){\n                    if (JSON.stringify(oldval) !== JSON.stringify(newval)) {\n                        callWatchers(obj, prop, \"set\", newval, oldval);\n                        WatchJS.noMore = false;\n                    }\n                }\n            };\n\n            defineGetAndSet(obj, prop, getter, setter);\n\n        };\n\n        callWatchers = function (obj, prop, action, newval, oldval) {\n\n            for (var wr in obj.watchers[prop]) {\n                if (isInt(wr)){\n                    obj.watchers[prop][wr].call(obj, prop, action, newval, oldval);\n                }\n            }\n        };\n\n        // @todo code related to \"watchFunctions\" is certainly buggy\n        var methodNames = ['pop', 'push', 'reverse', 'shift', 'sort', 'slice', 'unshift'];\n        var defineArrayMethodWatcher = function (obj, prop, original, methodName) {\n            defineProp(obj[prop], methodName, function () {\n                var response = original.apply(obj[prop], arguments);\n                watchOne(obj, obj[prop]);\n                if (methodName !== 'slice') {\n                    callWatchers(obj, prop, methodName,arguments);\n                }\n                return response;\n            });\n        };\n\n        var watchFunctions = function(obj, prop) {\n\n            if ((!obj[prop]) || (obj[prop] instanceof String) || (!isArray(obj[prop]))) {\n                return;\n            }\n\n            for (var i = methodNames.length, methodName; i--;) {\n                methodName = methodNames[i];\n                defineArrayMethodWatcher(obj, prop, obj[prop][methodName], methodName);\n            }\n\n        };\n\n        unwatchOne = function (obj, prop, watcher) {\n            for(var i in obj.watchers[prop]){\n                var w = obj.watchers[prop][i];\n\n                if(w == watcher) {\n                    obj.watchers[prop].splice(i, 1);\n                }\n            }\n        };\n\n    } else {\n        //this implementation dont work because it cant handle the gap between \"settings\".\n        //I mean, if you use a setter for an attribute after another setter of the same attribute it will only fire the second\n        //but I think we could think something to fix it\n\n        var subjects = [];\n\n        defineWatcher = function(obj, prop, watcher){\n\n            subjects.push({\n                obj: obj,\n                prop: prop,\n                serialized: JSON.stringify(obj[prop]),\n                watcher: watcher\n            });\n\n        };\n\n        unwatchOne = function (obj, prop, watcher) {\n\n            for (var i in subjects) {\n                var subj = subjects[i];\n\n                if (subj.obj == obj && subj.prop == prop && subj.watcher == watcher) {\n                    subjects.splice(i, 1);\n                }\n\n            }\n\n        };\n\n        callWatchers = function (obj, prop, action, value) {\n\n            for (var i in subjects) {\n                var subj = subjects[i];\n\n                if (subj.obj == obj && subj.prop == prop) {\n                    subj.watcher.call(obj, prop, action, value);\n                }\n\n            }\n\n        };\n\n        var loop = function(){\n\n            for(var i in subjects){\n\n                var subj = subjects[i];\n                var newSer = JSON.stringify(subj.obj[subj.prop]);\n                if(newSer != subj.serialized){\n                    subj.watcher.call(subj.obj, subj.prop, subj.obj[subj.prop], JSON.parse(subj.serialized));\n                    subj.serialized = newSer;\n                }\n\n            }\n\n        };\n\n        setInterval(loop, 50);\n\n    }\n\n    WatchJS.watch = watch;\n    WatchJS.unwatch = unwatch;\n    WatchJS.callWatchers = callWatchers;\n\n    return WatchJS;\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/watchjs/src/watch.js\n ** module id = 22\n ** module chunks = 0\n **/","module.exports = __webpack_amd_options__;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/buildin/amd-options.js\n ** module id = 23\n ** module chunks = 0\n **/"],"sourceRoot":""}